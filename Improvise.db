** LambdaMOO Database, Format Version 13 **
2
5
6
0 values pending finalization
0 clocks
0 queued tasks
0 suspended tasks
0 interrupted tasks
0 active connections with listeners
138
#0
System
16
2
1
2
4
0
4
6
1
3
1
24
1
77
1
91
1
117
1
130
4
0
26
_log_error
5
172
-1
server_started
5
172
-1
do_login_command
5
172
-1
authenticate
2
172
-1
private
5
172
-1
protected
5
172
-1
restrict_to_server
2
172
-1
restrict_to_builtin
2
172
-1
restrict_to_caller
5
172
-1
permit
5
172
-1
check_create_permission
2
172
-1
check_controls
2
172
-1
_unpack_verb_code
2
172
-1
_pack_verb_code
2
172
-1
bf_verb_code verb_code
5
172
-1
bf_set_verb_code set_verb_code
5
172
-1
verb_detail
5
172
-1
_parse_content_type
2
172
-1
_generate_content_type
2
172
-1
verb_commit
5
172
-1
verb_revert
5
172
-1
lookup*_reference
5
172
-1
_match_external_compiler
2
172
-1
grant
5
172
-1
revoke
5
172
-1
match_permit
5
172
-1
17
system
server_options
nothing
ambiguous_match
failed_match
passkey_players
disable_passkey_login
external_compilers
last_login_connection
welcome_message
epoch
core
plastic
model
dialog
mustache
alt
34
1
0
2
1
1
1
2
1
1
-1
2
1
1
-2
2
1
1
-3
2
1
4
2
1
5
1
6
5
0
0
0
5
0
10
2
2
application/x-moocode;version=0.0.*
1
43
2
application/x-mustache
1
114
2
1
0
0
2
1
2
Welcome to Stunt!  For information about Stunt, check out http://stunt.io/.  To connect to the server, type "connect <credentials>".
2
1
0
0
2
1
1
13
11
1
1
40
38
1
1
80
79
1
1
95
93
1
1
113
111
1
1
123
121
1
5
2
1
5
2
1
5
2
1
5
2
1
5
23
1
5
23
1
5
23
1
5
23
1
5
23
1
5
23
1
5
23
1
5
23
1
5
75
1
5
75
1
5
89
1
5
115
1
5
115
1
#1
Server Options
16
2
1
2
4
0
4
0
4
0
0
25
support_numeric_verbname_strings
protect_verb_code
protect_set_verb_code
max_concat_catchable
max_string_concat
max_list_value_bytes
max_map_value_bytes
fg_seconds
fg_ticks
bg_seconds
bg_ticks
connect_timeout
outbound_connect_timeout
name_lookup_timeout
max_stack_depth
queued_task_limit
default_flush_command
boot_msg
connect_msg
create_msg
recycle_msg
redirect_from_msg
redirect_to_msg
server_full_msg
timeout_msg
25
0
0
2
1
0
1
2
0
0
1
2
0
0
1
2
0
0
64537861
2
0
0
64537861
2
0
0
64537861
2
0
0
5
2
0
0
60000
2
0
0
3
2
0
0
30000
2
0
0
300
2
0
0
5
2
0
0
5
2
0
0
50
2
0
0
-1
2
0
2
.flush
2
0
2
*** Disconnected ***
2
0
2
*** Connected ***
2
0
2
*** Created ***
2
0
2
*** Recycled ***
2
0
2
*** Redirecting connection to new port ***
2
0
2
*** Redirecting old connection to this port ***
2
0
4
2
2
*** Sorry, but the server cannot accept any more connections right now. ***
2
*** Please try again later. ***
2
0
2
*** Timed-out waiting for login. ***
2
0
#2
Kernel Package
16
2
1
-1
4
8
1
0
1
1
1
3
1
10
1
4
1
7
1
8
1
9
4
0
4
0
0
11
identifier
version
manifest
relocate
requires
provides
instructions
description
authors
homepage
license
11
2
kernel
2
1
2
1.1.4
2
1
4
10
4
2
1
2
2
package
4
2
1
0
2
system
4
2
1
1
2
server_options
4
2
1
3
2
dictionary
4
2
1
10
2
changelog
4
2
1
4
2
object
4
2
1
8
2
shapes
4
2
1
9
2
composed
4
2
1
5
2
wizard
4
2
1
6
2
programmer
2
1
4
7
2
system.system
2
system.server_options
2
dictionary.kernel
2
dictionary.object
2
dictionary.shapes
2
dictionary.composed
2
system.passkey_players
2
1
4
0
2
1
4
0
2
1
4
1
2
install-dictionary
2
1
2
The kernel package comprises the minimal set of objects necessary to hack on and/or bootstrap a core.
2
1
4
1
2
Todd Sundsted
2
1
2
http://stunt.io/packages/kernel
2
1
2
FreeBSD License
2
1
#3
Kernel Dictionary
16
2
1
2
4
0
4
0
4
1
1
0
4
handle_uncaught_error
5
172
-1
handle_task_timeout
5
172
-1
server_started
5
172
-1
authenticate
5
172
-1
4
kernel
object
shapes
composed
4
1
3
2
1
1
4
2
1
1
8
2
1
1
9
2
1
#4
Object
144
2
1
2
4
0
1
-1
4
19
1
8
1
9
1
7
1
12
1
43
1
44
1
74
1
82
1
83
1
92
1
96
1
97
1
100
1
108
1
109
1
114
1
118
1
119
1
125
0
1
aliases
1
4
0
2
4
#5
Wizard
7
5
1
7
4
0
1
127
4
0
2
@strip-db-and-shutdown
5
8
-1
huh
5
172
-1
1
passkey
3
0
0
5
0
5
5
4
5
5
4
#6
Programmer
3
6
1
7
4
0
1
126
4
0
0
1
passkey
3
0
0
5
0
5
6
4
5
6
4
#7
Home
0
6
1
2
4
2
1
5
1
6
1
4
4
0
1
eval*uate
5
88
-2
0
1
5
6
4
#8
Shapes, Serialization/Deserialization Library
0
2
1
2
4
0
1
4
4
0
23
_log
5
172
-1
_suspend_if_necessary
2
172
-1
_controls controls
2
164
-1
_controls_verb
5
164
-1
_controls_property
5
164
-1
objects
5
172
-1
read_object
5
172
-1
write_object
5
172
-1
_parent_property_info
5
172
-1
_values
5
172
-1
values
5
172
-1
read_value
5
172
-1
write_value
5
172
-1
_write_parents
5
172
-1
_write_player
5
172
-1
read_verb
5
172
-1
write_verb
5
172
-1
read_property
5
172
-1
write_property
5
172
-1
bare_object
2
172
-1
add_value
2
172
-1
add_property_definition
2
172
-1
add_verb_definition
2
172
-1
0
1
5
2
4
#9
Composed, Component Library
0
2
1
2
4
0
1
4
4
0
47
_log
5
172
-1
_move
5
172
-1
_suspend_if_necessary
2
172
-1
_parse_specifier
2
172
-1
_parse_operation
2
172
-1
_parse_version
2
172
-1
_compare_versions
2
172
-1
_sort_versions
2
172
-1
_match match
2
172
-1
_map_specifier
2
172
-1
_unmap_specifier
2
172
-1
_install
2
172
-1
_uninstall
2
172
-1
_find_requires_provider
2
172
-1
reinitialize
2
172
-1
_check_required_provides
2
172
-1
_check_provided_requires
2
172
-1
_generate_global_mapping_keyed_on_object
5
172
-1
_generate_global_mapping_keyed_on_identifier
5
172
-1
_map
2
172
-1
_lookup
2
164
-1
_lookup_by_object
2
172
-1
_lookup_by_label
2
172
-1
_is_ancestor
2
172
-1
_contents
2
172
-1
install
5
172
-1
uninstall
5
172
-1
delete
5
172
-1
_set_seconds_and_ticks
5
172
-1
_reset_seconds_and_ticks
5
172
-1
import
5
172
-1
export
5
172
-1
_parse_url
2
164
-1
_fetch
5
172
-1
fetch_index
2
172
-1
fetch_package_to_cache
2
172
-1
import_package_from_archive
5
172
-1
import_package_from_cache
5
172
-1
export_package_to_cache
5
172
-1
import_package_from_file
5
172
-1
export_package_to_file
5
172
-1
pretty_print_cached_package
5
172
-1
@install
5
156
0
@uninstall
5
156
0
@list
5
156
0
_do_instructions
5
172
-1
_undo_instructions
5
172
-1
7
packages
provides_cache
requires_cache
last_fetch_index
archived
cached
archive_sources
8
4
14
1
2
1
11
1
23
1
38
1
72
1
75
1
79
1
89
1
93
1
104
1
111
1
115
1
121
1
128
2
0
10
14
2
alt
10
1
2
0.0.3
4
1
1
121
2
application
10
1
2
0.0.9
4
1
1
128
2
ask
10
1
2
0.0.2
4
1
1
75
2
core
10
1
2
0.0.2
4
1
1
11
2
dialog
10
1
2
0.1.1
4
1
1
93
2
dialog_extras
10
1
2
0.0.5
4
1
1
104
2
identity
10
1
2
0.0.2
4
1
1
115
2
kernel
10
1
2
1.1.4
4
1
1
2
2
model
10
1
2
0.0.1
4
1
1
79
2
mustache
10
1
2
1.0.1
4
1
1
111
2
persistent
10
1
2
0.0.2
4
1
1
89
2
plastic
10
1
2
0.0.3
4
1
1
38
2
primitive
10
1
2
0.0.4
4
1
1
23
2
text_tools
10
1
2
0.0.1
4
1
1
72
2
0
10
8
2
ask
10
1
2
0.0.2
4
1
1
79
2
core
10
1
2
0.0.2
4
4
1
38
1
93
1
104
1
121
2
dialog
10
1
2
0.1.1
4
2
1
104
1
128
2
dialog_extras
10
1
2
0.0.5
4
1
1
128
2
kernel
10
1
2
1.1.4
4
12
1
11
1
23
1
38
1
72
1
75
1
79
1
89
1
93
1
104
1
111
1
115
1
121
2
plastic
10
1
2
0.0.3
4
4
1
93
1
104
1
121
1
128
2
primitive
10
1
2
0.0.4
4
7
1
38
1
72
1
75
1
93
1
104
1
111
1
121
2
text_tools
10
1
2
0.0.1
4
1
1
121
2
0
0
0
2
0
10
0
2
0
10
0
2
0
4
1
2
http://stunt.io/v2/packages.json
2
0
5
2
4
#10
Changelog
16
2
1
2
4
0
1
-1
4
0
1
log
2
172
-1
71
1311681611
1311705199
1313452513
1315679164
1315956214
1316093967
1316094064
1317297266
1317487599
1317741809
1319025014
1319537884
1320954195
1321316054
1321356258
1321643106
1321643582
1323085326
1323087749
1328836140
1329004700
1329006449
1329757584
1329871032
1329874322
1331122162
1336415098
1336415121
1336415146
1336420618
1337254948
1337555791
1338032579
1338035085
1338035909
1338138322
1338138532
1338169765
1338239921
1338256684
1338511433
1338810704
1338810739
1338986468
1339116074
1339119035
1339159099
1339716849
1341319605
1341918651
1341919633
1352859577
1354716719
1355401890
1356004499
1356004559
1356009919
1356610770
1357132259
1357402056
1357415815
1357446795
1357452296
1357929752
1357994951
1358784518
1358785509
1360437901
1360668144
1360897124
1360897245
71
2
Added code to disable login by passkey players.
2
1
2
Added code to write a warning to the log when passkey authentication is enabled.
2
1
2
Moved passkey_login and passkey_players to the system object (#0) so that they are harder to subvert.
2
1
2
Updated `strip-core-and-shutdown' verb to reflect passkey changes.
2
1
2
Fixed incorrect implementation of specified test for a built-in function entry.
2
1
2
Added kernel support for enhanced verb programming.
2
1
2
Removed all verbs on core wiz/prog location except `map' and `eval'.
2
1
2
Added support for `chunk_length'.
2
1
2
Added support for `content_type'.
2
1
2
Removed `map' verb from core wiz/prog location.
2
1
2
Changed `restrict_to_caller' to check the object on which the verb was defined, instead of used.
2
1
2
Fixed scope bug in `$lookup()'.
2
1
2
Added `$configuration' -- package independent, per-environment, per-server configuration goes/stays here.
2
1
2
`$lookup()' now allows wizards to specify the package to search.
2
1
2
`$composed' no longer assumes the existence of `$sysobj'.
2
1
2
Remove `$configuration' -- replaced it with an app-specific property.
2
1
2
Added `import_package_from_file()' and `export_package_to_file' to `$composed'.
2
1
2
Added a welcome message and cleaned up `do_login_command()' and `authenticate()'.
2
1
2
Shape" is now called "Shapes".
2
1
2
Reset `#0.last_login_connection' on server start.
2
1
2
Tweaks to use the new for loop syntax.
2
1
2
Moved verb `audit' out of $composed.
2
1
2
`$verb_detail()' handles the case where `caller_perms()' is `$nothing'.
2
1
2
Added `fg/bg_seconds', `fg/bg_ticks' and `max_concat_catchable' properties to `$server_options'.
2
1
2
In the `@import' command, set the seconds/ticks to a large number so suspending is not necessary.
2
1
2
Fixed `reinitialize()' so that it was smarter with `args'.
2
1
2
`$composed' defaults to the existing content type if none is specified.
2
1
2
Verb metadata includes the sha1 of the verb source.
2
1
2
`$verb_detail()' returns the verb metadata.
2
1
2
In `$composed', better error messages when `relocate' holds a bad reference.
2
1
2
Promoted `$shapes:_controls()' to public and reduced perms.
2
1
2
Fixed regular expressions that were matching "." instead of "%.".
2
1
2
Made the default behavior of `bf_verb_code()' match the builtin.
2
1
2
Options should be dashed not underscored.
2
1
2
The fourth arg is the content type.
2
1
2
Added `state' and `revision' to verb metadata, and added verb version control verbs.
2
1
2
Added `updated_by' to verb metadata.
2
1
2
Use `read_http()' in `_fetch_from_archive()'.
2
1
2
Moved instruction handling into `install()' and `uninstall()'/`delete()'.
2
1
2
Make sure the player isn't inside of the package he/she/it is about to delete.
2
1
2
Handle options correctly on install with implicit identifier and version.
2
1
2
Added package-scoped lookup (e.g. `$lookup("object|kernel")').
2
1
2
Moved `$lookup_reference()' to `$system'.
2
1
2
Properly check the file handle when importing/exporting from/to a file.
2
1
2
Don't include unnecessary metadata in output from `read_verb()'.
2
1
2
Do not version or stamp verbs on `import()'.
2
1
2
`$verb_revert()' now reverts the raw verb code, too.
2
1
2
Fixed bug in tilde handling in `_fetch_from_archive()'.
2
1
2
Added ticks/seconds checks in `_unpack/_pack_verb_code()'.
2
1
2
Handle errors fetching from the archive better.
2
1
2
Lookup objects in an object's package even if the specified is explicit.
2
1
2
Give `$protected()' and `$private()' wiz-perms so that they can inspect anonymous objects.
2
1
2
Give `$permit()' wiz-perms so that it can inspect anonymous objects.
2
1
2
Changed the requirement for compiler output in `set_verb_code()'.
2
1
2
Created new version: 1.1.2.
2
1
2
Enabled support for versioning external compilers.
2
1
2
The `reinitialize()' verb restores state on failure.
2
1
2
Added support for anonymous objects to `$shapes'.
2
1
2
Don't write clear values.
2
1
2
`_fetch()' follows HTTP redirects.
2
1
2
Added support for multiple archive sources.
2
1
2
Added all known server options to `$server_options'.
2
1
2
Ensure non-local objects belong to the owner of the package.
2
1
2
Added `$grant()', `$revoke()' and permissions.
2
1
2
Better diagnostics for multiple archive sources.
2
1
2
Created new version: 1.1.3.
2
1
2
Added `$epoch' to track restarts.
2
1
2
Give `$restrict_to_caller()' wiz-perms.
2
1
2
Created new version: 1.1.4.
2
1
2
Fixed handling of "~" in archive sources.
2
1
2
Swallow errors raised when moving objects during installation.
2
1
#11
Core Package
0
11
1
-1
4
7
1
12
1
13
1
14
1
15
1
20
1
21
1
22
4
1
1
12
4
0
0
0
12
2
core
11
5
2
0.0.2
11
5
4
12
4
2
1
11
2
package
4
2
1
13
2
dictionary
4
2
1
14
2
changelog
4
2
1
15
2
utility
4
2
1
16
2
regexp_utilities
4
2
1
17
2
time_utilities
4
2
1
18
2
file_utilities
4
2
1
19
2
object_utilities
4
2
1
12
2
package_proto
4
2
1
20
2
permit_base_proto
4
2
1
21
2
change_owner_permit_proto
4
2
1
22
2
file_io_proto
11
5
4
12
2
dictionary.utility
2
dictionary.permit_base_proto
2
dictionary.change_owner_permit_proto
2
dictionary.file_io_proto
2
utility.regexp
2
utility.time
2
utility.file
2
utility.object
2
regexp_utilities.core
2
time_utilities.core
2
object_utilities.change_owner_permit_proto
2
file_utilities.file_io_proto
11
5
4
1
4
2
2
kernel
2
>= 1.1.3
11
5
5
11
5
4
1
2
install-namespace
11
5
2
The Core package contains objects that work with and/or extend the Kernel package.
11
5
4
1
2
Todd Sundsted
11
5
5
11
5
2
FreeBSD License
11
5
5
11
4
#12
Package Prototype
144
11
1
11
4
0
4
1
1
4
4
1
1
11
1
acceptable accept
11
172
-1
11
identifier
version
manifest
relocate
requires
provides
instructions
description
authors
homepage
license
12
2

11
5
2

11
5
4
0
11
5
4
0
11
5
4
0
11
5
4
0
11
5
4
0
11
5
2

11
5
4
0
11
5
2

11
5
2

11
5
5
11
4
#13
Dictionary
16
11
1
11
4
0
1
-1
4
0
0
4
permit_base_proto
change_owner_permit_proto
file_io_proto
utility
4
1
20
11
1
1
21
11
1
1
22
11
1
1
15
11
1
#14
Changelog
0
11
1
11
4
0
1
-1
4
0
0
7
1336405818
1336406704
1357929776
1358113390
1358643384
1358712225
1358814995
7
2
Moved package prototype into package.
11
1
2
Raise exceptions like `move()' in the verb `acceptable()'.
11
1
2
Added permissions support.
11
1
2
Created new version: 0.0.2.
11
1
2
Added `$core.utility.time' and verbs.
11
1
2
Added `$core.utility.regexp' and verbs.
11
1
2
Added `$core.utility.file' and verbs.
11
1
#15
Utility Dictionary
16
11
1
11
4
4
1
16
1
17
1
18
1
19
1
-1
4
0
0
4
regexp
time
file
object
4
1
16
11
1
1
17
11
1
1
18
11
1
1
19
11
1
#16
Regular Expression Utilities
0
11
1
15
4
0
1
-1
4
0
9
original*_string
11
172
-1
matched*_string
11
172
-1
regexp*_source
11
172
-1
all_captured*_substrings
11
172
-1
at
11
172
-1
begin end
11
172
-1
offset
11
172
-1
post_match pre_match
11
172
-1
count
11
172
-1
1
core
1
1
13
11
0
#17
Time Utilities
0
11
1
15
4
0
1
-1
4
0
16
make_time
11
172
-1
parse_ctime from_ctime
11
172
-1
parse_w3c_time from_w3c_time
11
172
-1
_pluralize
11
172
-1
english_time
11
172
-1
now
11
172
-1
string_month
11
172
-1
string_day
11
172
-1
year month day hour minute second
11
172
-1
is_am is_pm
11
172
-1
zone
11
172
-1
is_dst
11
172
-1
is_sunday is_monday is_tuesday is_wednesday is_thursday is_friday is_saturday
11
172
-1
format substitute
11
172
-1
rfc1123_time
11
172
-1
w3c_time
11
172
-1
7
core
months
months_short
days
days_short
time_zones
dst_zones
7
1
13
11
0
4
12
2
January
2
February
2
March
2
April
2
May
2
June
2
July
2
August
2
September
2
October
2
November
2
December
11
1
4
12
2
Jan
2
Feb
2
Mar
2
Apr
2
May
2
Jun
2
Jul
2
Aug
2
Sep
2
Oct
2
Nov
2
Dec
11
1
4
7
2
Sunday
2
Monday
2
Tuesday
2
Wednesday
2
Thursday
2
Friday
2
Saturday
11
1
4
7
2
Sun
2
Mon
2
Tue
2
Wed
2
Thu
2
Fri
2
Sat
11
1
10
9
2
CDT
0
5
2
CST
0
6
2
EDT
0
4
2
EST
0
5
2
GMT
0
0
2
MDT
0
6
2
MST
0
7
2
PDT
0
7
2
PST
0
8
11
1
4
4
2
CDT
2
EDT
2
MDT
2
PDT
11
1
#18
File Utilities
0
11
1
15
4
0
1
-1
4
0
2
_fix_mode
11
172
-1
open
5
172
-1
1
file_io_proto
1
1
22
11
0
#19
Object Utilities
16
11
1
15
4
0
1
-1
4
0
2
verbs properties
5
172
-1
change_owner
5
172
-1
1
change_owner_permit_proto
1
1
21
11
0
#20
Permit Base Prototype
144
11
1
11
4
0
1
-1
4
1
1
21
2
create_for_subject
5
172
-1
permit
5
172
-1
1
subject
1
0
0
11
4
#21
Change Owner Permit Prototype
272
11
1
11
4
0
4
1
1
20
4
0
0
0
1
5
11
4
#22
File I/O Prototype
0
11
1
11
4
0
1
-1
4
0
10
initialize
5
172
-1
recycle
5
172
-1
_invalidate
11
172
-1
close
5
172
-1
is_open is_closed
11
172
-1
is_text is_binary
11
172
-1
is_readable is_writeable
11
172
-1
readline writeline read write
5
172
-1
tell seek size
5
172
-1
is_eof
5
172
-1
3
file_handle
epoch
mode
3
0
-1
11
0
0
0
11
0
2

11
0
#23
Primitive Package
0
23
1
-1
4
14
1
24
1
25
1
26
1
27
1
28
1
29
1
30
1
31
1
32
1
33
1
34
1
35
1
36
1
37
1
-1
4
0
0
10
identifier
version
manifest
relocate
requires
instructions
description
authors
homepage
license
10
2
primitive
23
1
2
0.0.4
23
1
4
10
4
2
1
23
2
package
4
2
1
24
2
dictionary
4
2
1
25
2
changelog
4
2
1
28
2
int_proto
4
2
1
29
2
float_proto
4
2
1
31
2
str_proto
4
2
1
32
2
err_proto
4
2
1
33
2
list_proto
4
2
1
34
2
map_proto
4
2
1
35
2
lambda_proto
23
1
4
8
2
dictionary.int_proto
2
dictionary.float_proto
2
dictionary.str_proto
2
dictionary.err_proto
2
dictionary.list_proto
2
dictionary.map_proto
2
dictionary.lambda_proto
2
dictionary.frobs
23
1
4
1
4
2
2
kernel
2
>= 1.0.4
23
1
4
1
2
install-dictionary
23
1
2
The primitive package comprises prototype objects for LambdaMOO primitive data-types, utility operations on primitives, and objects for basic functional-style programming.
23
1
4
1
2
Todd Sundsted
23
1
2
http://stunt.io/packages/primitive
23
1
2
FreeBSD License
23
1
#24
Primitive Dictionary
0
23
1
23
4
0
1
-1
4
1
1
0
1
lambda
23
172
-1
8
int_proto
float_proto
str_proto
err_proto
list_proto
map_proto
frobs
lambda_proto
8
1
28
23
1
1
29
23
1
1
31
23
1
1
32
23
1
1
36
23
1
1
37
23
1
4
1
1
35
23
1
1
35
23
1
#25
Changelog
0
23
1
23
4
0
1
-1
4
0
0
10
1321837971
1322305336
1329066914
1356485946
1356524573
1358112743
1358256500
1358256855
1359228791
1359457658
10
2
Added support for functional-style programming via string lambdas.
23
1
2
Implemented first-pass primitives (with tests) including basic support for functional-style programming.
23
1
2
Updated verbs to use the new for loop syntax.
23
1
2
Created new version: 0.0.3.
23
1
2
The `split()' verb now splits on empty string as a special case.
23
1
2
Extensive additions to map, list, string and integer prototypes.
23
1
2
Created new version: 0.0.4.
23
1
2
Made `match()'/`rmatch()' their own verbs and appended verb arguments to the result.
23
1
2
Added `first()' and `last()' verbs to the list prototype.
23
1
2
Added `next()' and `previous()' verbs to the string prototype.
23
1
#26
Base Primitive
0
23
1
23
4
0
1
-1
4
6
1
28
1
29
1
31
1
32
1
33
1
34
3
_suspend_if_necessary
23
172
-1
type_of typeof
23
172
-1
to_json tojson
23
172
-1
0
0
#27
Numeric Primitive
0
23
1
23
4
0
1
-1
4
2
1
28
1
29
1
abs
23
172
-1
0
0
#28
Integer Prototype
0
23
1
23
4
0
4
2
1
26
1
27
4
0
7
up_to upto
5
172
-1
down_to downto
5
172
-1
is_even
23
172
-1
is_odd
23
172
-1
gcd
23
172
-1
lcm
23
172
-1
is_prime
23
172
-1
0
0
#29
Float Prototype
0
23
1
23
4
0
4
2
1
26
1
27
4
0
0
0
0
#30
Sequence Primitive
0
23
1
23
4
0
1
-1
4
3
1
31
1
33
1
34
10
_lambdafy
23
172
-1
each
5
172
-1
collect map
5
172
-1
inject reduce fold
5
172
-1
detect find
5
172
-1
select find_all
5
172
-1
reject
5
172
-1
every
5
172
-1
some
5
172
-1
length
23
172
-1
0
0
#31
String Prototype
0
23
1
23
4
0
4
2
1
26
1
30
4
0
26
to_lambda tolambda
23
172
-1
eval
5
172
-1
index rindex
23
172
-1
match rmatch
23
172
-1
split explode
23
172
-1
trim triml trimr
23
172
-1
strsub
23
172
-1
strtr
23
172
-1
repeat
23
172
-1
fill space
23
172
-1
right
23
172
-1
left
23
172
-1
center centre
23
172
-1
to_upper*case
23
172
-1
to_lower*case
23
172
-1
capitalize
23
172
-1
strip*_characters
23
172
-1
is_empty
23
172
-1
is_blank
23
172
-1
partition
23
172
-1
rpartition
23
172
-1
reverse
23
172
-1
squeeze
23
172
-1
next
23
172
-1
previous
23
172
-1
hash
23
172
-1
0
0
#32
Error Prototype
0
23
1
23
4
0
4
1
1
26
4
0
0
0
0
#33
List Prototype
0
23
1
23
4
0
4
2
1
26
1
30
4
1
1
36
27
to_lambda tolambda
23
172
-1
eval
5
172
-1
setadd
23
172
-1
setremove
23
172
-1
union
23
172
-1
intersection
23
172
-1
difference
23
172
-1
join
23
172
-1
sort
23
172
-1
reverse
23
172
-1
slice
23
172
-1
flatten
23
172
-1
dedup unique remove_duplicates
23
172
-1
compress
23
172
-1
remove_all
23
172
-1
repeat make
23
172
-1
count
23
172
-1
is_empty is_blank
23
172
-1
combinations
23
172
-1
permutations
23
172
-1
product
23
172
-1
rotate
23
172
-1
shuffle
23
172
-1
sample
23
172
-1
to_map
23
172
-1
first
23
172
-1
last
23
172
-1
0
0
#34
Map Prototype
0
23
1
23
4
0
4
2
1
26
1
30
4
1
1
37
12
keys
23
172
-1
values
23
172
-1
delete
23
172
-1
value_by_path
23
172
-1
set_value_by_path
23
172
-1
merge update
23
172
-1
is_empty is_blank
23
172
-1
has_key
23
172
-1
has_value
23
172
-1
invert
23
172
-1
slice
23
172
-1
to_list
23
172
-1
0
0
#35
Lambda Prototype
0
23
1
23
4
0
1
-1
4
0
8
create
23
172
-1
type_of typeof
23
172
-1
to_lambda tolambda
23
172
-1
_params_and_body
23
172
-1
_prepend_assignments
23
172
-1
partial
23
172
-1
bind
23
172
-1
call
5
172
-1
0
0
#36
List-Based Frob Prototype
0
23
1
23
4
0
4
1
1
33
4
0
1
*
5
172
-1
0
0
#37
Map-Based Frob Prototype
0
23
1
23
4
0
4
1
1
34
4
0
1
*
5
172
-1
0
0
#38
Plastic, MOOcode Parser Toolkit Package
16
38
1
-1
4
33
1
39
1
40
1
41
1
42
1
43
1
44
1
45
1
46
1
47
1
48
1
49
1
50
1
51
1
52
1
53
1
54
1
55
1
56
1
57
1
58
1
59
1
60
1
61
1
62
1
63
1
64
1
65
1
66
1
67
1
68
1
69
1
70
1
71
1
-1
4
0
2
after_install
5
172
-1
before_uninstall
5
172
-1
11
identifier
version
manifest
relocate
requires
provides
instructions
description
authors
homepage
license
11
2
plastic
38
1
2
0.0.3
38
1
4
34
4
2
1
38
2
package
4
2
1
39
2
changelog
4
2
1
40
2
dictionary
4
2
1
41
2
utilities
4
2
1
42
2
plastic_base_object
4
2
1
43
2
compiler
4
2
1
44
2
printer
4
2
1
45
2
tokenizer_proto
4
2
1
46
2
parser_proto
4
2
1
47
2
symbol_proto
4
2
1
48
2
literal_proto
4
2
1
50
2
statement_proto
4
2
1
51
2
operator_proto
4
2
1
52
2
control_flow_statement_proto
4
2
1
54
2
assignment_operator_proto
4
2
1
55
2
compound_assignment_operator_proto
4
2
1
56
2
prefix_operator_proto
4
2
1
53
2
infix_operator_proto
4
2
1
49
2
name_proto
4
2
1
57
2
bracket_operator_proto
4
2
1
58
2
brace_operator_proto
4
2
1
59
2
if_statement_proto
4
2
1
60
2
invocation_operator_proto
4
2
1
61
2
verb_selector_operator_proto
4
2
1
62
2
property_selector_operator_proto
4
2
1
63
2
error_catching_operator_proto
4
2
1
64
2
traditional_ternary_operator_proto
4
2
1
65
2
for_statement_proto
4
2
1
66
2
loop_statement_proto
4
2
1
67
2
fork_statement_proto
4
2
1
68
2
try_statement_proto
4
2
1
69
2
positional_symbol_proto
4
2
1
70
2
sign_operator_proto
4
2
1
71
2
from_statement_proto
38
1
4
37
2
dictionary.utilities
2
dictionary.compiler
2
dictionary.printer
2
dictionary.tokenizer_proto
2
dictionary.parser_proto
2
dictionary.symbol_proto
2
dictionary.literal_proto
2
dictionary.statement_proto
2
dictionary.operator_proto
2
dictionary.control_flow_statement_proto
2
dictionary.assignment_operator_proto
2
dictionary.compound_assignment_operator_proto
2
dictionary.prefix_operator_proto
2
dictionary.infix_operator_proto
2
dictionary.name_proto
2
dictionary.bracket_operator_proto
2
dictionary.brace_operator_proto
2
dictionary.if_statement_proto
2
dictionary.invocation_operator_proto
2
dictionary.verb_selector_operator_proto
2
dictionary.property_selector_operator_proto
2
dictionary.error_catching_operator_proto
2
dictionary.traditional_ternary_operator_proto
2
dictionary.for_statement_proto
2
dictionary.loop_statement_proto
2
dictionary.fork_statement_proto
2
dictionary.try_statement_proto
2
dictionary.positional_symbol_proto
2
dictionary.sign_operator_proto
2
dictionary.from_statement_proto
2
utilities.plastic
2
compiler.plastic
2
printer.plastic
2
tokenizer_proto.plastic
2
parser_proto.plastic
2
parser_proto.object_utilities
2
symbol_proto.plastic
38
1
4
3
4
2
2
kernel
2
>= 1.1.1
4
2
2
core
2
>= 0.0.1
4
2
2
primitive
2
>= 0.0.2
38
1
4
0
38
1
4
1
2
install-namespace
38
1
2
Plastic is the MOOcode parser toolkit.  It comprises an extended MOOcode language parser and compiler, and is compatible with the Stunt verb language extension mechanism.
38
1
4
1
2
Todd Sundsted
38
1
2
http://stunt.io/packages/plastic
38
1
2
FreeBSD License
38
1
#39
Changelog
16
38
1
38
4
0
1
-1
4
0
0
15
1331063405
1354983225
1355404149
1355712101
1356480216
1357566908
1357566938
1357571633
1357582940
1357593496
1357603194
1357912180
1357918770
1358255777
1360449360
15
2
Initial revision.
38
1
2
First-cut at migration from frobs to anonymous objects.
38
1
2
The first-cut is complete.
38
1
2
Added rudimentary traversal support.
38
1
2
Changed up object `r', `f' and `a' flags and added the `parse_all()' verb.
38
1
2
Created new version: 0.0.2.
38
1
2
Moved the code generation -- `:p()' verbs -- into a single verb.
38
1
2
Refactored common code into a base object.
38
1
2
Improved variable name collision avoidance.
38
1
2
Added support for inline comments.
38
1
2
Added support for compound assignment.
38
1
2
Added support for import.
38
1
2
Added support for `->' for loop syntax.
38
1
2
Created new version: 0.0.3.
38
1
2
Fixed the associativity of `&&', `||' and `**' operators.
38
1
#40
Dictionary
16
38
1
38
4
0
1
-1
4
0
0
30
utilities
tokenizer_proto
parser_proto
symbol_proto
literal_proto
statement_proto
operator_proto
control_flow_statement_proto
assignment_operator_proto
compound_assignment_operator_proto
prefix_operator_proto
infix_operator_proto
name_proto
bracket_operator_proto
brace_operator_proto
if_statement_proto
invocation_operator_proto
verb_selector_operator_proto
property_selector_operator_proto
error_catching_operator_proto
traditional_ternary_operator_proto
for_statement_proto
loop_statement_proto
positional_symbol_proto
fork_statement_proto
try_statement_proto
sign_operator_proto
from_statement_proto
compiler
printer
30
1
41
38
1
1
45
38
1
1
46
38
1
1
47
38
1
1
48
38
1
1
50
38
1
1
51
38
1
1
52
38
1
1
54
38
1
1
55
38
1
1
56
38
1
1
53
38
1
1
49
38
1
1
57
38
1
1
58
38
1
1
59
38
1
1
60
38
1
1
61
38
1
1
62
38
1
1
63
38
1
1
64
38
1
1
65
38
1
1
66
38
1
1
69
38
1
1
67
38
1
1
68
38
1
1
70
38
1
1
71
38
1
1
43
38
1
1
44
38
1
#41
Plastic Utilities
16
38
1
38
4
0
1
-1
4
0
6
suspend_if_necessary
38
172
-1
parse_map_sequence
38
172
-1
parse_list_sequence
38
172
-1
validate_scattering_pattern
38
172
-1
children
38
172
-1
match
38
172
-1
1
plastic
1
1
40
38
0
#42
Plastic Base Object
0
38
1
38
4
0
1
-1
4
3
1
43
1
45
1
46
2
_ensure_prototype
38
172
-1
_ensure_instance
38
172
-1
0
0
#43
MOOcode Compiler
272
38
1
38
4
0
4
2
1
4
1
42
4
0
4
_lookup*_variable
38
172
-1
_generate*_unique
38
172
-1
compile c
38
172
-1
p
38
172
-1
4
plastic
reserved_names
builtin_names
variable_map
5
1
40
38
0
4
19
2
if
2
else
2
elseif
2
endif
2
for
2
in
2
endfor
2
fork
2
endfork
2
return
2
while
2
endwhile
2
try
2
except
2
finally
2
endtry
2
ANY
2
break
2
continue
38
1
4
20
2
player
2
this
2
caller
2
verb
2
argstr
2
args
2
dobjstr
2
dobj
2
prepstr
2
iobjstr
2
iobj
2
err
2
num
2
int
2
float
2
str
2
obj
2
list
2
map
2
anon
38
1
10
0
38
1
5
38
4
#44
Syntax Tree Pretty Printer
16
38
1
38
4
0
4
1
1
4
4
0
2
_print
38
172
-1
print p
38
172
-1
1
plastic
2
1
40
38
0
5
38
4
#45
Tokenizer Prototype
16
38
1
38
4
0
4
1
1
42
4
0
3
create
38
172
-1
advance
38
172
-1
token
38
172
-1
6
plastic
errors
row
column
source
token
6
1
40
38
0
10
19
2
E_ARGS
3
11
2
E_DIV
3
2
2
E_EXEC
3
17
2
E_FILE
3
16
2
E_FLOAT
3
15
2
E_INTRPT
3
18
2
E_INVARG
3
13
2
E_INVIND
3
7
2
E_MAXREC
3
9
2
E_NACC
3
12
2
E_NONE
3
0
2
E_PERM
3
3
2
E_PROPNF
3
4
2
E_QUOTA
3
14
2
E_RANGE
3
10
2
E_RECMOVE
3
8
2
E_TYPE
3
1
2
E_VARNF
3
6
2
E_VERBNF
3
5
38
0
0
1
38
1
0
1
38
1
4
0
38
0
10
0
38
0
#46
Parser Prototype
16
38
1
38
4
0
4
1
1
42
4
0
12
create
38
172
-1
symbol
38
172
-1
reserve_statement reserve_keyword
38
172
-1
make_identifier make_variable
38
172
-1
token
38
172
-1
advance
38
172
-1
expression
38
172
-1
statement
38
172
-1
statements
38
172
-1
parse_all
38
172
-1
push
38
172
-1
pop
38
172
-1
8
plastic
object_utilities
tokenizer
symbols
token
loop_variables
loop_depth
imports
8
1
40
38
0
1
19
38
0
1
-1
38
0
10
0
38
1
0
0
38
1
4
0
38
1
0
0
38
1
10
0
38
1
#47
Symbol Prototype
400
38
1
38
4
0
1
-1
4
6
1
48
1
49
1
51
1
57
1
58
1
69
4
create
38
172
-1
clone
38
172
-1
nud
38
172
-1
led
38
172
-1
9
plastic
id
type
bp
value
reserved
eol
row
column
9
1
40
38
0
0
0
38
5
0
0
38
5
0
0
38
5
0
0
38
5
0
0
38
5
0
0
38
5
0
0
38
5
0
0
38
5
#48
Literal Prototype
272
38
1
38
4
0
4
1
1
47
4
0
1
nud
38
172
-1
0
9
5
38
0
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
#49
Name Prototype
272
38
1
38
4
0
4
1
1
47
4
1
1
50
1
nud
38
172
-1
0
9
5
38
0
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
#50
Statement Prototype
400
38
1
38
4
0
4
1
1
49
4
7
1
52
1
59
1
65
1
66
1
67
1
68
1
71
1
std
38
172
-1
0
9
5
38
0
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
#51
Operator Prototype
400
38
1
38
4
0
4
1
1
47
4
8
1
53
1
56
1
60
1
61
1
62
1
63
1
64
1
70
0
0
9
5
38
0
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
#52
Control Flow Statement Prototype
272
38
1
38
4
0
4
1
1
50
4
0
1
std
38
172
-1
1
first
10
0
0
38
5
5
38
0
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
#53
Infix Operator Prototype
400
38
1
38
4
0
4
1
1
51
4
2
1
54
1
55
1
led
38
172
-1
3
right
first
second
12
0
0
38
5
0
0
38
5
0
0
38
5
5
38
0
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
#54
Assignment Operator Prototype
272
38
1
38
4
0
4
1
1
53
4
0
1
led
38
172
-1
0
12
5
38
5
5
38
5
5
38
5
5
38
0
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
#55
Compound Assignment Operator Prototype
0
38
1
38
4
0
4
1
1
53
4
0
1
led
38
172
-1
0
12
5
38
5
5
38
5
5
38
5
5
38
0
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
#56
Prefix Operator Prototype
400
38
1
38
4
0
4
1
1
51
4
0
1
nud
38
172
-1
1
first
10
0
0
38
5
5
38
0
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
#57
Bracket Operator Prototype
272
38
1
38
4
0
4
1
1
47
4
0
2
nud
38
172
-1
led
38
172
-1
3
first
second
third
12
0
0
38
5
0
0
38
5
0
0
38
5
5
38
0
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
#58
Brace Operator Prototype
272
38
1
38
4
0
4
1
1
47
4
0
1
nud
38
172
-1
1
first
10
0
0
38
5
5
38
0
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
#59
If Statement Prototype
272
38
1
38
4
0
4
1
1
50
4
0
1
std
38
172
-1
0
9
5
38
0
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
#60
Invocation Operator Prototype
272
38
1
38
4
0
4
1
1
51
4
0
2
nud
38
172
-1
led
38
172
-1
3
first
second
third
12
0
0
38
5
0
0
38
5
0
0
38
5
5
38
0
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
#61
Verb Selector Operator Prototype
272
38
1
38
4
0
4
1
1
51
4
0
1
led
38
172
-1
2
first
second
11
0
0
38
5
0
0
38
5
5
38
0
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
#62
Property Selector Operator Prototype
272
38
1
38
4
0
4
1
1
51
4
0
1
led
38
172
-1
2
first
second
11
0
0
38
5
0
0
38
5
5
38
0
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
#63
Error Catching Operator Prototype
272
38
1
38
4
0
4
1
1
51
4
0
2
nud
38
172
-1
led
38
172
-1
3
first
second
third
12
0
0
38
5
0
0
38
5
0
0
38
5
5
38
0
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
#64
Traditional Ternary Operator Proto
0
38
1
38
4
0
4
1
1
51
4
0
1
led
38
172
-1
3
first
second
third
12
0
0
38
1
0
0
38
1
0
0
38
1
5
38
0
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
#65
For Statement Prototype
272
38
1
38
4
0
4
1
1
50
4
0
1
std
38
172
-1
1
subtype
10
0
0
38
5
5
38
0
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
#66
Loop Statement Prototype
272
38
1
38
4
0
4
1
1
50
4
0
1
std
38
172
-1
0
9
5
38
0
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
#67
Fork Statement Prototype
272
38
1
38
4
0
4
1
1
50
4
0
1
std
38
172
-1
0
9
5
38
0
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
#68
Try Statement Prototype
272
38
1
38
4
0
4
1
1
50
4
0
1
std
38
172
-1
1
subtype
10
0
0
38
5
5
38
0
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
#69
Positional Symbol Prototype
272
38
1
38
4
0
4
1
1
47
4
0
1
nud
38
172
-1
0
9
5
38
0
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
#70
Sign Operator Prototype
0
38
1
38
4
0
4
1
1
51
4
0
2
nud
38
172
-1
led
38
172
-1
2
first
second
11
0
0
38
1
0
0
38
1
5
38
0
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
#71
From Statement Prototype
0
38
1
38
4
0
4
1
1
50
4
0
1
std
38
172
-1
0
9
5
38
0
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
5
38
5
#72
Text Tools
0
72
1
-1
4
2
1
73
1
74
1
-1
4
0
0
11
identifier
version
manifest
relocate
requires
provides
instructions
description
authors
homepage
license
11
2
text_tools
72
1
2
0.0.1
72
1
4
3
4
2
1
72
2
package
4
2
1
73
2
changelog
4
2
1
74
2
patience_diff
72
1
4
0
72
1
4
2
4
1
2
kernel
4
2
2
primitive
2
>= 0.0.2
72
1
4
0
72
1
4
0
72
1
2
The Text Tools package provides tools for working with text.  Currently it only provides an implementation of the patience diff algorithm.
72
1
4
1
2
Todd Sundsted
72
1
2

72
1
2
FreeBSD License
72
1
#73
Changelog
0
72
1
72
4
0
1
-1
4
0
0
1
1338760427
1
2
Added patience diff.
72
1
#74
Patience Diff
0
72
1
72
4
0
4
1
1
4
4
0
6
_suspend_if_necessary
72
172
-1
_hash_lines
72
172
-1
_find_common_unique_lines
72
172
-1
_find_lcs
72
172
-1
_generate_diff
72
172
-1
diff
72
172
-1
1
default_hash_algo
2
2
md5
72
1
5
72
4
#75
Ask, Query Package
0
75
1
-1
4
3
1
76
1
77
1
78
1
-1
4
0
0
11
identifier
version
manifest
relocate
requires
provides
instructions
description
authors
homepage
license
11
2
ask
75
1
2
0.0.2
75
1
4
5
4
2
1
75
2
package
4
2
1
76
2
changelog
4
2
1
77
2
dictionary
4
2
1
78
2
ask_proto
4
2
12
138
2
query_utilities
75
1
4
4
2
dictionary.ask_proto
2
dictionary.ask
2
ask_proto.query_utilities
2
query_utilities.ask_proto
75
1
4
2
4
1
2
kernel
4
2
2
primitive
2
>= 0.0.2
75
1
4
0
75
1
4
1
2
install-dictionary
75
1
2
Ask implements queries based on relational algebra.
75
1
4
1
2
Todd Sundsted
75
1
2

75
1
2
FreeBSD License
75
1
#76
Changelog
0
75
1
75
4
0
1
-1
4
0
0
9
1338507037
1339588745
1341490029
1341492308
1341572860
1341574954
1341628401
1351463659
1360331541
9
2
First cut at `$ask'.
75
1
2
Replaced magic string "#" with `$ask:id()'/`$ask_proto.id'.
75
1
2
Instead of failing, return information about low-level (E_PERM, etc.) errors.
75
1
2
Added support for predicates with objects numbers.
75
1
2
Added support for predicates "is true"/"is false".
75
1
2
Added support for more logical operators.
75
1
2
Added support for the string matching operator.
75
1
2
Migrated from frob to anonymous object.
75
1
2
Fixed bug with underscores in identifier matching.
75
1
#77
Dictionary
0
75
1
75
4
0
1
-1
4
1
1
0
0
2
ask_proto
ask
2
1
78
75
1
1
78
75
1
#78
Ask Prototype
16
75
1
75
4
0
1
-1
4
0
9
_match_literal_or_identifier
75
172
-1
_match_operator
75
172
-1
_parse_predicate
75
172
-1
from
75
172
-1
select
75
172
-1
where
75
172
-1
count
75
172
-1
all
75
172
-1
one
75
172
-1
5
query_utilities
from
operations
ID
ERRORS
5
12
138
75
0
0
0
75
0
0
0
75
0
1
-7
75
1
1
-11
75
1
#79
Model Package
0
79
1
-1
4
9
1
80
1
81
1
82
1
83
1
84
1
85
1
86
1
87
1
88
1
-1
4
0
0
11
identifier
version
manifest
relocate
requires
provides
instructions
description
authors
homepage
license
11
2
model
79
1
2
0.0.1
79
1
4
10
4
2
1
79
2
package
4
2
1
80
2
dictionary
4
2
1
81
2
changelog
4
2
1
82
2
model_proto
4
2
1
83
2
constraint
4
2
1
84
2
validates_presence_of
4
2
1
85
2
validates_uniqueness_of
4
2
1
86
2
validates_immutability_of
4
2
1
87
2
validates_format_of
4
2
1
88
2
validates_revision_of
79
1
4
7
2
dictionary.model_proto
2
dictionary.constraint
2
dictionary.validates_presence_of
2
dictionary.validates_uniqueness_of
2
dictionary.validates_immutability_of
2
dictionary.validates_format_of
2
dictionary.validates_revision_of
79
1
4
2
4
1
2
kernel
4
2
2
ask
2
>= 0.0.1
79
1
4
0
79
1
4
1
2
install-namespace
79
1
2

79
1
4
0
79
1
2

79
1
2

79
1
#80
Dictionary
0
79
1
79
4
0
1
-1
4
0
6
validate
5
172
-1
create
5
172
-1
update
5
172
-1
read
5
172
-1
_before_* _after_*
5
172
-1
find find_by_*
79
172
-1
9
model_proto
constraint
id
errors
validates_presence_of
validates_uniqueness_of
validates_immutability_of
validates_format_of
validates_revision_of
9
1
82
79
1
1
83
79
1
1
-7
79
1
1
-11
79
1
1
84
79
1
1
85
79
1
1
86
79
1
1
87
79
1
1
88
79
1
#81
Changelog
0
79
1
79
4
0
1
-1
4
0
0
19
1316329109
1316332819
1317981980
1318420551
1320746708
1321644116
1321732614
1321750566
1339414278
1339498645
1339498974
1339505506
1339505587
1339507058
1339581632
1339581896
1339589892
1341418035
1343621398
19
2
Added package installation instructions.
79
1
2
Fixed validation breakage related to map operation changes.
79
1
2
Model create/update now uses $shape to write values -- normalizes `location' et al.
79
1
2
Verb `find_by_*' now uses $ask.
79
1
2
Updated package information.
79
1
2
Loosened the coupling between model actions and the model prototype object.  Added custom `respond_to()' verb.  Format validation now takes "pattern" instead of "regex".
79
1
2
Renamed model verb `show()' to `read()'.
79
1
2
Return the canonical representation on create/update.  Handle a few errors better.
79
1
2
Major rewrite.  Fixed magic markers for errors and object number/id.  Removed custom `respond_to()' verb.
79
1
2
Moved verbs from `$model.model' to `$model'.
79
1
2
Renamed `$model.model' to `$model.model_proto'.
79
1
2
Cleaned up `find()'.
79
1
2
Added prototype and instance delegation.
79
1
2
`update()' and `read()' now work with descendants and children.
79
1
2
`$model.validates_presence_of' is now forgiving if the property is set.
79
1
2
Added `$model.validates_revision_of'.
79
1
2
`$model:find()' and `$model:find_by_*()' automatically select accessible properties.
79
1
2
`validates_format_of()' handles the empty string correctly.
79
1
2
Validations improvements/fixes.
79
1
#82
Model Prototype
128
79
1
79
4
0
4
1
1
4
4
0
2
create find find_by_*
5
172
-1
validate update read
5
172
-1
2
accessible
constraints
3
4
0
79
5
10
0
79
5
5
79
4
#83
Constraint Prototype
0
79
1
79
4
0
4
1
1
4
4
5
1
84
1
85
1
86
1
87
1
88
3
validate
79
172
-1
add_error
79
172
-1
is_blank is_present
5
172
-1
0
1
5
79
4
#84
Validates Presence Of
0
79
1
79
4
0
4
1
1
83
4
0
1
validate
5
172
-1
0
1
5
79
4
#85
Validates Uniqueness Of
0
79
1
79
4
0
4
1
1
83
4
0
1
validate
5
172
-1
0
1
5
79
4
#86
Validates Immutability Of
0
79
1
79
4
0
4
1
1
83
4
0
1
validate
5
172
-1
0
1
5
79
4
#87
Validates Format Of
0
79
1
79
4
0
4
1
1
83
4
0
1
validate
79
172
-1
0
1
5
79
4
#88
Validates Revision Of
0
79
1
79
4
0
4
1
1
83
4
0
1
validate
5
172
-1
0
1
5
79
4
#89
Persistent Package
0
89
1
-1
4
3
1
90
1
91
1
92
1
-1
4
0
0
10
identifier
version
manifest
relocate
requires
instructions
description
authors
homepage
license
10
2
persistent
89
1
2
0.0.2
89
1
4
4
4
2
1
89
2
package
4
2
1
90
2
changelog
4
2
1
91
2
dictionary
4
2
1
92
2
attachable
89
1
4
1
2
dictionary.attachable
89
1
4
1
4
2
2
kernel
2
>= 1.0.6
89
1
4
1
2
install-dictionary
89
1
2
Persistent creates and manages the associated Stunt filesystem.  The package includes the $attachable mixin.
89
1
4
1
2
Todd Sundsted
89
1
2
http://stunt.io/packages/persistent
89
1
2
FreeBSD License
89
1
#90
Changelog
0
89
1
89
4
0
1
-1
4
0
0
5
1312670738
1313453111
1321630702
1329737917
1343820926
5
2
Added $attachable/Attachable.
89
1
2
Create directory structure under files/ on startup.
89
1
2
Cleanup in $attachable.  Removed use of `call_function()'.  Deal with missing helper executables better.
89
1
2
Updated code to use new `for' loop functionality.
89
1
2
Massive rework on `$attachable'.
89
1
#91
Dictionary
0
89
1
89
4
0
1
-1
4
1
1
0
1
server_started
5
172
-1
1
attachable
1
1
92
89
1
#92
Attachable
128
89
1
89
4
0
4
1
1
4
4
0
11
attachments
89
172
-1
attachment
5
172
-1
check_attachment
5
172
-1
recycle
5
172
-1
_path_for
5
172
-1
add_attachment
5
172
-1
add_attachment_from_tmp_file
5
172
-1
delete_attachment
5
172
-1
_identify
5
172
-1
_thumbnail
5
172
-1
_check_limit
89
172
-1
3
attachment_pools
attachments
attachment_limit
4
10
2
2
private
2
private/app
2
public
2
public/app
89
0
10
0
89
0
0
4
89
1
5
89
4
#93
Dialog, Web Server Package
0
93
1
-1
4
9
1
94
1
95
1
96
1
97
1
98
1
99
1
100
1
101
1
102
1
-1
4
0
2
after_install
5
172
-1
before_uninstall
5
172
-1
10
identifier
version
manifest
relocate
requires
instructions
description
authors
homepage
license
10
2
dialog
93
1
2
0.1.1
93
1
4
10
4
2
1
93
2
package
4
2
1
94
2
changelog
4
2
1
95
2
dictionary
4
2
1
96
2
utilities
4
2
1
97
2
server
4
2
1
98
2
request_proto
4
2
1
99
2
response_proto
4
2
1
100
2
route_proto
4
2
1
101
2
handler_proto
4
2
1
102
2
player_in_session
93
1
4
12
2
dictionary.utilities
2
dictionary.server
2
dictionary.request_proto
2
dictionary.response_proto
2
dictionary.route_proto
2
dictionary.handler_proto
2
dictionary.player_in_session
2
server.utilities
2
server.request_proto
2
server.response_proto
2
server.route_proto
2
utilities.time
93
1
4
4
4
2
2
kernel
2
>= 1.0.6
4
2
2
primitive
2
>= 0.0.4
4
2
2
core
2
>= 0.0.2
4
2
2
plastic
2
>= 0.0.2
93
1
4
1
2
install-namespace
93
1
2
Dialog is the Stunt HTTP server.
93
1
4
1
2
Todd Sundsted
93
1
2
http://stunt.io/packages/dialog
93
1
2
FreeBSD License
93
1
#94
Changelog
0
93
1
93
4
0
1
-1
4
0
0
52
1316094194
1316358449
1318324724
1318324757
1318346368
1319025413
1319025667
1319388751
1319388831
1329657368
1329684677
1331257920
1331258266
1331905594
1331908171
1332104162
1332104693
1332106296
1332244717
1335621656
1336318579
1336480647
1336702845
1336991408
1337168940
1337216616
1337248289
1337250774
1337429755
1337431122
1337449915
1337453002
1341097958
1341100432
1341103044
1341232003
1341314273
1341320216
1343504254
1343580292
1343586836
1343591641
1354983271
1358819301
1358861187
1358861512
1359226185
1359377595
1359645935
1359910125
1359911101
1359985161
52
2
Added HTTP server framework (basic) including external file serving, routing to object/verb handlers and a database example.
93
1
2
Unescape URL encoded POST data.
93
1
2
Modified HTTP server `session()' verb to get session from task local value.
93
1
2
Modified HTTP server `internal()' verb to properly set `player' and perms.
93
1
2
Removed player()/set_player() from request; moved authenticated player persistence into task local storage.
93
1
2
Refactored HTTP server chaining; support external chain steps; removed upgrade from default chain; added external log and upgrade steps.
93
1
2
Removed internal dependency on storing the player in the HTTP session.
93
1
2
The HTTP server `external()' verb looks up mime type by extension and by exec'ing `identify'.
93
1
2
`_do_chain()' tries to be smarter about cleanup on error.
93
1
2
Moved HTTP status codes into a property.
93
1
2
Removed `external()' and renamed `internal()' to `serve()'.
93
1
2
Added a configurable session cookie name.
93
1
2
Fixed the ownership and perms of `key'.
93
1
2
Handle too-large bodies in cleanup.
93
1
2
Added better diagnostics in session validation.
93
1
2
Added support for flash socket policy file requests.
93
1
2
Fixed the handling of upgrade requests.
93
1
2
Renamed "route" to "route_proto" in all the right places.
93
1
2
Moved the flash socket policy logic back into `do_login_command()'.
93
1
2
Explicitly send a content length of zero (0) when the body is empty.  Safari seems to want this on redirects.
93
1
2
Package dictionary now has no parents.
93
1
2
Limit parameters map to 1000 items to foil DOS attacks.
93
1
2
Removed redundant code from `parse_query_string()'.
93
1
2
Added support for a synchronizer-style authenticity token.  Refactored the session code.  Fixed tests.
93
1
2
Roll the player step in the chain into the session step.
93
1
2
More useful error messages when chaining fails.
93
1
2
Broadened the 404/500 verb to handle (almost) any status.
93
1
2
Added authenticity token and player information as convenience parameters.
93
1
2
Handle bad requests more gracefully.
93
1
2
Added Server header to response.
93
1
2
Strip out query/body parameters that begin with "__".
93
1
2
Added Date header.
93
1
2
Force peeked-at input on the _front_ of the queue.
93
1
2
Surround system/convenience parameters with double-underscores.
93
1
2
Add `__xhr__' and `__url_base__' system/convenience parameters.
93
1
2
Strip parameters that begin with double-underscores.
93
1
2
Handle form data parameters more securely.
93
1
2
Handle request media type parameters
93
1
2
The session cookie must be http only.
93
1
2
Add `__ssh__' and `__remote_client__' system/convenience parameters.
93
1
2
Added timezone adjustments.
93
1
2
Fixed error properly closing files.
93
1
2
First-cut at migration from frobs to anonymous objects.
93
1
2
Created new version: 0.1.1.
93
1
2
Fixed the It Works! page.
93
1
2
Added basic response helpers.
93
1
2
Fixed handling of unescaping unprintable characters.
93
1
2
Added `forbidden()' response helper.
93
1
2
Added `not_acceptable()' response helper.
93
1
2
Added `request_entity_too_large()' response helper.
93
1
2
Added `bad_request()' response helper.
93
1
2
Fixed a naming bug with authenticity token.
93
1
#95
Dialog Dictionary
0
93
1
93
4
0
1
-1
4
0
0
7
server
request_proto
response_proto
route_proto
handler_proto
utilities
player_in_session
7
1
97
93
1
1
98
93
1
1
99
93
1
1
100
93
1
1
101
93
1
1
96
93
1
1
102
93
1
#96
Dialog Utilities
0
93
1
93
4
0
4
1
1
4
4
0
4
generate_query_string
93
172
-1
parse_query_string
93
172
-1
escape
93
172
-1
unescape
93
172
-1
3
time
reserved
escaped
4
1
17
93
0
4
19
2
!
2
*
2
'
2
(
2
)
2
;
2
:
2
@
2
&
2
=
2
+
2
$
2
,
2
/
2
?
2
#
2
[
2
]
2
 
93
1
4
19
2
%21
2
%2A
2
%27
2
%28
2
%29
2
%3B
2
%3A
2
%40
2
%26
2
%3D
2
%2B
2
%24
2
%2C
2
%2F
2
%3F
2
%23
2
%5B
2
%5D
2
+
93
1
5
93
4
#97
HTTP Server
0
93
1
93
4
1
1
103
4
1
1
4
4
1
1
131
22
_log
5
172
-1
_key
93
172
-1
start
5
172
-1
stop
5
172
-1
_read_http
5
172
-1
_notify
5
172
-1
_session_cookie_name _flash_socket_policy
5
172
-1
_read_from_connection
93
172
-1
_write_to_connection
93
172
-1
_do_request
93
172
-1
do_login_command
5
172
-1
session
5
172
-1
route
93
172
-1
parameters
5
172
-1
protect_from_forgery
5
172
-1
serve
5
172
-1
cleanup
5
172
-1
2* 3* 4* 5*
93
172
-1
traceback
93
172
-1
trampoline
5
172
-1
_drop_perms_and_call_verb
5
172
-1
_do_chain
5
172
-1
10
port
key
default_chain
utilities
request_proto
response_proto
route_proto
status_codes
session_cookie_name
flash_socket_policy
11
0
8888
93
1
0
0
93
0
4
7
2
session
2
parameters
2
protect_from_forgery
2
route
2
serve
2
cleanup
2
404
93
4
1
96
93
0
1
98
93
1
1
99
93
1
1
100
93
1
10
13
0
200
2
Ok
0
201
2
Created
0
204
2
No Content
0
302
2
Moved
0
304
2
Not Modified
0
400
2
Bad Request
0
403
2
Forbidden
0
404
2
Not Found
0
406
2
Not Acceptable
0
413
2
Request Entity Too Large
0
415
2
Unsupported Media Type
0
422
2
Unprocessable Entity
0
500
2
Server Error
93
1
2
_stunt_session
93
4
0
0
93
4
5
93
4
#98
HTTP Request Prototype
272
93
1
93
4
0
1
-1
4
0
9
method uri headers body upgrade parameters handler exception
93
172
-1
set_method set_uri set_headers set_body set_upgrade set_parameters set_handler set_exception
93
172
-1
cookies
93
172
-1
path
93
172
-1
query
93
172
-1
type
93
172
-1
set_type
93
172
-1
length
93
172
-1
set_length
93
172
-1
8
method
uri
headers
body
upgrade
parameters
handler
exception
8
0
0
93
0
0
0
93
0
10
0
93
0
0
0
93
0
0
0
93
0
10
0
93
0
4
0
93
0
0
0
93
0
#99
HTTP Response Prototype
272
93
1
93
4
0
1
-1
4
0
6
status headers body
93
172
-1
set_status set_headers set_body
93
172
-1
type
93
172
-1
set_type
93
172
-1
length location
93
172
-1
set_length set_location
93
172
-1
3
status
headers
body
3
0
0
93
0
10
0
93
0
0
0
93
0
#100
HTTP Route Prototype
0
93
1
93
4
0
4
1
1
4
4
4
1
103
1
106
1
107
1
137
1
match
93
172
-1
0
1
5
93
4
#101
Base Handler Prototype
0
93
1
93
4
0
1
-1
4
0
11
_request
5
172
-1
_response
5
172
-1
_ensure_once
93
172
-1
200 ok
93
172
-1
400 bad_request
93
172
-1
403 forbidden
93
172
-1
404 not_found
93
172
-1
406 not_acceptable
93
172
-1
413 request_entity_too_large
93
172
-1
500 server_error
93
172
-1
302 moved
93
172
-1
4
_ensure_once
session
request
response
4
0
0
93
0
10
0
93
0
0
0
93
4
0
0
93
4
#102
Player in Session Capability
0
93
1
93
4
0
1
-1
4
0
2
set_player
5
172
-1
player
5
172
-1
1
prototypes
1
4
0
5
0
#103
It Works!
0
93
1
97
4
0
4
1
1
100
4
0
2
match
93
172
-1
it_works!
93
172
-1
0
1
5
93
4
#104
Dialog, Extras
0
104
1
-1
4
6
1
105
1
106
1
107
1
108
1
109
1
110
1
-1
4
0
0
10
identifier
version
manifest
relocate
requires
instructions
description
authors
homepage
license
10
2
dialog_extras
104
1
2
0.0.5
104
1
4
7
4
2
1
104
2
package
4
2
1
105
2
changelog
4
2
1
106
2
file_server
4
2
1
107
2
db_server
4
2
1
108
2
streaming_handler
4
2
1
109
2
logger
4
2
1
110
2
view_helpers
104
1
4
0
104
1
4
5
4
2
2
kernel
2
>= 1.0.7
4
2
2
primitive
2
>= 0.0.2
4
2
2
core
2
>= 0.0.2
4
2
2
plastic
2
>= 0.0.2
4
2
2
dialog
2
>= 0.0.2
104
1
4
0
104
1
2
The Dialog Extras package contains objects that extend Dialog: file server, db object server, upgrade protocol handler, and logger.
104
1
4
1
2
Todd Sundsted
104
1
2
http://stunt.io/packages/dialog_extras
104
1
2
FreeBSD License
104
1
#105
Changelog
0
104
1
104
4
0
1
-1
4
0
0
12
1335730720
1337172128
1337341716
1337342502
1337441502
1337453415
1341098950
1341100432
1343584453
1343591641
1358988229
1360243978
12
2
Deal with a few more errors in static file routing.
104
1
2
Deal with unparseable object numbers.
104
1
2
Smartened up the database POST, PUT and DELETE verbs.
104
1
2
Don't let invalid players create objects.
104
1
2
Prevent `index.html' file serving from shadowing `///' (the database handler path prefix).
104
1
2
Added last-modified and if-modified-since support.
104
1
2
Support "swf" and "htm" extensions.
104
1
2
Surround system/convenience parameters with double-underscores.
104
1
2
Log the correct client IP address.
104
1
2
Fixed error properly closing files.
104
1
2
Log request duration.
104
1
2
Added helpers for the authenticity token.
104
1
#106
HTTP File Server
0
104
1
104
4
0
4
1
1
100
4
1
1
132
2
match
5
172
-1
get
5
172
-1
0
1
5
104
4
#107
HTTP Database Server
0
104
1
104
4
0
4
1
1
100
4
1
1
133
7
match
104
172
-1
_match_uri
104
172
-1
_toobj
104
172
-1
get
5
172
-1
put
5
172
-1
post
5
172
-1
delete
5
172
-1
0
1
5
104
4
#108
HTTP Streaming Handler
0
104
1
104
4
0
4
1
1
4
4
1
1
131
2
do_socket
5
172
-1
do_long_poll
5
172
-1
1
description
2
2
HTTP streaming handlers for player interaction.  Currently socket based and long-polling.
104
1
5
104
4
#109
HTTP Logger
0
104
1
104
4
0
4
1
1
4
4
1
1
131
1
log
5
172
-1
0
1
5
104
4
#110
View Helpers
0
104
1
104
4
0
1
-1
4
1
1
135
4
escape
110
172
-1
authenticity_token
110
172
-1
authenticity_token_meta_tag
110
172
-1
authenticity_token_form_input
110
172
-1
0
0
#111
Mustache Templating Language Package
0
111
1
-1
4
3
1
112
1
113
1
114
1
-1
4
0
2
after_install
5
172
-1
before_uninstall
5
172
-1
11
identifier
version
manifest
relocate
requires
provides
instructions
description
authors
homepage
license
11
2
mustache
111
1
2
1.0.1
111
1
4
4
4
2
1
111
2
package
4
2
1
112
2
changelog
4
2
1
113
2
dictionary
4
2
1
114
2
compiler
111
1
4
1
2
dictionary.compiler
111
1
4
2
4
2
2
kernel
2
>= 1.1.1
4
2
2
primitive
2
>= 0.0.2
111
1
4
0
111
1
4
1
2
install-namespace
111
1
2
A MOO/Stunt port of the popular Mustache templating language (http://mustache.github.com/).
111
1
4
1
2
Todd Sundsted
111
1
2
http://stunt.io/packages/mustache
111
1
2
FreeBSD License
111
1
#112
Changelog
0
111
1
111
4
0
1
-1
4
0
0
9
1317769370
1317897840
1319399411
1337466158
1337553578
1341406402
1341407065
1355362911
1355403901
9
2
Initial release candidate.
111
1
2
Fixed a bug in pushing/popping context frames.
111
1
2
Fixed a bug in handling dotted notation.
111
1
2
Emit syntax errors for invalid mustache.
111
1
2
Improved the quality of the generated code.
111
1
2
Emit a syntax error for an empty tag.
111
1
2
Ensure `compile()' takes a list.
111
1
2
Created new version: 1.0.1.
111
1
2
Compiler output is now compatible.
111
1
#113
Dictionary
0
111
1
111
4
0
1
-1
4
0
0
1
compiler
1
1
114
111
1
#114
Mustache Compiler
0
111
1
111
4
0
4
1
1
4
4
0
2
_log
5
172
-1
compile
111
172
-1
0
1
5
111
4
#115
Identity Package
0
115
1
-1
4
5
1
116
1
117
1
118
1
119
1
120
1
-1
4
0
0
11
identifier
version
manifest
relocate
requires
provides
instructions
description
authors
homepage
license
11
2
identity
115
1
2
0.0.2
115
1
4
6
4
2
1
115
2
package
4
2
1
116
2
changelog
4
2
1
117
2
dictionary
4
2
1
118
2
authenticatable
4
2
1
119
2
utilities
4
2
1
120
2
namespace
115
1
4
3
2
dictionary.authenticatable
2
dictionary.identity
2
namespace.utilities
115
1
4
1
4
2
2
kernel
2
>= 1.0.4
115
1
4
0
115
1
4
1
2
install-dictionary
115
1
2
The identity package provides mechanisms for establishing player/user identity.
115
1
4
1
2
Todd Sundsted
115
1
2
http://stunt.io/packages/identity
115
1
2
FreeBSD License
115
1
#116
Changelog
0
115
1
115
4
0
1
-1
4
0
0
4
1311598736
1336418462
1336419186
1339591932
4
2
Improved the fixed-time hash comparison in $authenticatable.
115
1
2
Moved utility verbs from the `$authenticatable' prototype mixin.
115
1
2
Updated `$authenticate()' to use the new utility verbs.
115
1
2
Added the `@password' command verb.
115
1
#117
Dictionary
0
115
1
115
4
0
1
-1
4
1
1
0
1
authenticate
5
172
-1
2
authenticatable
identity
2
1
118
115
1
1
120
115
1
#118
Authenticatable
0
115
1
115
4
0
4
1
1
4
4
0
1
@password
5
8
-1
1
hashed_password
2
10
0
5
0
5
115
4
#119
Identity Utilities
0
115
1
115
4
0
4
1
1
4
4
0
2
verify_hashed_password
115
172
-1
hash_password
115
172
-1
0
1
5
115
4
#120
Identity Namespace
0
115
1
115
4
0
1
-1
4
0
0
1
utilities
1
1
119
115
1
#121
Alt, Player Package
0
121
1
-1
4
6
1
122
1
123
1
124
1
125
1
126
1
127
1
-1
4
0
0
11
identifier
version
manifest
relocate
requires
provides
instructions
description
authors
homepage
license
11
2
alt
121
1
2
0.0.3
121
1
4
7
4
2
1
121
2
package
4
2
1
122
2
changelog
4
2
1
123
2
dictionary
4
2
1
124
2
player_utilities
4
2
1
125
2
player_proto
4
2
1
126
2
programmer_proto
4
2
1
127
2
wizard_proto
121
1
4
3
2
dictionary.player_proto
2
dictionary.programmer_proto
2
dictionary.wizard_proto
121
1
4
5
4
2
2
kernel
2
>= 1.0.4
4
2
2
core
2
>= 0.0.1
4
2
2
primitive
2
>= 0.0.2
4
2
2
text_tools
2
>= 0.0.1
4
2
2
plastic
2
>= 0.0.1
121
1
4
0
121
1
4
1
2
install-namespace
121
1
2
The Alt Package contains the basic player hierarchy and defines a basic set of VR verbs.
121
1
4
1
2
Todd Sundsted
121
1
2
http://stunt.io/packages/alt
121
1
2
FreeBSD License
121
1
#122
Changelog
0
121
1
121
4
0
1
-1
4
0
0
16
1333837145
1333839422
1338036321
1338208126
1338895941
1341148790
1341149402
1341174341
1341176019
1341179018
1341187815
1343595533
1351446849
1354988315
1355922371
1356876578
16
2
`match_verb()'/`match_property()' now match on "me" and "here".
121
1
2
Removed `utilities' property from `$player_proto'; using `$lookup()' instead.
121
1
2
In `set_verb_code()', the fourth arg is the content type.
121
1
2
Don't program verb if nothing changed.
121
1
2
Added `@diff/@difference' command verb.
121
1
2
Added argstr tail processing.
121
1
2
Made `@inspect' output much more attractive.
121
1
2
Improved property handling in `@list'/`@edit' and `@program'.
121
1
2
Fixed the verb-not-found case in `@diff'.
121
1
2
Added  `@commit' and `@revert'.
121
1
2
`@program' snarfs lines early to avoid accidental commands.
121
1
2
Fixed many usability problems with the `@inspect' command verb.
121
1
2
A few tweaks to make `@inspect' et al work better with anonymous objects.
121
1
2
Major revamp of `evaluate'.
121
1
2
Added `@shutdown' command verb.
121
1
2
Added support for object matching on bindings.
121
1
#123
Dictionary
0
121
1
121
4
0
1
-1
4
0
0
3
player_proto
programmer_proto
wizard_proto
3
1
125
121
1
1
126
121
1
1
127
121
1
#124
Player Utilities
0
121
1
121
4
0
1
-1
4
0
5
match_verb match_property
5
172
-1
match_object
5
172
-1
_player_controls_verb _player_controls_property
5
172
-1
_player_controls_object
5
172
-1
extract_tail
121
172
-1
0
0
#125
Player Prototype
144
121
1
121
4
0
4
1
1
4
4
1
1
126
3
huh
5
172
-1
notify tell
5
172
-1
@quit
5
8
-1
0
1
5
121
4
#126
Programmer Prototype
144
121
1
121
4
0
4
1
1
125
4
2
1
127
1
6
7
_parse
5
172
-1
eval*uate
5
88
-2
@list @edit
5
24
-1
@program
5
88
-2
@in*spect
5
24
-1
@diff*erence
5
24
-1
@commit @revert
5
24
-1
1
alt_bindings
2
10
0
121
4
5
121
4
#127
Wizard Prototype
0
121
1
121
4
0
4
1
1
126
4
1
1
5
1
@shutdown
5
8
-1
0
2
5
121
4
5
121
4
#128
Application Package
0
128
1
-1
4
3
1
129
1
130
1
131
1
-1
4
0
1
after_install
5
172
-1
11
identifier
version
manifest
requires
relocate
provides
instructions
description
authors
homepage
license
11
2
application
128
1
2
0.0.9
128
1
4
10
4
2
1
128
2
package
4
2
1
129
2
changelog
4
2
1
130
2
dictionary
4
2
1
131
2
server
4
2
1
132
2
file_server
4
2
1
133
2
database_server
4
2
1
134
2
home_controller
4
2
1
135
2
home_views
4
2
1
136
2
session_controller
4
2
1
137
2
routes
128
1
4
3
4
2
2
dialog
2
>= 0.1.1
4
2
2
dialog_extras
2
>= 0.0.5
4
2
2
plastic
2
>= 0.0.2
128
1
4
2
2
routes.home_controller
2
routes.session_controller
128
1
4
0
128
1
4
1
2
install-dictionary
128
1
2

128
1
4
0
128
1
2

128
1
2

128
1
#129
Changelog
0
128
1
128
4
0
1
-1
4
0
0
10
1335958995
1335960351
1335961601
1336184517
1336230042
1355917473
1355919225
1359114126
1359114154
1359115220
10
2
Major refactoring.
128
1
2
Updated the authentication.
128
1
2
Autostart the web server.
128
1
2
Use jquery.console.
128
1
2
Handle multiline output correctly/better in the view.
128
1
2
Created new version: 0.0.8.
128
1
2
Long polling is now the default.  `socket_or_long_poll' changes this behavior.
128
1
2
Created new version: 0.0.9.
128
1
2
Updated session verbs `create()' and `destroy()' to new session mechanism.
128
1
2
Updated home verbs `_common()', `home()' and `browse()'.
128
1
#130
Dictionary
0
128
1
128
4
0
1
-1
4
1
1
0
1
server_started
5
172
-1
0
0
#131
HTTP Server
0
128
1
128
4
5
1
132
1
133
1
134
1
136
1
137
4
3
1
97
1
108
1
109
4
0
0
0
12
0
8888
93
1
0
0
93
0
4
10
2
session
2
parameters
2
protect_from_forgery
2
do_socket
2
do_long_poll
2
route
2
serve
2
cleanup
2
404
2
log
128
4
5
93
0
5
93
1
5
93
1
5
93
1
5
93
1
5
128
4
2
<?xml version="1.0"?><cross-domain-policy><allow-access-from domain="localhost" to-ports="*"/></cross-domain-policy>
128
4
5
128
4
5
104
1
#132
File Server
0
128
1
131
4
0
4
1
1
106
4
0
0
0
1
5
128
4
#133
Database Server
0
128
1
131
4
0
4
1
1
107
4
0
0
0
1
5
128
4
#134
Home Controller
0
128
1
131
4
1
1
135
1
-1
4
0
3
_common*_parameters
128
172
-1
home
128
172
-1
browse
128
172
-1
2
home_views
socket_or_long_poll
2
1
38158
128
0
2
long_poll
128
0
#135
Home Views
0
128
1
134
4
0
4
1
1
110
4
0
6
_head
128
172
-1
_foot
128
172
-1
_nav
128
172
-1
public
128
172
-1
home
128
172
-1
browse
128
172
-1
0
0
#136
Session Controller
0
128
1
131
4
0
1
-1
4
0
2
create
5
172
-1
destroy
5
172
-1
0
0
#137
Routes
0
128
1
131
4
0
4
1
1
100
4
0
1
match
128
172
-1
2
home_controller
session_controller
3
1
134
128
0
1
136
128
0
5
128
4
1
#138
Query Utilities
0
75
1
-1
4
0
1
-1
4
0
2
query
5
172
-1
lookup
5
172
-1
1
ask_proto
1
1
78
75
0
0
463
#0:0
$private();
{e} = args;
desc = e[2];
{line, @lines} = e[4];
server_log(tostr(line[4], ":", line[2], (line[4] != line[1]) ? tostr(" (this == ", line[1], ")") | "", ", line ", line[6], ":  ", desc));
for line in (lines)
server_log(tostr("... called from ", line[4], ":", line[2], (line[4] != line[1]) ? tostr(" (this == ", line[1], ")") | "", ", line ", line[6]));
endfor
server_log("(End of traceback)");
.
#0:1
$restrict_to_server();
for parent in (parents(this))
if (respond_to(parent, "server_started"))
try
parent:server_started(@args);
except e (ANY)
this:_log_error(e);
endtry
endif
endfor
.
#0:2
$restrict_to_server();
try
subject = $nothing;
set_connection_option(player, "hold-input", 1);
if (!args)
if ((player < this.last_login_connection) && this.welcome_message)
this.last_login_connection = player;
notify(player, this.welcome_message);
endif
return;
elseif (args[1] != "connect")
notify(player, "*** Invalid ***");
return;
endif
try
subject = $authenticate(@args[2..$]);
except e (ANY)
this:_log_error(e);
notify(player, "*** Failed ***");
subject = $nothing;
return;
endtry
if ((!valid(subject)) || (!is_player(subject)))
suspend(2);
notify(player, "*** Failed ***");
subject = $nothing;
return;
endif
finally
set_connection_option(player, "hold-input", 0);
return subject;
endtry
.
#0:3
$permit("wizard");
valid = 1;
for arg in (args)
if (typeof(arg) != STR)
valid = 0;
endif
endfor
valid || raise(E_INVARG);
for parent in (parents(this))
if (respond_to(parent, "authenticate") && `valid(subject = parent:authenticate(@args)) ! ANY')
return subject;
endif
endfor
return $failed_match;
.
#0:4
clients = args;
callers = callers();
(length(callers) > 1) || raise(E_PERM, "Private verb");
((((callers[1][4] == callers[2][4]) && valid(callers[1][4])) && (callers[1][1] == callers[2][1])) && valid(callers[1][1])) || raise(E_PERM, "Private verb");
((!clients) || (callers[2][2] in clients)) || raise(E_PERM, tostr("Private verb:  \"", callers[2][2], "\" not in verb list ", toliteral(clients)));
return;
"clients = args;";
"callers = callers();";
"length(callers) > 1 || raise(E_PERM, \"Private verb\");";
"callers[1][4] == callers[2][4] && valid(callers[1][4]) && callers[1][1] == callers[2][1] && valid(callers[1][1]) || raise(E_PERM, \"Private verb\");";
"!clients || callers[2][2] in clients || raise(E_PERM, tostr(\"Private verb:  \\\"\", callers[2][2], \"\\\" not in verb list \", toliteral(clients)));";
"/*";
"Only allow the call if the caller and the callee were both defined";
"on the same object and the call between caller and callee was";
"performed on the same instance.";
"*/";
"/* security audit on Tue Jul 26 15:51:17 2011 EDT */";
"";
"content_type:application/x-moocode";
"updated_at:Tue Sep 13 19:26:52 2011 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:5
clients = args;
callers = callers();
(length(callers) > 1) || raise(E_PERM, "Protected verb");
((callers[1][1] == callers[2][1]) && valid(callers[1][1])) || raise(E_PERM, "Protected verb");
((!clients) || (callers[2][2] in clients)) || raise(E_PERM, tostr("Protected verb:  \"", callers[2][2], "\" not in verb list ", toliteral(clients)));
return;
"clients = args;";
"callers = callers();";
"length(callers) > 1 || raise(E_PERM, \"Protected verb\");";
"callers[1][1] == callers[2][1] && valid(callers[1][1]) || raise(E_PERM, \"Protected verb\");";
"!clients || callers[2][2] in clients || raise(E_PERM, tostr(\"Protected verb:  \\\"\", callers[2][2], \"\\\" not in verb list \", toliteral(clients)));";
"/*";
"Only allow the call if the call between caller and the callee was";
"performed on the same instance.";
"*/";
"/* security audit on Tue Jul 26 15:51:17 2011 EDT */";
"";
"content_type:application/x-moocode";
"updated_at:Tue Sep 13 19:26:52 2011 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:6
args && raise(E_ARGS);
{dummy, @callers} = callers();
callers && raise(E_PERM, "Server-only verb");
return;
"args && raise(E_ARGS);";
"{dummy, @callers} = callers();";
"callers && raise(E_PERM, \"Server-only verb\");";
"/*";
"Only allow the call if the caller is the server.";
"*/";
"/* security audit on Tue Jul 26 15:51:17 2011 EDT */";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"updated_at:Tue Oct 18 07:27:43 2011 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:7
clients = args;
{dummy, @callers} = callers();
callers || raise(E_PERM, "Builtin-only verb");
(((callers[1][4] == $nothing) && (callers[1][3] == $nothing)) && (callers[1][2] != "")) || raise(E_PERM, "Builtin-only verb");
((!clients) || (callers[1][2] in clients)) || raise(E_PERM, tostr("Builtin-only verb:  \"", callers[1][2], "\" not in verb list ", toliteral(clients)));
return;
"clients = args;";
"{dummy, @callers} = callers();";
"callers || raise(E_PERM, \"Builtin-only verb\");";
"callers[1][4] == $nothing && callers[1][3] == $nothing && callers[1][2] != \"\" || raise(E_PERM, \"Builtin-only verb\");";
"!clients || callers[1][2] in clients || raise(E_PERM, tostr(\"Builtin-only verb:  \\\"\", callers[1][2], \"\\\" not in verb list \", toliteral(clients)));";
"/*";
"Only allow the call if the caller is a built-in function.";
"*/";
"/* fixed incorrect implementation of specified test Sat Sep 10 15:39:39 2011 EDT*/";
"/* security audit on Tue Jul 26 15:51:17 2011 EDT */";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode";
"updated_at:Tue Oct 18 07:27:43 2011 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:8
{caller, @clients} = args;
{dummy, @callers} = callers();
callers || raise(E_PERM, "Restricted verb");
((callers[1][4] == caller) && valid(callers[1][1])) || raise(E_PERM, "Restricted verb");
((!clients) || (callers[1][2] in clients)) || raise(E_PERM, tostr("Restricted verb:  \"", callers[1][2], "\" not in verb list ", toliteral(clients)));
return;
"{caller, @clients} = args;";
"{dummy, @callers} = callers();";
"callers || raise(E_PERM, \"Restricted verb\");";
"callers[1][4] == caller && valid(callers[1][1]) || raise(E_PERM, \"Restricted verb\");";
"!clients || callers[1][2] in clients || raise(E_PERM, tostr(\"Restricted verb:  \\\"\", callers[1][2], \"\\\" not in verb list \", toliteral(clients)));";
"/*";
"Only allow the call if the specified caller matches the actual";
"caller.";
"*/";
"/* changed to check the object on which the verb was defined, instead of used Tue Oct 18 07:26:02 2011 EDT */";
"/* security audit on Tue Jul 26 15:51:17 2011 EDT */";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode";
"updated_at:Tue Oct 18 07:27:43 2011 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:9
subjects = args;
callers = callers();
(length(callers) > 1) || raise(E_PERM);
(valid(callers[2][3]) && valid(callers[1][1])) || raise(E_PERM);
if (("wizard" in subjects) && callers[2][3].wizard)
return;
endif
if (("owner" in subjects) && (callers[2][3] == callers[1][1].owner))
return;
endif
if (("programmer" in subjects) && (callers[2][3] == callers[1][3]))
return;
endif
raise(E_PERM);
return;
"subjects = args;";
"callers = callers();";
"length(callers) > 1 || raise(E_PERM);";
"valid(callers[2][3]) && valid(callers[1][1]) || raise(E_PERM);";
"if (\"wizard\" in subjects && callers[2][3].wizard)";
"  return;";
"endif";
"if (\"owner\" in subjects && callers[2][3] == callers[1][1].owner)";
"  return;";
"endif";
"if (\"programmer\" in subjects && callers[2][3] == callers[1][3])";
"  return;";
"endif";
"raise(E_PERM);";
"/*";
"Only allow the call if the caller is a wizard (if the subject";
"\"wizard\" is specified) or the owner of the object the verb was";
"called on (AKA this) (if the subject \"owner\" is specified) or the";
"verb's programmer (if the subject \"programmer\" is specified).";
"*/";
"/* security audit on Tue Jul 26 15:51:17 2011 EDT */";
"";
"chunk_length:21";
"chunk_type:source";
"content_type:application/x-moocode";
"updated_at:Mon Oct 24 00:04:09 2011 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:10
{owner, object} = args;
(caller_perms().wizard || (caller_perms() == owner)) || raise(E_PERM);
if (LIST == typeof(object))
for object in (object)
(((object == $nothing) || (valid(object) && object.f)) || (valid(object) && (owner.wizard || (owner == object.owner)))) || raise(E_PERM);
endfor
else
(((object == $nothing) || (valid(object) && object.f)) || (valid(object) && (owner.wizard || (owner == object.owner)))) || raise(E_PERM);
endif
return;
"{owner, object} = args;";
"caller_perms().wizard || caller_perms() == owner || raise(E_PERM);";
"/* `object' can be $nothing, an object number, or a list of object numbers */";
"if (LIST == typeof(object))";
"  for object in (object)";
"    object == $nothing || (valid(object) && object.f) || (valid(object) && (owner.wizard || owner == object.owner)) || raise(E_PERM);";
"  endfor";
"else";
"  object == $nothing || (valid(object) && object.f) || (valid(object) && (owner.wizard || owner == object.owner)) || raise(E_PERM);";
"endif";
"/* security audit on Tue Jul 26 15:51:17 2011 EDT */";
"";
"content_type:application/x-moocode";
"updated_at:Tue Sep 13 19:26:52 2011 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:11
{owner, object} = args;
(caller_perms().wizard || (caller_perms() == owner)) || raise(E_PERM);
(valid(object) && (owner.wizard || (owner == object.owner))) || raise(E_PERM);
return;
"{owner, object} = args;";
"caller_perms().wizard || caller_perms() == owner || raise(E_PERM);";
"valid(object) && (owner.wizard || owner == object.owner) || raise(E_PERM);";
"/* security audit on Tue Jul 26 15:51:17 2011 EDT */";
"";
"content_type:application/x-moocode";
"updated_at:Tue Sep 13 19:26:52 2011 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:12
{code} = args;
(typeof(code) == LIST) || raise(E_INVARG);
state = 1;
chunks = {};
chunk = [];
chunk_length = 0;
i = length(code);
while (state && i)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
line = code[i];
i = i - 1;
if ((state == 1) && (line == "\"-=-=-mxyzptlk-=-=-\";"))
chunk = ["metadata" -> []];
chunk_length = 0;
state = 2;
elseif (state == 1)
i = i + 1;
state = 0;
elseif ((state == 2) && (r = match(line, "^\"%([-_a-z0-9]+%)%:%(.+%)\";$")))
key = r[4][r[3][1][1]..r[3][1][2]];
value = r[4][r[3][2][1]..r[3][2][2]];
chunk_length = (key == "chunk_length") ? toint(value) | 0;
chunk["metadata"][key] = value;
elseif ((state == 2) && (line == "\"\";"))
chunk["source"] = {};
for line in (code[(i - chunk_length) + 1..i])
chunk["source"] = {@chunk["source"], strsub(strsub(line[2..$ - 2], "\\\"", "\""), "\\\\", "\\")};
endfor
i = i - chunk_length;
state = 3;
elseif ((state == 3) && (line == "return;"))
chunks = {chunk, @chunks};
state = 0;
elseif ((state == 3) && (line == "\"-=-=-mxyzptlk-=-=-\";"))
chunks = {chunk, @chunks};
chunk = ["metadata" -> []];
chunk_length = 0;
state = 2;
elseif ((state == 3) && (r = match(line, ((((("^\"%(%(" + "[^\\\"]+") + "%|") + "\\\\") + "%|") + "\\\"") + "%)*%)\";$")))
line = strsub(strsub(r[4][r[3][1][1]..r[3][1][2]], "\\\"", "\""), "\\\\", "\\");
chunk["source"] = {line, @chunk["source"]};
elseif (state == 2)
raise(E_INVARG, tostr("Bad metadata:  ", line));
elseif (state == 3)
raise(E_INVARG, tostr("Missing return:  ", line));
else
raise(E_INVARG);
endif
endwhile
if (state > 1)
raise(E_INVARG, "Corrupt source");
endif
chunks = {["code" -> code[1..i]], @chunks};
return chunks;
return;
"{code} = args;";
"";
"/* Not $private() but maybe should be.  The existance and interface";
" * are subject to change.  No obvious security problems, though.";
" */";
"";
"typeof(code) == LIST || raise(E_INVARG);";
"";
"/* State:";
" *   0 = done";
" *   1 = looking for a boundary";
" *   2 = reading metadata";
" *   3 = reading source";
" */";
"state = 1;";
"";
"/* Strinctly speaking, \"chunk_length\" is optional.  If it's present,";
" * use the value to skip past lines of source.  Otherwise, use the";
" * more error-prone search-for-the-boundary method.";
" */";
"chunks = {};";
"chunk = [];";
"chunk_length = 0;";
"";
"i = length(code);";
"while (state && i)";
"  (ticks_left() < 10000 || seconds_left() < 2) &&";
"    suspend(0);";
"  line = code[i];";
"  i = i - 1;";
"  if (state == 1 && line == \"\\\"-=-=-mxyzptlk-=-=-\\\";\")";
"    chunk = [\"metadata\" -> []];";
"    chunk_length = 0;";
"    state = 2;";
"  elseif (state == 1)";
"    i = i + 1;";
"    state = 0;";
"  elseif (state == 2 && (r = match(line, \"^\\\"%([-_a-z0-9]+%)%:%(.+%)\\\";$\")))";
"    key = r[4][r[3][1][1]..r[3][1][2]];";
"    value = r[4][r[3][2][1]..r[3][2][2]];";
"    chunk_length = (key == \"chunk_length\" ) ? toint(value) | 0;";
"    chunk[\"metadata\"][key] = value;";
"  elseif (state == 2 && line == \"\\\"\\\";\")";
"    chunk[\"source\"] = {};";
"    for line in (code[i - chunk_length + 1..i])";
"      chunk[\"source\"] = {@chunk[\"source\"], strsub(strsub(line[2..$ - 2], \"\\\\\\\"\", \"\\\"\"), \"\\\\\\\\\", \"\\\\\")};";
"    endfor";
"    i = i - chunk_length;";
"    state = 3;";
"  elseif (state == 3 && line == \"return;\")";
"    chunks = {chunk, @chunks};";
"    state = 0;";
"  elseif (state == 3 && line == \"\\\"-=-=-mxyzptlk-=-=-\\\";\")";
"    chunks = {chunk, @chunks};";
"    chunk = [\"metadata\" -> []];";
"    chunk_length = 0;";
"    state = 2;";
"  elseif (state == 3 && (r = match(line, \"^\\\"%(%(\" + \"[^\\\\\\\"]+\" +  \"%|\" + \"\\\\\\\\\" +  \"%|\" + \"\\\\\\\"\" + \"%)*%)\\\";$\")))";
"    line = strsub(strsub(r[4][r[3][1][1]..r[3][1][2]], \"\\\\\\\"\", \"\\\"\"), \"\\\\\\\\\", \"\\\\\");";
"    chunk[\"source\"] = {line, @chunk[\"source\"]};";
"  elseif (state == 2)";
"    raise(E_INVARG, tostr(\"Bad metadata:  \", line));";
"  elseif (state == 3)";
"    raise(E_INVARG, tostr(\"Missing return:  \", line));";
"  else";
"    raise(E_INVARG);";
"  endif";
"endwhile";
"if (state > 1)";
"  raise(E_INVARG, \"Corrupt source\");";
"endif";
"chunks = {[\"code\" -> code[1..i]], @chunks};";
"";
"return chunks;";
"";
"/* security audit on Tue Sep 13 18:59:04 2011 EDT */";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:77";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:92A11D466C5630A29FF7229853670F7554C38A4E";
"state:clean";
"updated_at:Tue Jul  3 08:43:38 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#0:13
{chunks} = args;
(typeof(chunks) == LIST) || raise(E_INVARG);
state = 1;
code = {};
for chunk in (chunks)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (state > 1)
source = {};
if (state == 2)
source = {"return;"};
state = 3;
endif
for line in (chunk["source"])
source = {@source, toliteral(line) + ";"};
endfor
metadata = {};
for value, key in (chunk["metadata"])
metadata = {@metadata, toliteral(tostr(key, ":", value)) + ";"};
endfor
code = {@code, @source, "\"\";", @metadata, "\"-=-=-mxyzptlk-=-=-\";"};
else
code = chunk["code"];
state = 2;
endif
endfor
return code;
return;
"{chunks} = args;";
"";
"/* Not $private() but maybe should be.  The existance and interface";
" * are subject to change.  No obvious security problems, though.";
" */";
"";
"typeof(chunks) == LIST || raise(E_INVARG);";
"";
"/* State:";
" *   1 = adding code chunk";
" *   2 = adding first source chunk";
" *   3 = adding source chunk";
" */";
"state = 1;";
"";
"code = {};";
"";
"for chunk in (chunks)";
"  (ticks_left() < 10000 || seconds_left() < 2) &&";
"    suspend(0);";
"  if (state > 1)";
"    source = {};";
"    if (state == 2)";
"      source = {\"return;\"};";
"      state = 3;";
"    endif";
"    for line in (chunk[\"source\"])";
"      source = {@source, toliteral(line) + \";\"};";
"    endfor";
"    metadata = {};";
"    for value, key in (chunk[\"metadata\"])";
"      metadata = {@metadata, toliteral(tostr(key, \":\", value)) + \";\"};";
"    endfor";
"    code = {@code, @source, \"\\\"\\\";\", @metadata, \"\\\"-=-=-mxyzptlk-=-=-\\\";\"};";
"  else";
"    code = chunk[\"code\"];";
"    state = 2;";
"  endif";
"endfor";
"";
"return code;";
"";
"/* security audit on Tue Sep 13 18:59:04 2011 EDT */";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:44";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:9CAE265C4C667DE8BFFE28FE6856683DA259F29B";
"state:clean";
"updated_at:Tue Jul  3 08:42:40 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#0:14
{object, verb, @options} = args;
valid(object) || raise(E_INVARG);
`{owner, flags, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);
perms = caller_perms();
((perms.wizard || (perms == owner)) || index(flags, "r")) || raise(E_PERM);
perms.programmer || raise(E_PERM);
set_task_perms(perms);
raw = 0;
fully_parenthesize = 0;
indent = 1;
if (options)
if (typeof(options[1]) == MAP)
`raw = options[1]["raw"] ! E_RANGE';
`fully_parenthesize = options[1]["fully_parenthesize"] || options[1]["fully-parenthesize"] ! E_RANGE';
`indent = options[1]["indent"] ! E_RANGE';
`revision = options[1]["revision"] ! E_RANGE';
elseif (typeof(options[1]) == STR)
raw = "raw" in options;
fully_parenthesize = ("fully_parenthesize" in options) || ("fully-parenthesize" in options);
indent = "indent" in options;
elseif (typeof(options[1]) == INT)
`fully_parenthesize = options[1] ! E_RANGE';
`indent = options[2] ! E_RANGE';
endif
endif
code = verb_code(object, verb, fully_parenthesize, indent);
chunks = this:_unpack_verb_code(code);
if (`revision ! ANY' != E_VARNF)
n = 0;
for chunk, i in (chunks)
if ((`toint(chunk["metadata"]["revision"]) ! E_RANGE, E_TYPE' == revision) && revision)
n = i;
break;
endif
endfor
(!n) && raise(E_INVARG, "No such revision");
else
n = 2;
endif
return ((!raw) && (length(chunks) > 1)) ? chunks[n]["source"] | chunks[1]["code"];
return;
"{object, verb, @options} = args;";
"";
"/* check arguments and permissions */";
"valid(object) || raise(E_INVARG);";
"`{owner, flags, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"perms = caller_perms();";
"perms.wizard || (perms == owner) || index(flags, \"r\") || raise(E_PERM);";
"perms.programmer || raise(E_PERM);";
"";
"/* drop wiz-perms */";
"set_task_perms(perms);";
"";
"/* interpret optional arguments */";
"raw = 0;";
"fully_parenthesize = 0;";
"indent = 1;";
"if (options)";
"  if (typeof(options[1]) == MAP)";
"    `raw = options[1][\"raw\"] ! E_RANGE';";
"    `fully_parenthesize = options[1][\"fully_parenthesize\"] || options[1][\"fully-parenthesize\"] ! E_RANGE';";
"    `indent = options[1][\"indent\"] ! E_RANGE';";
"    `revision = options[1][\"revision\"] ! E_RANGE';";
"  elseif (typeof(options[1]) == STR)";
"    raw = (\"raw\" in options);";
"    fully_parenthesize = (\"fully_parenthesize\" in options) || (\"fully-parenthesize\" in options) ;";
"    indent = (\"indent\" in options);";
"  elseif (typeof(options[1]) == INT)";
"    `fully_parenthesize = options[1] ! E_RANGE';";
"    `indent = options[2] ! E_RANGE';";
"  endif";
"endif";
"";
"code = verb_code(object, verb, fully_parenthesize, indent);";
"chunks = this:_unpack_verb_code(code);";
"";
"if (`revision ! ANY' != E_VARNF)";
"  n = 0;";
"  for chunk, i in (chunks)";
"    if (`toint(chunk[\"metadata\"][\"revision\"]) ! E_RANGE, E_TYPE' == revision && revision)";
"      n = i;";
"      break;";
"    endif";
"  endfor";
"  !n && raise(E_INVARG, \"No such revision\");";
"else";
"  n = 2;";
"endif";
"";
"return (!raw && length(chunks) > 1) ? chunks[n][\"source\"] | chunks[1][\"code\"];";
"";
"/* security audit on Tue Sep 13 18:59:04 2011 EDT */";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:52";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:93F4856A7AF92AD16B1806C1421B76C27C8E24A6";
"state:clean";
"updated_at:Sun May 27 12:50:21 2012 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:15
{object, verb, code, @options} = args;
valid(object) || raise(E_INVARG);
`{owner, flags, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);
perms = caller_perms();
((perms.wizard || (perms == owner)) || index(flags, "w")) || raise(E_PERM);
perms.programmer || raise(E_PERM);
set_task_perms(perms);
raw = 1;
content_type = 0;
do_not_version = 0;
do_not_stamp = 0;
if (options)
if (typeof(options[1]) == MAP)
raw = `options[1]["raw"] ! E_RANGE';
content_type = `options[1]["content_type"] ! E_RANGE' || `options[1]["content-type"] ! E_RANGE';
do_not_version = `options[1]["do_not_version"] ! E_RANGE' || `options[1]["do-not-version"] ! E_RANGE';
do_not_stamp = `options[1]["do_not_stamp"] ! E_RANGE' || `options[1]["do-not-stamp"] ! E_RANGE';
elseif ((typeof(options[1]) == STR) && (options[1] == "raw"))
raw = "raw";
elseif (typeof(options[1]) == STR)
raw = 0;
content_type = options[1];
endif
if (raw && content_type)
raise(E_INVARG);
endif
endif
chunks = {};
if (temp = verb_code(object, verb))
chunks = this:_unpack_verb_code(temp);
endif
if ((!options) && (!content_type))
if (`content_type = chunks[2]["metadata"]["content_type"] ! E_RANGE')
raw = 0;
endif
endif
(do_not_version && chunks) && raise(E_INVARG);
(do_not_stamp && chunks) && raise(E_INVARG);
if ((raw && code) && (code[$] == "\"-=-=-mxyzptlk-=-=-\";"))
return {"Illegal use of marker"};
elseif (content_type)
source = code;
{type, attributes} = this:_parse_content_type(content_type);
content_type = this:_generate_content_type({type, attributes});
if ((type == "application/x-moocode") && (!attributes))
elseif (`valid(compiler = this:_match_external_compiler(type, attributes)) ! ANY')
{status, code} = compiler:compile(code, attributes);
if (!status)
return code;
endif
else
return {tostr("Unknown content type:  ", content_type)};
endif
if (length(chunks) > 1)
if (`chunks[2]["metadata"]["state"] ! E_RANGE' == "clean")
revision = `toint(chunks[2]["metadata"]["revision"]) + 1 ! E_RANGE => 1';
keep = chunks[2..$];
else
revision = `toint(chunks[2]["metadata"]["revision"]) ! E_RANGE => 1';
keep = chunks[3..$];
endif
else
revision = 1;
keep = {};
endif
metadata = ["chunk_type" -> "source", "chunk_length" -> length(source), "content_type" -> content_type, "sha1" -> value_hash(source, "sha1")];
if ((!do_not_version) || chunks)
metadata["state"] = "dirty";
metadata["revision"] = revision;
endif
if ((!do_not_stamp) || chunks)
metadata["updated_at"] = ctime(time());
metadata["updated_by"] = perms;
endif
code = this:_pack_verb_code({["code" -> code], ["metadata" -> metadata, "source" -> source], @keep});
endif
return set_verb_code(object, verb, code);
return;
"{object, verb, code, @options} = args;";
"";
"/* check arguments and permissions */";
"valid(object) || raise(E_INVARG);";
"`{owner, flags, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"perms = caller_perms();";
"perms.wizard || (perms == owner) || index(flags, \"w\") || raise(E_PERM);";
"perms.programmer || raise(E_PERM);";
"";
"/* drop wiz-perms */";
"set_task_perms(perms);";
"";
"/* interpret optional arguments */";
"raw = 1;";
"content_type = 0;";
"do_not_version = 0;";
"do_not_stamp = 0;";
"if (options)";
"  if (typeof(options[1]) == MAP)";
"    raw = `options[1][\"raw\"] ! E_RANGE';";
"    content_type = `options[1][\"content_type\"] ! E_RANGE' || `options[1][\"content-type\"] ! E_RANGE';";
"    do_not_version = `options[1][\"do_not_version\"] ! E_RANGE' || `options[1][\"do-not-version\"] ! E_RANGE';";
"    do_not_stamp = `options[1][\"do_not_stamp\"] ! E_RANGE' || `options[1][\"do-not-stamp\"] ! E_RANGE';";
"  elseif (typeof(options[1]) == STR && options[1] == \"raw\")";
"    raw = \"raw\";";
"  elseif (typeof(options[1]) == STR)";
"    raw = 0;";
"    content_type = options[1];";
"  endif";
"  if (raw && content_type)";
"    raise(E_INVARG);";
"  endif";
"endif";
"";
"chunks = {};";
"if (temp = verb_code(object, verb))";
"  chunks = this:_unpack_verb_code(temp);";
"endif";
"";
"/* Iff no options are specified, use the content type of the verb";
" * source as the content type.  This alternative exists only to support";
" * legacy editors/tools.  It may be removed.";
" */";
"if (!options && !content_type)";
"  if (`content_type = chunks[2][\"metadata\"][\"content_type\"] ! E_RANGE')";
"    raw = 0;";
"  endif";
"endif";
"";
"/* Programmers can disable versioning (writing \"state\" and \"revision\")";
" * and stamping (writing \"updated_at\" and \"updated_by\"), however this";
" * only works the first time the verb code is set (the purpose of this";
" * functionality is to support package loading and other kinds of";
" * object migration).";
" */";
"do_not_version && chunks && raise(E_INVARG);";
"do_not_stamp && chunks && raise(E_INVARG);";
"";
"if (raw && code && code[$] == \"\\\"-=-=-mxyzptlk-=-=-\\\";\")";
"  return {\"Illegal use of marker\"};";
"";
"elseif (content_type)";
"  source = code;";
"";
"  /* parse the content type to validate it, then generate it in canonical form */";
"  {type, attributes} = this:_parse_content_type(content_type);";
"  content_type = this:_generate_content_type({type, attributes});";
"";
"  /* natively supported... no external compilation necessary */";
"  if (type == \"application/x-moocode\" && !attributes)";
"    ;";
"";
"  /* find an external compiler and compile */";
"  elseif (`valid(compiler = this:_match_external_compiler(type, attributes)) ! ANY')";
"    {status, code} = compiler:compile(code, attributes);";
"    if (!status)";
"      return code;";
"    endif";
"";
"  /* fail */";
"  else";
"    return {tostr(\"Unknown content type:  \", content_type)};";
"  endif";
"";
"  /* If the most recent revision is clean, increment the revision and";
"   * keep all prior revisions.  Else, replace the revision.";
"   */";
"  if (length(chunks) > 1)";
"    if (`chunks[2][\"metadata\"][\"state\"] ! E_RANGE' == \"clean\")";
"      revision = `toint(chunks[2][\"metadata\"][\"revision\"]) + 1 ! E_RANGE => 1';";
"      keep = chunks[2..$];";
"    else";
"      revision = `toint(chunks[2][\"metadata\"][\"revision\"]) ! E_RANGE => 1';";
"      keep = chunks[3..$];";
"    endif";
"  else";
"    revision = 1;";
"    keep = {};";
"  endif";
"";
"  metadata = [";
"    \"chunk_type\" -> \"source\",";
"    \"chunk_length\" -> length(source),";
"    \"content_type\" -> content_type,";
"    \"sha1\" -> value_hash(source, \"sha1\")";
"  ];";
"  if (!do_not_version || chunks)";
"    metadata[\"state\"] = \"dirty\";";
"    metadata[\"revision\"] = revision;";
"  endif";
"  if (!do_not_stamp || chunks)";
"    metadata[\"updated_at\"] = ctime(time());";
"    metadata[\"updated_by\"] = perms;";
"  endif";
"";
"  code = this:_pack_verb_code({[\"code\" -> code], [\"metadata\" -> metadata, \"source\" -> source], @keep});";
"";
"endif";
"";
"return set_verb_code(object, verb, code);";
"";
"/* security audit on Tue Sep 13 18:59:04 2011 EDT */";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:123";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:5";
"sha1:D3B17FBC9EA456126D45ED5B4C111565F7A08FDF";
"state:clean";
"updated_at:Thu Dec 20 06:18:25 2012 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"{object, verb, code, @options} = args;";
"";
"/* check arguments and permissions */";
"valid(object) || raise(E_INVARG);";
"`{owner, flags, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"perms = caller_perms();";
"perms.wizard || (perms == owner) || index(flags, \"w\") || raise(E_PERM);";
"perms.programmer || raise(E_PERM);";
"";
"/* drop wiz-perms */";
"set_task_perms(perms);";
"";
"/* interpret optional arguments */";
"raw = 1;";
"content_type = 0;";
"do_not_version = 0;";
"do_not_stamp = 0;";
"if (options)";
"  if (typeof(options[1]) == MAP)";
"    raw = `options[1][\"raw\"] ! E_RANGE';";
"    content_type = `options[1][\"content_type\"] ! E_RANGE' || `options[1][\"content-type\"] ! E_RANGE';";
"    do_not_version = `options[1][\"do_not_version\"] ! E_RANGE' || `options[1][\"do-not-version\"] ! E_RANGE';";
"    do_not_stamp = `options[1][\"do_not_stamp\"] ! E_RANGE' || `options[1][\"do-not-stamp\"] ! E_RANGE';";
"  elseif (typeof(options[1]) == STR && options[1] == \"raw\")";
"    raw = \"raw\";";
"  elseif (typeof(options[1]) == STR)";
"    raw = 0;";
"    content_type = options[1];";
"  endif";
"  if (raw && content_type)";
"    raise(E_INVARG);";
"  endif";
"endif";
"";
"chunks = {};";
"if (temp = verb_code(object, verb))";
"  chunks = this:_unpack_verb_code(temp);";
"endif";
"";
"/* Iff no options are specified, use the content type of the verb";
" * source as the content type.  This alternative exists only to support";
" * legacy editors/tools.  It may be removed.";
" */";
"if (!options && !content_type)";
"  if (`content_type = chunks[2][\"metadata\"][\"content_type\"] ! E_RANGE')";
"    raw = 0;";
"  endif";
"endif";
"";
"/* Programmers can disable versioning (writing \"state\" and \"revision\")";
" * and stamping (writing \"updated_at\" and \"updated_by\"), however this";
" * only works the first time the verb code is set (the purpose of this";
" * functionality is to support package loading and other kinds of";
" * object migration).";
" */";
"do_not_version && chunks && raise(E_INVARG);";
"do_not_stamp && chunks && raise(E_INVARG);";
"";
"if (raw && code && code[$] == \"\\\"-=-=-mxyzptlk-=-=-\\\";\")";
"  return {\"Illegal use of marker\"};";
"";
"elseif (content_type)";
"  source = code;";
"";
"  /* parse the content type to validate it, then generate it in canonical form */";
"  {type, attributes} = this:_parse_content_type(content_type);";
"  content_type = this:_generate_content_type({type, attributes});";
"";
"  /* natively supported... no external compilation necessary */";
"  if (type == \"application/x-moocode\")";
"    ;";
"";
"  /* find an external compiler and compile */";
"  elseif (`valid(compiler = $external_compilers[type]) ! E_RANGE, E_TYPE')";
"    {status, code} = compiler:compile(code, attributes);";
"    if (!status)";
"      return code;";
"    endif";
"";
"  /* fail */";
"  else";
"    return {tostr(\"Invalid content type:  \", type)};";
"  endif";
"";
"  /* If the most recent revision is clean, increment the revision and";
"   * keep all prior revisions.  Else, replace the revision.";
"   */";
"  if (length(chunks) > 1)";
"    if (`chunks[2][\"metadata\"][\"state\"] ! E_RANGE' == \"clean\")";
"      revision = `toint(chunks[2][\"metadata\"][\"revision\"]) + 1 ! E_RANGE => 1';";
"      keep = chunks[2..$];";
"    else";
"      revision = `toint(chunks[2][\"metadata\"][\"revision\"]) ! E_RANGE => 1';";
"      keep = chunks[3..$];";
"    endif";
"  else";
"    revision = 1;";
"    keep = {};";
"  endif";
"";
"  metadata = [";
"    \"chunk_type\" -> \"source\",";
"    \"chunk_length\" -> length(source),";
"    \"content_type\" -> content_type,";
"    \"sha1\" -> value_hash(source, \"sha1\")";
"  ];";
"  if (!do_not_version || chunks)";
"    metadata[\"state\"] = \"dirty\";";
"    metadata[\"revision\"] = revision;";
"  endif";
"  if (!do_not_stamp || chunks)";
"    metadata[\"updated_at\"] = ctime(time());";
"    metadata[\"updated_by\"] = perms;";
"  endif";
"";
"  code = this:_pack_verb_code({[\"code\" -> code], [\"metadata\" -> metadata, \"source\" -> source], @keep});";
"";
"endif";
"";
"return set_verb_code(object, verb, code);";
"";
"/* security audit on Tue Sep 13 18:59:04 2011 EDT */";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:123";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:4";
"sha1:331D0374823E49B367CF562E48625F45DD0F8066";
"state:clean";
"updated_at:Thu Dec 13 07:27:09 2012 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"{object, verb, code, @options} = args;";
"";
"/* check arguments and permissions */";
"valid(object) || raise(E_INVARG);";
"`{owner, flags, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"perms = caller_perms();";
"perms.wizard || (perms == owner) || index(flags, \"w\") || raise(E_PERM);";
"perms.programmer || raise(E_PERM);";
"";
"/* drop wiz-perms */";
"set_task_perms(perms);";
"";
"/* interpret optional arguments */";
"raw = 1;";
"content_type = 0;";
"do_not_version = 0;";
"do_not_stamp = 0;";
"if (options)";
"  if (typeof(options[1]) == MAP)";
"    raw = `options[1][\"raw\"] ! E_RANGE';";
"    content_type = `options[1][\"content_type\"] ! E_RANGE' || `options[1][\"content-type\"] ! E_RANGE';";
"    do_not_version = `options[1][\"do_not_version\"] ! E_RANGE' || `options[1][\"do-not-version\"] ! E_RANGE';";
"    do_not_stamp = `options[1][\"do_not_stamp\"] ! E_RANGE' || `options[1][\"do-not-stamp\"] ! E_RANGE';";
"  elseif (typeof(options[1]) == STR && options[1] == \"raw\")";
"    raw = \"raw\";";
"  elseif (typeof(options[1]) == STR)";
"    raw = 0;";
"    content_type = options[1];";
"  endif";
"  if (raw && content_type)";
"    raise(E_INVARG);";
"  endif";
"endif";
"";
"chunks = {};";
"if (temp = verb_code(object, verb))";
"  chunks = this:_unpack_verb_code(temp);";
"endif";
"";
"/* Iff no options are specified, use the content type of the verb";
" * source as the content type.  This alternative exists only to support";
" * legacy editors/tools.  It may be removed.";
" */";
"if (!options && !content_type)";
"  if (`content_type = chunks[2][\"metadata\"][\"content_type\"] ! E_RANGE')";
"    raw = 0;";
"  endif";
"endif";
"";
"/* Programmers can disable versioning (writing \"state\" and \"revision\")";
" * and stamping (writing \"updated_at\" and \"updated_by\"), however this";
" * only works the first time the verb code is set (the purpose of this";
" * functionality is to support package loading and other kinds of";
" * object migration).";
" */";
"do_not_version && chunks && raise(E_INVARG);";
"do_not_stamp && chunks && raise(E_INVARG);";
"";
"if (raw && code && code[$] == \"\\\"-=-=-mxyzptlk-=-=-\\\";\")";
"  return {\"Illegal use of marker\"};";
"";
"elseif (content_type)";
"  source = code;";
"";
"  /* parse the content type to validate it, then generate it in canonical form */";
"  {type, attributes} = this:_parse_content_type(content_type);";
"  content_type = this:_generate_content_type({type, attributes});";
"";
"  /* natively supported... no external compilation necessary */";
"  if (type == \"application/x-moocode\")";
"    ;";
"";
"  /* find an external compiler and compile */";
"  elseif (`valid(compiler = $external_compilers[type]) ! E_RANGE, E_TYPE')";
"    code = compiler:compile(code, attributes);";
"";
"  /* fail */";
"  else";
"    return {tostr(\"Invalid content type:  \", type)};";
"  endif";
"";
"  /* If the most recent revision is clean, increment the revision and";
"   * keep all prior revisions.  Else, replace the revision.";
"   */";
"  if (length(chunks) > 1)";
"    if (`chunks[2][\"metadata\"][\"state\"] ! E_RANGE' == \"clean\")";
"      revision = `toint(chunks[2][\"metadata\"][\"revision\"]) + 1 ! E_RANGE => 1';";
"      keep = chunks[2..$];";
"    else";
"      revision = `toint(chunks[2][\"metadata\"][\"revision\"]) ! E_RANGE => 1';";
"      keep = chunks[3..$];";
"    endif";
"  else";
"    revision = 1;";
"    keep = {};";
"  endif";
"";
"  metadata = [";
"    \"chunk_type\" -> \"source\",";
"    \"chunk_length\" -> length(source),";
"    \"content_type\" -> content_type,";
"    \"sha1\" -> value_hash(source, \"sha1\")";
"  ];";
"  if (!do_not_version || chunks)";
"    metadata[\"state\"] = \"dirty\";";
"    metadata[\"revision\"] = revision;";
"  endif";
"  if (!do_not_stamp || chunks)";
"    metadata[\"updated_at\"] = ctime(time());";
"    metadata[\"updated_by\"] = perms;";
"  endif";
"";
"  code = this:_pack_verb_code({[\"code\" -> code], [\"metadata\" -> metadata, \"source\" -> source], @keep});";
"";
"endif";
"";
"return set_verb_code(object, verb, code);";
"";
"/* security audit on Tue Sep 13 18:59:04 2011 EDT */";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:120";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:3";
"sha1:68360A844092C7A98B6F05C66C2D028240946236";
"state:clean";
"updated_at:Thu Jun  7 08:12:38 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"{object, verb, code, @options} = args;";
"";
"/* check arguments and permissions */";
"valid(object) || raise(E_INVARG);";
"`{owner, flags, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"perms = caller_perms();";
"perms.wizard || (perms == owner) || index(flags, \"w\") || raise(E_PERM);";
"perms.programmer || raise(E_PERM);";
"";
"/* drop wiz-perms */";
"set_task_perms(perms);";
"";
"/* interpret optional arguments */";
"raw = 1;";
"content_type = 0;";
"if (options)";
"  if (typeof(options[1]) == MAP)";
"    raw = `options[1][\"raw\"] ! E_RANGE';";
"    content_type = `options[1][\"content_type\"] ! E_RANGE' || `options[1][\"content-type\"] ! E_RANGE';";
"  elseif (typeof(options[1]) == STR && options[1] == \"raw\")";
"    raw = \"raw\";";
"  elseif (typeof(options[1]) == STR)";
"    raw = 0;";
"    content_type = options[1];";
"  endif";
"  if (raw && content_type)";
"    raise(E_INVARG);";
"  endif";
"endif";
"";
"chunks = {};";
"if (temp = verb_code(object, verb))";
"  chunks = this:_unpack_verb_code(temp);";
"endif";
"";
"/* Iff no options are specified, use the content type of the verb";
" * source as the content type.  This alternative exists only to support";
" * legacy editors/tools.  It may be removed.";
" */";
"if (!options && !content_type)";
"  if (`content_type = chunks[2][\"metadata\"][\"content_type\"] ! E_RANGE')";
"    raw = 0;";
"  endif";
"endif";
"";
"if (raw && code && code[$] == \"\\\"-=-=-mxyzptlk-=-=-\\\";\")";
"  return {\"Illegal use of marker\"};";
"";
"elseif (content_type)";
"  source = code;";
"";
"  /* parse the content type to validate it, then generate it in canonical form */";
"  {type, attributes} = this:_parse_content_type(content_type);";
"  content_type = this:_generate_content_type({type, attributes});";
"";
"  /* natively supported... no external compilation necessary */";
"  if (type == \"application/x-moocode\")";
"    ;";
"";
"  /* find an external compiler and compile */";
"  elseif (`valid(compiler = $external_compilers[type]) ! E_RANGE, E_TYPE')";
"    code = compiler:compile(code, attributes);";
"";
"  /* fail */";
"  else";
"    return {tostr(\"Invalid content type:  \", type)};";
"  endif";
"";
"  /* If the most recent revision is clean, increment the revision and";
"   * keep all prior revisions.  Else, replace the revision.";
"   */";
"  if (length(chunks) > 1)";
"    if (`chunks[2][\"metadata\"][\"state\"] ! E_RANGE' == \"clean\")";
"      revision = `toint(chunks[2][\"metadata\"][\"revision\"]) + 1 ! E_RANGE => 1';";
"      keep = chunks[2..$];";
"    else";
"      revision = `toint(chunks[2][\"metadata\"][\"revision\"]) ! E_RANGE => 1';";
"      keep = chunks[3..$];";
"    endif";
"  else";
"    revision = 1;";
"    keep = {};";
"  endif";
"";
"  metadata = [";
"    \"chunk_type\" -> \"source\",";
"    \"chunk_length\" -> length(source),";
"    \"updated_at\" -> ctime(time()),";
"    \"updated_by\" -> caller_perms(),";
"    \"content_type\" -> content_type,";
"    \"sha1\" -> value_hash(source, \"sha1\"),";
"    \"state\" -> \"dirty\",";
"    \"revision\" -> revision";
"  ];";
"  code = this:_pack_verb_code({[\"code\" -> code], [\"metadata\" -> metadata, \"source\" -> source], @keep});";
"";
"endif";
"";
"return set_verb_code(object, verb, code);";
"";
"/* security audit on Tue Sep 13 18:59:04 2011 EDT */";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:102";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:B08019A181F1E20328F2B83072D42C20044630C1";
"state:clean";
"updated_at:Sun May 27 13:03:56 2012 EDT";
"updated_by:#5";
"-=-=-mxyzptlk-=-=-";
"{object, verb, code, @options} = args;";
"";
"/* check arguments and permissions */";
"valid(object) || raise(E_INVARG);";
"`{owner, flags, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"perms = caller_perms();";
"perms.wizard || (perms == owner) || index(flags, \"w\") || raise(E_PERM);";
"perms.programmer || raise(E_PERM);";
"";
"/* drop wiz-perms */";
"set_task_perms(perms);";
"";
"/* interpret optional arguments */";
"raw = 1;";
"content_type = 0;";
"if (options)";
"  if (typeof(options[1]) == MAP)";
"    raw = `options[1][\"raw\"] ! E_RANGE';";
"    content_type = `options[1][\"content_type\"] ! E_RANGE' || `options[1][\"content-type\"] ! E_RANGE';";
"  elseif (typeof(options[1]) == STR && options[1] == \"raw\")";
"    raw = \"raw\";";
"  elseif (typeof(options[1]) == STR)";
"    raw = 0;";
"    content_type = options[1];";
"  endif";
"  if (raw && content_type)";
"    raise(E_INVARG);";
"  endif";
"endif";
"";
"chunks = {};";
"if (temp = verb_code(object, verb))";
"  chunks = this:_unpack_verb_code(temp);";
"endif";
"";
"/* Iff no options are specified, use the content type of the verb";
" * source as the content type.  This alternative exists only to support";
" * legacy editors/tools.  It may be removed.";
" */";
"if (!options && !content_type)";
"  if (`content_type = chunks[2][\"metadata\"][\"content_type\"] ! E_RANGE')";
"    raw = 0;";
"  endif";
"endif";
"";
"if (raw && code && code[$] == \"\\\"-=-=-mxyzptlk-=-=-\\\";\")";
"  return {\"Illegal use of marker\"};";
"";
"elseif (content_type)";
"  source = code;";
"";
"  /* parse the content type to validate it, then generate it in canonical form */";
"  {type, attributes} = this:_parse_content_type(content_type);";
"  content_type = this:_generate_content_type({type, attributes});";
"";
"  /* natively supported... no external compilation necessary */";
"  if (type == \"application/x-moocode\")";
"    ;";
"";
"  /* find an external compiler and compile */";
"  elseif (`valid(compiler = $external_compilers[type]) ! E_RANGE, E_TYPE')";
"    code = compiler:compile(code, attributes);";
"";
"  /* fail */";
"  else";
"    return {tostr(\"Invalid content type:  \", type)};";
"  endif";
"";
"  /* If the most recent revision is clean, increment the revision and";
"   * keep all prior revisions.  Else, replace the revision.";
"   */";
"  if (length(chunks) > 1)";
"    if (`chunks[2][\"metadata\"][\"state\"] ! E_RANGE' == \"clean\")";
"      revision = `toint(chunks[2][\"metadata\"][\"revision\"]) + 1 ! E_RANGE => 1';";
"      keep = chunks[2..$];";
"    else";
"      revision = `toint(chunks[2][\"metadata\"][\"revision\"]) ! E_RANGE => 1';";
"      keep = chunks[3..$];";
"    endif";
"  else";
"    revision = 1;";
"    keep = {};";
"  endif";
"";
"  metadata = [";
"    \"chunk_type\" -> \"source\",";
"    \"chunk_length\" -> length(source),";
"    \"updated_at\" -> ctime(time()),";
"    \"content_type\" -> content_type,";
"    \"sha1\" -> value_hash(source, \"sha1\"),";
"    \"state\" -> \"dirty\",";
"    \"revision\" -> revision";
"  ];";
"  code = this:_pack_verb_code({[\"code\" -> code], [\"metadata\" -> metadata, \"source\" -> source], @keep});";
"";
"endif";
"";
"return set_verb_code(object, verb, code);";
"";
"/* security audit on Tue Sep 13 18:59:04 2011 EDT */";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:101";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:3FEC4BE4DEDAED95270BF07692B6CF0DFCC4F5D3";
"state:clean";
"updated_at:Sun May 27 07:16:24 2012 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:16
{object, verb, @options} = args;
valid(object) || raise(E_INVARG);
`{owner, perms, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);
callerp = caller_perms();
((`callerp.wizard ! E_INVIND' || (valid(callerp) && (callerp == owner))) || index(perms, "r")) || raise(E_PERM);
`callerp.programmer ! E_INVIND' || raise(E_PERM);
set_task_perms(callerp);
{dobj, prep, iobj} = verb_args(object, verb);
ret = ["owner" -> owner, "perms" -> perms, "names" -> name, "dobj" -> dobj, "prep" -> prep, "iobj" -> iobj];
code = verb_code(object, verb);
chunks = this:_unpack_verb_code(code);
`ret["updated_at"] = chunks[2]["metadata"]["updated_at"] ! E_RANGE';
`ret["updated_by"] = toobj(chunks[2]["metadata"]["updated_by"]) ! E_RANGE';
`ret["content_type"] = chunks[2]["metadata"]["content_type"] ! E_RANGE';
`ret["sha1"] = chunks[2]["metadata"]["sha1"] ! E_RANGE';
`ret["state"] = chunks[2]["metadata"]["state"] ! E_RANGE';
`ret["revision"] = toint(chunks[2]["metadata"]["revision"]) ! E_RANGE';
return ret;
return;
"{object, verb, @options} = args;";
"";
"/* check arguments */";
"valid(object) || raise(E_INVARG);";
"`{owner, perms, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"";
"/* check permissions */";
"callerp = caller_perms();";
"`callerp.wizard ! E_INVIND' || (valid(callerp) && callerp == owner) || index(perms, \"r\") || raise(E_PERM);";
"`callerp.programmer ! E_INVIND' || raise(E_PERM);";
"";
"/* drop wiz-perms */";
"set_task_perms(callerp);";
"";
"{dobj, prep, iobj} = verb_args(object, verb);";
"";
"ret = [\"owner\" -> owner, \"perms\" -> perms, \"names\" -> name, \"dobj\" -> dobj, \"prep\" -> prep, \"iobj\" -> iobj];";
"";
"code = verb_code(object, verb);";
"chunks = this:_unpack_verb_code(code);";
"";
"`ret[\"updated_at\"] = chunks[2][\"metadata\"][\"updated_at\"] ! E_RANGE';";
"`ret[\"updated_by\"] = toobj(chunks[2][\"metadata\"][\"updated_by\"]) ! E_RANGE';";
"`ret[\"content_type\"] = chunks[2][\"metadata\"][\"content_type\"] ! E_RANGE';";
"`ret[\"sha1\"] = chunks[2][\"metadata\"][\"sha1\"] ! E_RANGE';";
"`ret[\"state\"] = chunks[2][\"metadata\"][\"state\"] ! E_RANGE';";
"`ret[\"revision\"] = toint(chunks[2][\"metadata\"][\"revision\"]) ! E_RANGE';";
"";
"return ret;";
"";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:31";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:172E3B6EFAB13F7D5C64774D3E6BBB8592442EF5";
"state:clean";
"updated_at:Sun May 27 13:06:44 2012 EDT";
"updated_by:#5";
"-=-=-mxyzptlk-=-=-";
"{object, verb, @options} = args;";
"";
"/* check arguments */";
"valid(object) || raise(E_INVARG);";
"`{owner, perms, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"";
"/* check permissions */";
"callerp = caller_perms();";
"`callerp.wizard ! E_INVIND' || (valid(callerp) && callerp == owner) || index(perms, \"r\") || raise(E_PERM);";
"`callerp.programmer ! E_INVIND' || raise(E_PERM);";
"";
"/* drop wiz-perms */";
"set_task_perms(callerp);";
"";
"{dobj, prep, iobj} = verb_args(object, verb);";
"";
"ret = [\"owner\" -> owner, \"perms\" -> perms, \"names\" -> name, \"dobj\" -> dobj, \"prep\" -> prep, \"iobj\" -> iobj];";
"";
"code = verb_code(object, verb);";
"chunks = this:_unpack_verb_code(code);";
"";
"`ret[\"updated_at\"] = chunks[2][\"metadata\"][\"updated_at\"] ! E_RANGE';";
"`ret[\"content_type\"] = chunks[2][\"metadata\"][\"content_type\"] ! E_RANGE';";
"`ret[\"sha1\"] = chunks[2][\"metadata\"][\"sha1\"] ! E_RANGE';";
"`ret[\"state\"] = chunks[2][\"metadata\"][\"state\"] ! E_RANGE';";
"`ret[\"revision\"] = toint(chunks[2][\"metadata\"][\"revision\"]) ! E_RANGE';";
"";
"return ret;";
"";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:30";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:035A143B93AC8FDFCCBC50884B755B42489EBCAE";
"state:clean";
"updated_at:Sun May 27 10:01:53 2012 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:17
{content_type} = args;
parts = {};
while (content_type && (i = index(content_type, ";")))
parts = {@parts, content_type[1..i - 1]};
content_type = content_type[i + 1..$];
endwhile
parts = {@parts, content_type};
if (parts)
{type, @parts} = parts;
r = match(type, "^ *%([^ ]+%) *$");
type = type[r[3][1][1]..r[3][1][2]];
attributes = [];
for part in (parts)
r = match(part, "^ *%([^ ]+%) *%= *%([^ ]+%) *$");
key = part[r[3][1][1]..r[3][1][2]];
value = part[r[3][2][1]..r[3][2][2]];
attributes[key] = value;
endfor
return {type, attributes};
endif
return {};
return;
"{content_type} = args;";
"";
"/* Not $private() but maybe should be.  The existance and interface";
" * are subject to change.  No obvious security problems, though.";
" */";
"";
"parts = {};";
"while (content_type && (i = index(content_type, \";\")))";
"  parts = {@parts, content_type[1..i - 1]};";
"  content_type = content_type[i + 1..$];";
"endwhile";
"parts = {@parts, content_type};";
"if (parts)";
"  {type, @parts} = parts;";
"  r = match(type, \"^ *%([^ ]+%) *$\");";
"  type = type[r[3][1][1]..r[3][1][2]];";
"  attributes = [];";
"  for part in (parts)";
"    r = match(part, \"^ *%([^ ]+%) *%= *%([^ ]+%) *$\");";
"    key = part[r[3][1][1]..r[3][1][2]];";
"    value = part[r[3][2][1]..r[3][2][2]];";
"    attributes[key] = value;";
"  endfor";
"  return {type, attributes};";
"endif";
"";
"return {};";
"";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:29";
"chunk_type:source";
"content_type:application/x-moocode";
"updated_at:Sat Oct  1 18:22:18 2011 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:18
{content_type} = args;
{type, attributes} = content_type;
for attribute in (mapkeys(attributes))
type = tostr(type, ";", attribute, "=", attributes[attribute]);
endfor
return type;
return;
"{content_type} = args;";
"";
"/* Not $private() but maybe should be.  The existance and interface";
" * are subject to change.  No obvious security problems, though.";
" */";
"";
"{type, attributes} = content_type;";
"";
"for attribute in (mapkeys(attributes))";
"  type = tostr(type, \";\", attribute, \"=\", attributes[attribute]);";
"endfor";
"";
"return type;";
"";
"/* security audit on Sat Oct  1 18:04:47 2011 EDT */";
"";
"chunk_length:15";
"chunk_type:source";
"content_type:application/x-moocode";
"updated_at:Sat Oct  1 18:22:18 2011 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:19
{object, verb} = args;
valid(object) || raise(E_INVARG);
`{owner, perms, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);
callerp = caller_perms();
((`callerp.wizard ! ANY' || (valid(callerp) && (callerp == owner))) || index(perms, "r")) || raise(E_PERM);
`callerp.programmer ! ANY' || raise(E_PERM);
set_task_perms(callerp);
code = verb_code(object, verb);
chunks = this:_unpack_verb_code(code);
if (length(chunks) == 1)
raise(E_INVARG, "Nothing to commit:  old-style verb");
endif
if (`chunks[2]["metadata"]["state"] ! E_RANGE' != "dirty")
raise(E_INVARG, "Nothing to commit:  not dirty");
endif
chunks[2]["metadata"]["state"] = "clean";
code = this:_pack_verb_code(chunks);
return set_verb_code(object, verb, code);
return;
"{object, verb} = args;";
"";
"/* check arguments */";
"valid(object) || raise(E_INVARG);";
"`{owner, perms, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"";
"/* check permissions */";
"callerp = caller_perms();";
"`callerp.wizard ! ANY' || (valid(callerp) && callerp == owner) || index(perms, \"r\") || raise(E_PERM);";
"`callerp.programmer ! ANY' || raise(E_PERM);";
"";
"/* drop wiz-perms */";
"set_task_perms(callerp);";
"";
"code = verb_code(object, verb);";
"chunks = this:_unpack_verb_code(code);";
"";
"if (length(chunks) == 1)";
"  raise(E_INVARG, \"Nothing to commit:  old-style verb\");";
"endif";
"";
"if (`chunks[2][\"metadata\"][\"state\"] ! E_RANGE' != \"dirty\")";
"  raise(E_INVARG, \"Nothing to commit:  not dirty\");";
"endif";
"";
"chunks[2][\"metadata\"][\"state\"] = \"clean\";";
"";
"code = this:_pack_verb_code(chunks);";
"";
"return set_verb_code(object, verb, code);";
"";
"chunk_length:30";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:C97460810709B14FD371C31B1E0EF65510578A5F";
"state:clean";
"updated_at:Sun May 27 10:01:53 2012 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:20
{object, verb} = args;
valid(object) || raise(E_INVARG);
`{owner, perms, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);
callerp = caller_perms();
((`callerp.wizard ! ANY' || (valid(callerp) && (callerp == owner))) || index(perms, "r")) || raise(E_PERM);
`callerp.programmer ! ANY' || raise(E_PERM);
set_task_perms(callerp);
code = verb_code(object, verb);
chunks = this:_unpack_verb_code(code);
if (length(chunks) == 1)
raise(E_INVARG, "Nothing to revert:  old-style verb");
endif
if (`chunks[2]["metadata"]["state"] ! E_RANGE' != "dirty")
raise(E_INVARG, "Nothing to revert:  not dirty");
endif
if (length(chunks) < 3)
raise(E_INVARG, "Nothing to revert");
endif
keep = chunks[3..$];
chunk = keep[1];
content_type = chunk["metadata"]["content_type"];
{type, attributes} = this:_parse_content_type(content_type);
content_type = this:_generate_content_type({type, attributes});
if ((type == "application/x-moocode") && (!attributes))
code = chunk["source"];
elseif (`valid(compiler = this:_match_external_compiler(type, attributes)) ! ANY')
{status, code} = compiler:compile(chunk["source"], attributes);
if (!status)
return {tostr("Compilation failed:  ", code)};
endif
else
return {tostr("Invalid content type:  ", type)};
endif
code = this:_pack_verb_code({["code" -> code], @keep});
return set_verb_code(object, verb, code);
return;
"{object, verb} = args;";
"";
"/* check arguments */";
"valid(object) || raise(E_INVARG);";
"`{owner, perms, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"";
"/* check permissions */";
"callerp = caller_perms();";
"`callerp.wizard ! ANY' || (valid(callerp) && callerp == owner) || index(perms, \"r\") || raise(E_PERM);";
"`callerp.programmer ! ANY' || raise(E_PERM);";
"";
"/* drop wiz-perms */";
"set_task_perms(callerp);";
"";
"code = verb_code(object, verb);";
"chunks = this:_unpack_verb_code(code);";
"";
"if (length(chunks) == 1)";
"  raise(E_INVARG, \"Nothing to revert:  old-style verb\");";
"endif";
"";
"if (`chunks[2][\"metadata\"][\"state\"] ! E_RANGE' != \"dirty\")";
"  raise(E_INVARG, \"Nothing to revert:  not dirty\");";
"endif";
"";
"if (length(chunks) < 3)";
"  raise(E_INVARG, \"Nothing to revert\");";
"endif";
"";
"/* discard the raw code and the dirty revision */";
"keep = chunks[3..$];";
"chunk = keep[1];";
"";
"/* a revision should _always_ have a content type */";
"content_type = chunk[\"metadata\"][\"content_type\"];";
"";
"/* parse the content type to validate it, then generate it in canonical form */";
"{type, attributes} = this:_parse_content_type(content_type);";
"content_type = this:_generate_content_type({type, attributes});";
"";
"/* natively supported... no external compilation necessary */";
"if (type == \"application/x-moocode\" && !attributes)";
"  code = chunk[\"source\"];";
"";
"/* find an external compiler and compile */";
"elseif (`valid(compiler = this:_match_external_compiler(type, attributes)) ! ANY')";
"  {status, code} = compiler:compile(chunk[\"source\"], attributes);";
"  if (!status)";
"    return {tostr(\"Compilation failed:  \", code)};";
"  endif";
"";
"/* fail */";
"else";
"  return {tostr(\"Invalid content type:  \", type)};";
"endif";
"";
"code = this:_pack_verb_code({[\"code\" -> code], @keep});";
"";
"return set_verb_code(object, verb, code);";
"";
"chunk_length:59";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:3";
"sha1:F1D5D951AD6CBCDCE9316CD892C13C031718F0B0";
"state:clean";
"updated_at:Wed Jan 23 21:50:19 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"{object, verb} = args;";
"";
"/* check arguments */";
"valid(object) || raise(E_INVARG);";
"`{owner, perms, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"";
"/* check permissions */";
"callerp = caller_perms();";
"`callerp.wizard ! ANY' || (valid(callerp) && callerp == owner) || index(perms, \"r\") || raise(E_PERM);";
"`callerp.programmer ! ANY' || raise(E_PERM);";
"";
"/* drop wiz-perms */";
"set_task_perms(callerp);";
"";
"code = verb_code(object, verb);";
"chunks = this:_unpack_verb_code(code);";
"";
"if (length(chunks) == 1)";
"  raise(E_INVARG, \"Nothing to revert:  old-style verb\");";
"endif";
"";
"if (`chunks[2][\"metadata\"][\"state\"] ! E_RANGE' != \"dirty\")";
"  raise(E_INVARG, \"Nothing to revert:  not dirty\");";
"endif";
"";
"if (length(chunks) < 3)";
"  raise(E_INVARG, \"Nothing to revert\");";
"endif";
"";
"/* discard the raw code and the dirty revision */";
"keep = chunks[3..$];";
"chunk = keep[1];";
"";
"/* a revision should _always_ have a content type */";
"content_type = chunk[\"metadata\"][\"content_type\"];";
"";
"/* parse the content type to validate it, then generate it in canonical form */";
"{type, attributes} = this:_parse_content_type(content_type);";
"content_type = this:_generate_content_type({type, attributes});";
"";
"/* natively supported... no external compilation necessary */";
"if (type == \"application/x-moocode\")";
"  code = chunk[\"source\"];";
"";
"/* find an external compiler and compile */";
"elseif (`valid(compiler = $external_compilers[type]) ! E_RANGE, E_TYPE')";
"  code = compiler:compile(chunk[\"source\"], attributes);";
"";
"/* fail */";
"else";
"  return {tostr(\"Invalid content type:  \", type)};";
"endif";
"";
"code = this:_pack_verb_code({[\"code\" -> code], @keep});";
"";
"return set_verb_code(object, verb, code);";
"";
"chunk_length:56";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:2DAA5677A2901D79B60C15C1A1FA9E068DBD8796";
"state:clean";
"updated_at:Fri Jun  8 08:31:17 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"{object, verb} = args;";
"";
"/* check arguments */";
"valid(object) || raise(E_INVARG);";
"`{owner, perms, name} = verb_info(object, verb) ! ANY' || raise(E_VERBNF);";
"";
"/* check permissions */";
"callerp = caller_perms();";
"`callerp.wizard ! ANY' || (valid(callerp) && callerp == owner) || index(perms, \"r\") || raise(E_PERM);";
"`callerp.programmer ! ANY' || raise(E_PERM);";
"";
"/* drop wiz-perms */";
"set_task_perms(callerp);";
"";
"code = verb_code(object, verb);";
"chunks = this:_unpack_verb_code(code);";
"";
"if (length(chunks) == 1)";
"  raise(E_INVARG, \"Nothing to revert:  old-style verb\");";
"endif";
"";
"if (`chunks[2][\"metadata\"][\"state\"] ! E_RANGE' != \"dirty\")";
"  raise(E_INVARG, \"Nothing to revert:  not dirty\");";
"endif";
"";
"if (length(chunks) < 3)";
"  raise(E_INVARG, \"Nothing to revert\");";
"endif";
"";
"chunks = {chunks[1], @chunks[3..$]};";
"";
"code = this:_pack_verb_code(chunks);";
"";
"return set_verb_code(object, verb, code);";
"";
"chunk_length:34";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:C055EA137DC455E211ACF1EDC5C85327AED1A6EA";
"state:clean";
"updated_at:Sun May 27 10:01:53 2012 EDT";
"-=-=-mxyzptlk-=-=-";
.
#0:21
{reference, ?options = []} = args;
packages = $composed.packages;
provides_cache = $composed.provides_cache;
requires_cache = $composed.requires_cache;
set_task_perms(perms = caller_perms());
if (typeof(`enclosing_package = options["package"] ! E_RANGE') != ERR)
if ((valid(enclosing_package) && (enclosing_package in packages)) && perms.wizard)
elseif (perms.wizard)
raise(E_INVARG);
else
raise(E_PERM);
endif
else
enclosing_package = callers()[1][4];
while (valid(enclosing_package) && (!(enclosing_package in packages)))
enclosing_package = enclosing_package.location;
endwhile
endif
if (!valid(enclosing_package))
raise(E_INVIND, "Invalid indirection:  no enclosing package");
endif
if (reference == "__package__")
return enclosing_package;
elseif (reference == "__owner__")
return enclosing_package.owner;
elseif (r = match(reference, "^%([a-z_][a-z0-9_]*%)%(|%([a-z][a-z0-9_]*%)%)?$"))
reference = r[4][r[3][1][1]..r[3][1][2]];
package = `r[4][r[3][3][1]..r[3][3][2]] ! E_RANGE';
if ((!package) || (package == enclosing_package.identifier))
package = enclosing_package;
else
if (`versions = requires_cache[package] ! E_RANGE')
for packages, version in (versions)
if (enclosing_package in packages)
package = provides_cache[package][version][1];
break;
endif
endfor
else
package = $nothing;
endif
endif
for entry in (`package.manifest ! ANY => {}')
{object, label} = entry;
if (reference == label)
return object;
endif
endfor
endif
return $failed_match;
return;
"{reference, ?options = []} = args;";
"";
"/* get package info... */";
"packages = $composed.packages;";
"provides_cache = $composed.provides_cache;";
"requires_cache = $composed.requires_cache;";
"";
"/* ...then drop perms... */";
"set_task_perms(perms = caller_perms());";
"";
"/* If the caller has wiz-perms, it can set the enclosing package";
" * explicitly.  The enclosing package is the point-of-view from";
" * which we look up references.";
" */";
"if (typeof(`enclosing_package = options[\"package\"] ! E_RANGE') != ERR)";
"  if (valid(enclosing_package) && (enclosing_package in packages) && perms.wizard)";
"    ;";
"  elseif (perms.wizard)";
"    raise(E_INVARG);";
"  else";
"    raise(E_PERM);";
"  endif";
"";
"/* Otherwise, start where the verb was defined and search for";
" * the enclosing package.";
" */";
"else";
"  enclosing_package = callers()[1][4];";
"  while (valid(enclosing_package) && !(enclosing_package in packages))";
"    enclosing_package = enclosing_package.location;";
"  endwhile";
"";
"endif";
"";
"/* Raise an error if we make it to the top without finding an";
" * enclosing package -- this typically means that `$lookup()' has been";
" * called from a verb on an object that is in a package that has not";
" * yet been _installed_.";
" */";
"if (!valid(enclosing_package))";
"  raise(E_INVIND, \"Invalid indirection:  no enclosing package\");";
"endif";
"";
"/* find the reference */";
"if (reference == \"__package__\")";
"  return enclosing_package;";
"";
"elseif (reference == \"__owner__\")";
"  return enclosing_package.owner;";
"";
"elseif (r = match(reference, \"^%([a-z_][a-z0-9_]*%)%(|%([a-z][a-z0-9_]*%)%)?$\"))";
"  reference = r[4][r[3][1][1]..r[3][1][2]];";
"  package = `r[4][r[3][3][1]..r[3][3][2]] ! E_RANGE';";
"  if (!package || (package == enclosing_package.identifier))";
"    package = enclosing_package;";
"  else";
"    if (`versions = requires_cache[package] ! E_RANGE')";
"      for packages, version in (versions)";
"        if (enclosing_package in packages)";
"          package = provides_cache[package][version][1];";
"          break;";
"        endif";
"      endfor";
"    else";
"      package = $nothing;";
"    endif";
"  endif";
"  for entry in (`package.manifest ! ANY => {}')";
"    {object, label} = entry;";
"    if (reference == label)";
"      return object;";
"    endif";
"  endfor";
"endif";
"";
"return $failed_match;";
"";
"chunk_length:76";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:47F06BC1BFE0AF565C3F48257B346AB3F86F6F74";
"state:clean";
"updated_at:Tue Jul 10 07:24:45 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"{reference, ?options = []} = args;";
"";
"/* get package info... */";
"packages = $composed.packages;";
"provides_cache = $composed.provides_cache;";
"requires_cache = $composed.requires_cache;";
"";
"/* ...then drop perms... */";
"set_task_perms(perms = caller_perms());";
"";
"/* If the caller has wiz-perms, it can set the enclosing package";
" * explicitly.  The enclosing package is the point-of-view from";
" * which we look up references.";
" */";
"if (typeof(`enclosing_package = options[\"package\"] ! E_RANGE') != ERR)";
"  if (valid(enclosing_package) && (enclosing_package in packages) && perms.wizard)";
"    ;";
"  elseif (perms.wizard)";
"    raise(E_INVARG);";
"  else";
"    raise(E_PERM);";
"  endif";
"";
"/* Otherwise, start where the verb was defined and search for";
" * the enclosing package.";
" */";
"else";
"  enclosing_package = callers()[1][4];";
"  while (valid(enclosing_package) && !(enclosing_package in packages))";
"    enclosing_package = enclosing_package.location;";
"  endwhile";
"";
"endif";
"";
"/* Raise an error if we make it to the top without finding an";
" * enclosing package -- this typically means that `$lookup()' has been";
" * called from a verb on an object that is in a package that has not";
" * yet been _installed_.";
" */";
"if (!valid(enclosing_package))";
"  raise(E_INVIND, \"Invalid indirection:  no enclosing package\");";
"endif";
"";
"/* find the reference */";
"if (reference == \"__package__\")";
"  return enclosing_package;";
"";
"elseif (reference == \"__owner__\")";
"  return enclosing_package.owner;";
"";
"elseif (r = match(reference, \"^%([a-z_][a-z0-9_]*%)%(|%([a-z][a-z0-9_]*%)%)?$\"))";
"  reference = r[4][r[3][1][1]..r[3][1][2]];";
"  package = `r[4][r[3][3][1]..r[3][3][2]] ! E_RANGE';";
"  if (package)";
"    if (`versions = requires_cache[package] ! E_RANGE')";
"      for packages, version in (versions)";
"        if (enclosing_package in packages)";
"          package = provides_cache[package][version][1];";
"          break;";
"        endif";
"      endfor";
"    else";
"      package = $nothing;";
"    endif";
"  else";
"    package = enclosing_package;";
"  endif";
"  for entry in (`package.manifest ! ANY => {}')";
"    {object, label} = entry;";
"    if (reference == label)";
"      return object;";
"    endif";
"  endfor";
"endif";
"";
"return $failed_match;";
"";
"chunk_length:76";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:7F52AC72A1975B9D81567EBD29438F08E5A46C18";
"state:clean";
"updated_at:Mon Jun  4 07:46:49 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#0:22
{type, attributes, ?external_compilers = $external_compilers} = args;
for value, key in (external_compilers)
if ((parsed = this:_parse_content_type(key)) && (parsed[1] == type))
pattern = `parsed[2]["version"] ! E_RANGE';
version = `attributes["version"] ! E_RANGE';
if (!pattern)
return value;
elseif (version)
pattern = strsub(strsub(pattern, ".", "%."), "*", "[^%.]*");
if (match(version, pattern))
return value;
endif
endif
endif
endfor
return $failed_match;
return;
"{type, attributes, ?external_compilers = $external_compilers} = args;";
"";
"for value, key in (external_compilers)";
"  if ((parsed = this:_parse_content_type(key)) && parsed[1] == type)";
"    pattern = `parsed[2][\"version\"] ! E_RANGE';";
"    version = `attributes[\"version\"] ! E_RANGE';";
"    if (!pattern)";
"      return value;";
"    elseif (version)";
"      pattern = strsub(strsub(pattern, \".\", \"%.\"), \"*\", \"[^%.]*\");";
"      if (match(version, pattern))";
"        return value;";
"      endif";
"    endif";
"  endif";
"endfor";
"";
"return $failed_match;";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:AFFF1A06980617D1A04465EE4B987EF294E61836";
"state:clean";
"updated_at:Thu Dec 20 05:58:54 2012 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#0:23
{permit, ?owner = 0} = args;
task_local = task_local();
caller_perms = caller_perms();
if ((owner != 0) && (owner != caller_perms))
if (!caller_perms.wizard)
raise(E_PERM, "Invalid owner");
elseif ((typeof(owner) != OBJ) || (!valid(owner)))
raise(E_INVARG, "Invalid owner");
endif
else
owner = caller_perms;
endif
if (!`permits = task_local["permits"] ! E_RANGE')
permits = {};
endif
if ((len = length(permits)) > 99)
raise(E_INVARG, "Too many permits");
endif
for i in [1..len]
if (permits[i] == {owner, permit})
raise(E_INVARG, "Duplicate permit");
endif
endfor
task_local["permits"] = listappend(permits, {owner, permit});
set_task_local(task_local);
return permit;
return;
"/* Grants the stated permit.  There is no restriction on what types";
" * of values can be used as permits.  The `owner' defaults to the";
" * caller's permissions, however wizardly players can change the";
" * owner.  Both the permit and the owner are used during matching.";
" */";
"";
"{permit, ?owner = 0} = args;";
"";
"task_local = task_local();";
"caller_perms = caller_perms();";
"";
"if (owner != 0 && owner != caller_perms)";
"  if (!caller_perms.wizard)";
"    raise(E_PERM, \"Invalid owner\");";
"  elseif (typeof(owner) != OBJ || !valid(owner))";
"    raise(E_INVARG, \"Invalid owner\");";
"  endif";
"else";
"  owner = caller_perms;";
"endif";
"";
"if (!(`permits = task_local[\"permits\"] ! E_RANGE'))";
"  permits = {};";
"endif";
"";
"if ((len = length(permits)) > 99)";
"  raise(E_INVARG, \"Too many permits\");";
"endif";
"";
"for i in [1..len]";
"  if (permits[i] == {owner, permit})";
"    raise(E_INVARG, \"Duplicate permit\");";
"  endif";
"endfor";
"";
"task_local[\"permits\"] = listappend(permits, {owner, permit});";
"set_task_local(task_local);";
"";
"return permit;";
"";
"chunk_length:39";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:1725814E8F3E0D1990E3B4CB530E1E2FC038B0E0";
"state:clean";
"updated_at:Fri Jan 11 11:34:32 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"{permit, ?owner = 0} = args;";
"";
"task_local = task_local();";
"caller_perms = caller_perms();";
"";
"if (owner != 0 && owner != caller_perms)";
"  if (!caller_perms.wizard)";
"    raise(E_PERM, \"Invalid owner\");";
"  elseif (typeof(owner) != OBJ || !valid(owner))";
"    raise(E_INVARG, \"Invalid owner\");";
"  endif";
"else";
"  owner = caller_perms;";
"endif";
"";
"if (!(`permits = task_local[\"permits\"] ! E_RANGE'))";
"  permits = {};";
"endif";
"";
"if ((len = length(permits)) > 99)";
"  raise(E_INVARG, \"Too many permits\");";
"endif";
"";
"for i in [1..len]";
"  if (permits[i] == {owner, permit})";
"    raise(E_INVARG, \"Duplicate permit\");";
"  endif";
"endfor";
"";
"task_local[\"permits\"] = listappend(permits, {owner, permit});";
"set_task_local(task_local);";
"";
"return permit;";
"";
"chunk_length:33";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:155C5FFC0500558A30B9AD3E30BD6F1E691966B3";
"state:clean";
"updated_at:Sun Dec 23 08:28:39 2012 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#0:24
{permit, ?owner = 0} = args;
task_local = task_local();
caller_perms = caller_perms();
if ((owner != 0) && (owner != caller_perms))
if (!caller_perms.wizard)
raise(E_PERM, "Invalid owner");
elseif ((typeof(owner) != OBJ) || (!valid(owner)))
raise(E_INVARG, "Invalid owner");
endif
else
owner = caller_perms;
endif
if (!`permits = task_local["permits"] ! E_RANGE')
permits = {};
endif
len = length(permits);
for i in [1..len]
if (permits[i] == {owner, permit})
task_local["permits"] = listdelete(permits, i);
set_task_local(task_local);
return permit;
endif
endfor
raise(E_INVARG, "Invalid permit");
return;
"/* Revokes the stated permit.  A player can only revoke his/her";
" * granted permits, however a wizardly player can specify a value for";
" * `owner' and revoke that owner's permits.";
" */";
"";
"{permit, ?owner = 0} = args;";
"";
"task_local = task_local();";
"caller_perms = caller_perms();";
"";
"if (owner != 0 && owner != caller_perms)";
"  if (!caller_perms.wizard)";
"    raise(E_PERM, \"Invalid owner\");";
"  elseif (typeof(owner) != OBJ || !valid(owner))";
"    raise(E_INVARG, \"Invalid owner\");";
"  endif";
"else";
"  owner = caller_perms;";
"endif";
"";
"if (!(`permits = task_local[\"permits\"] ! E_RANGE'))";
"  permits = {};";
"endif";
"";
"len = length(permits);";
"";
"for i in [1..len]";
"  if (permits[i] == {owner, permit})";
"    task_local[\"permits\"] = listdelete(permits, i);";
"    set_task_local(task_local);";
"";
"    return permit;";
"  endif";
"endfor";
"";
"raise(E_INVARG, \"Invalid permit\");";
"";
"chunk_length:36";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:3D5960742E6BC6BF7D299D46EFD097C96A8CA37F";
"state:clean";
"updated_at:Fri Jan 11 11:34:32 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"{permit, ?owner = 0} = args;";
"";
"task_local = task_local();";
"caller_perms = caller_perms();";
"";
"if (owner != 0 && owner != caller_perms)";
"  if (!caller_perms.wizard)";
"    raise(E_PERM, \"Invalid owner\");";
"  elseif (typeof(owner) != OBJ || !valid(owner))";
"    raise(E_INVARG, \"Invalid owner\");";
"  endif";
"else";
"  owner = caller_perms;";
"endif";
"";
"if (!(`permits = task_local[\"permits\"] ! E_RANGE'))";
"  permits = {};";
"endif";
"";
"len = length(permits);";
"";
"for i in [1..len]";
"  if (permits[i] == {owner, permit})";
"    task_local[\"permits\"] = listdelete(permits, i);";
"    set_task_local(task_local);";
"";
"    return permit;";
"  endif";
"endfor";
"";
"raise(E_INVARG, \"Invalid permit\");";
"";
"chunk_length:31";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:AC90DFFD542B301ADE4A944453B2D8D5C8304D24";
"state:clean";
"updated_at:Sun Dec 23 08:28:39 2012 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#0:25
{permit, owner, ?subject = 0} = args;
task_local = task_local();
caller_perms = caller_perms();
for caller in (callers())
if (caller_perms != caller[3])
break;
endif
endfor
if (!valid(caller[3]))
raise(E_INVARG);
endif
caller_perms = caller[3];
if ((subject != 0) && (subject != caller_perms))
if (!caller_perms().wizard)
raise(E_PERM, "Invalid subject");
elseif ((typeof(subject) != OBJ) || (!valid(subject)))
raise(E_INVARG, "Invalid subject");
endif
else
subject = caller_perms;
endif
if (!`permits = task_local["permits"] ! E_RANGE')
return $failed_match;
endif
if (`valid(permit) ! E_TYPE')
for pair in (permits)
{o, p} = pair;
if (((o == owner) && `isa(p, permit) ! E_TYPE') && p:permit(permit, owner, subject))
return p;
endif
endfor
else
for pair in (permits)
if (pair == {owner, permit})
return permit;
endif
endfor
endif
return $failed_match;
return;
"/* This is called by a verb to determine whether or not to perform a";
" * risky operation on behalf of _its_ caller, the `subject'.  This";
" * verb finds the subject by walking the call stack, looking for the";
" * first verb running with permissions different from its immediate";
" * caller.  The `owner' may be the ultimate direct/indirect object of";
" * the action (in any event, it must be the object that granted the";
" * permit).";
" */";
"";
"{permit, owner, ?subject = 0} = args;";
"";
"task_local = task_local();";
"caller_perms = caller_perms();";
"";
"for caller in (callers())";
"  if (caller_perms != caller[3])";
"    break;";
"  endif";
"endfor";
"";
"if (!valid(caller[3]))";
"  raise(E_INVARG);";
"endif";
"";
"caller_perms = caller[3];";
"";
"if (subject != 0 && subject != caller_perms)";
"  if (!caller_perms().wizard) /* note! must check the immediate caller, here */";
"    raise(E_PERM, \"Invalid subject\");";
"  elseif (typeof(subject) != OBJ || !valid(subject))";
"    raise(E_INVARG, \"Invalid subject\");";
"  endif";
"else";
"  subject = caller_perms;";
"endif";
"";
"if (!(`permits = task_local[\"permits\"] ! E_RANGE'))";
"  return $failed_match;";
"endif";
"";
"if (`valid(permit) ! E_TYPE')";
"  for pair in (permits)";
"    {o, p} = pair;";
"    if (o == owner && `isa(p, permit) ! E_TYPE' && p:permit(permit, owner, subject))";
"      return p;";
"    endif";
"  endfor";
"else";
"  for pair in (permits)";
"    if (pair == {owner, permit})";
"      return permit;";
"    endif";
"  endfor";
"endif";
"";
"return $failed_match;";
"";
"chunk_length:56";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:E6A48E5A942EADA49DC00CB8A20C806A5DE59F5E";
"state:clean";
"updated_at:Fri Jan 11 12:05:57 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"/* This is called by a verb to determine whether or not to perform";
" * a risky operation on behalf of _its_ caller, the `subject'.  The";
" * `owner' may be the ultimate direct/indirect object of the action";
" * (it is, in any event, the object that granted the permit).";
" */";
"";
"{permit, owner, ?subject = 0} = args;";
"";
"task_local = task_local();";
"caller_perms = caller_perms();";
"";
"if (subject != 0 && subject != caller_perms)";
"  if (!caller_perms.wizard)";
"    raise(E_PERM, \"Invalid subject\");";
"  elseif (typeof(subject) != OBJ || !valid(subject))";
"    raise(E_INVARG, \"Invalid subject\");";
"  endif";
"else";
"  subject = caller_perms;";
"endif";
"";
"if (!(`permits = task_local[\"permits\"] ! E_RANGE'))";
"  return $failed_match;";
"endif";
"";
"if (`valid(permit) ! E_TYPE')";
"  for pair in (permits)";
"    {o, p} = pair;";
"    if (o == owner && `isa(p, permit) ! E_TYPE' && p:permit(permit, owner, subject))";
"      return p;";
"    endif";
"  endfor";
"else";
"  for pair in (permits)";
"    if (pair == {owner, permit})";
"      return permit;";
"    endif";
"  endfor";
"endif";
"";
"return $failed_match;";
"";
"chunk_length:41";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:0BAAB87EFA7292B6D7F7F8502464A8B0AA259CDC";
"state:clean";
"updated_at:Sun Dec 23 10:24:11 2012 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#3:0
{code, message, value, traceback, formatted} = args;
callers() && raise(E_PERM, "Server task");
for line in (formatted)
server_log(line);
endfor
.
#3:1
{resource, traceback, formatted} = args;
callers() && raise(E_PERM, "Server task");
for line in (formatted)
server_log(line);
endfor
.
#3:2
$restrict_to_caller($system, "server_started");
$epoch = $epoch + 1;
$last_login_connection = #-1;
if (!$disable_passkey_login)
server_log(tostr("WARNING: Log-in via passkey is enabled for the following players (specified in $passkey_players):"));
for player in ($passkey_players)
server_log(tostr("WARNING:   \"", player.name, "\" (", player, ")"));
endfor
server_log("WARNING: This is a severe security vulnerability.  In a secure environment you should:");
server_log("WARNING:   disable passkey login:");
server_log("WARNING:     ; $disable_passkey_login = 1");
server_log("WARNING:     ; $passkey_players = {}");
server_log("WARNING:   disable existing passkeys:");
for player in ($passkey_players)
server_log(tostr("WARNING:     ; ", player, ".passkey = 0"));
endfor
server_log("WARNING:   and for good measure:");
for player in ($passkey_players)
server_log(tostr("WARNING:     ; set_player_flag(", player, ", 0)"));
endfor
i = random(100000) + 100000;
for player in ($passkey_players)
passkey = string_hash((tostr(random()) + ctime(time())) + player.name);
while (i)
((!(i % 100)) && ((ticks_left() < 2000) || (seconds_left() < 2))) && suspend(0);
passkey = string_hash(passkey);
i = i - 1;
endwhile
server_log(tostr("PASSKEY for \"", player.name, "\" (", player, ("): " + passkey) + " (keep it secret)"));
player.passkey = passkey;
endfor
endif
return;
"$restrict_to_caller($system, \"server_started\");";
"";
"$epoch = $epoch + 1;";
"$last_login_connection = #-1;";
"";
"if (!$disable_passkey_login)";
"  /* generate passkeys for passkey players */";
"  server_log(tostr(\"WARNING: Log-in via passkey is enabled for the following players (specified in $passkey_players):\"));";
"  for player in ($passkey_players)";
"    server_log(tostr(\"WARNING:   \\\"\", player.name, \"\\\" (\", player, \")\"));";
"  endfor";
"  server_log(\"WARNING: This is a severe security vulnerability.  In a secure environment you should:\");";
"  server_log(\"WARNING:   disable passkey login:\");";
"  server_log(\"WARNING:     ; $disable_passkey_login = 1\");";
"  server_log(\"WARNING:     ; $passkey_players = {}\");";
"  server_log(\"WARNING:   disable existing passkeys:\");";
"  for player in ($passkey_players)";
"    server_log(tostr(\"WARNING:     ; \", player, \".passkey = 0\"));";
"  endfor";
"  server_log(\"WARNING:   and for good measure:\");";
"  for player in ($passkey_players)";
"    server_log(tostr(\"WARNING:     ; set_player_flag(\", player, \", 0)\"));";
"  endfor";
"  i = random(100000) + 100000;";
"  for player in ($passkey_players)";
"    passkey = string_hash(tostr(random()) + ctime(time()) + player.name);";
"    while (i)";
"      !(i % 100) && (ticks_left() < 2000 || seconds_left() < 2) && suspend(0);";
"      passkey = string_hash(passkey);";
"      i = i - 1;";
"    endwhile";
"    server_log(tostr(\"PASSKEY for \\\"\", player.name, \"\\\" (\", player, \"): \" + passkey + \" (keep it secret)\"));";
"    player.passkey = passkey;";
"  endfor";
"endif";
"";
"chunk_length:35";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:76032147C6B0D02D04E80E06D221306A61083DF4";
"state:clean";
"updated_at:Mon Jan 21 11:22:33 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#3:3
$restrict_to_caller($system, "authenticate");
if (length(args) == 1)
{passkey} = args;
if (!$disable_passkey_login)
for player in ($passkey_players)
if (length(passkey) == length(player.passkey))
count = 0;
for i in [1..length(passkey)]
count = ((passkey[i] == player.passkey[i]) ? 1 | 0) + count;
endfor
if (length(passkey) == count)
return player;
endif
endif
endfor
endif
endif
return $failed_match;
.
#5:0
if (player != this)
notify(player, "I couldn't understand that.");
return;
endif
if (!player.wizard)
notify(player, "You must be a wizard to do that!");
return;
endif
if (length($composed.packages) > 1)
notify(player, "You have non-kernel packages installed.");
return;
endif
notify(player, "Bye!");
boot_player(player);
for task in (queued_tasks())
kill_task(task[1]);
endfor
$epoch = 0;
$last_login_connection = 0;
$external_compilers = [];
$disable_passkey_login = 0;
#5.passkey = 0;
#6.passkey = 0;
$composed.archive_sources = {"http://stunt.io/v2/packages.json"};
$composed.last_fetch_index = 0;
$composed.archived = [];
$composed.cached = [];
chparents(#0, {#3});
chparents(#5, {});
chparents(#6, {});
package = $composed:export(#2);
json = generate_json(package, "embedded-types");
while (len = length(json))
len = (len > 60000) ? 60000 | len;
line = json[1..len];
json[1..len] = "";
server_log(line);
endwhile
reset_max_object();
shutdown();
return;
"if (player != this)";
"  notify(player, \"I couldn't understand that.\");";
"  return;";
"endif";
"if (!player.wizard)";
"  notify(player, \"You must be a wizard to do that!\");";
"  return;";
"endif";
"";
"if (length($composed.packages) > 1)";
"  notify(player, \"You have non-kernel packages installed.\");";
"  return;";
"endif";
"";
"notify(player, \"Bye!\");";
"boot_player(player);";
"";
"for task in (queued_tasks())";
"  kill_task(task[1]);";
"endfor";
"";
"#0.epoch = 0;";
"#0.last_login_connection = 0;";
"#0.external_compilers = [];";
"";
"#0.disable_passkey_login = 0;";
"#5.passkey = 0;";
"#6.passkey = 0;";
"";
"$composed.archive_sources = {\"http://stunt.io/v2/packages.json\"};";
"$composed.last_fetch_index = 0;";
"$composed.archived = [];";
"$composed.cached = [];";
"";
"chparents(#0, {#3});";
"chparents(#5, {});";
"chparents(#6, {});";
"";
"package = $composed:export(#2);";
"json = generate_json(package, \"embedded-types\");";
"while (len = length(json))";
"  len = len > 60000 ? 60000 | len;";
"  line = json[1..len];";
"  json[1..len] = \"\";";
"  server_log(line);";
"endwhile";
"";
"reset_max_object();";
"shutdown();";
"";
"chunk_length:49";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:6";
"sha1:B3F69B65640E578B1EEC70EB7FBA43C4CA0BBCFC";
"state:clean";
"updated_at:Sat Feb  9 18:02:32 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"if (player != this)";
"  notify(player, \"I couldn't understand that.\");";
"  return;";
"endif";
"if (!player.wizard)";
"  notify(player, \"You must be a wizard to do that!\");";
"  return;";
"endif";
"";
"if (length($composed.packages) > 1)";
"  notify(player, \"You have non-kernel packages installed.\");";
"  return;";
"endif";
"";
"notify(player, \"Bye!\");";
"boot_player(player);";
"";
"for task in (queued_tasks())";
"  kill_task(task[1]);";
"endfor";
"";
"#0.epoch = 0;";
"#0.last_login_connection = 0;";
"#0.external_compilers = [];";
"";
"#0.disable_passkey_login = 0;";
"#5.passkey = 0;";
"#6.passkey = 0;";
"";
"$composed.archive_sources = {\"http://stunt.io/v1/packages.json\"};";
"$composed.last_fetch_index = 0;";
"$composed.archived = [];";
"$composed.cached = [];";
"";
"chparents(#0, {#3});";
"chparents(#5, {});";
"chparents(#6, {});";
"";
"package = $composed:export(#2);";
"json = generate_json(package, \"embedded-types\");";
"while (len = length(json))";
"  len = len > 60000 ? 60000 | len;";
"  line = json[1..len];";
"  json[1..len] = \"\";";
"  server_log(line);";
"endwhile";
"";
"reset_max_object();";
"shutdown();";
"";
"chunk_length:49";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:5";
"sha1:489FC4EEF6CEF117D4A65F93E24E695E0FF65576";
"state:clean";
"updated_at:Mon Jan 21 11:25:52 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"if (player != this)";
"  notify(player, \"I couldn't understand that.\");";
"  return;";
"endif";
"if (!player.wizard)";
"  notify(player, \"You must be a wizard to do that!\");";
"  return;";
"endif";
"";
"if (length($composed.packages) > 1)";
"  notify(player, \"You have non-kernel packages installed.\");";
"  return;";
"endif";
"";
"notify(player, \"Bye!\");";
"boot_player(player);";
"";
"for task in (queued_tasks())";
"  kill_task(task[1]);";
"endfor";
"";
"#0.external_compilers = [];";
"#0.last_login_connection = 0;";
"";
"#0.disable_passkey_login = 0;";
"#5.passkey = 0;";
"#6.passkey = 0;";
"";
"$composed.archive_sources = {\"http://stunt.io/v1/packages.json\"};";
"$composed.last_fetch_index = 0;";
"$composed.archived = [];";
"$composed.cached = [];";
"";
"chparents(#0, {#3});";
"chparents(#5, {});";
"chparents(#6, {});";
"";
"package = $composed:export(#2);";
"json = generate_json(package, \"embedded-types\");";
"while (len = length(json))";
"  len = len > 60000 ? 60000 | len;";
"  line = json[1..len];";
"  json[1..len] = \"\";";
"  server_log(line);";
"endwhile";
"";
"reset_max_object();";
"shutdown();";
"";
"chunk_length:48";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:4";
"sha1:24858A40145E8F44425C8F63490A3DFD22BFC654";
"state:clean";
"updated_at:Sat Jan 12 09:08:33 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"if (player != this)";
"  notify(player, \"I couldn't understand that.\");";
"  return;";
"endif";
"if (!player.wizard)";
"  notify(player, \"You must be a wizard to do that!\");";
"  return;";
"endif";
"";
"if (length($composed.packages) > 1)";
"  notify(player, \"You have non-kernel packages installed.\");";
"  return;";
"endif";
"";
"notify(player, \"Bye!\");";
"boot_player(player);";
"";
"for task in (queued_tasks())";
"  kill_task(task[1]);";
"endfor";
"";
"#0.external_compilers = [];";
"#0.last_login_connection = 0;";
"";
"#0.disable_passkey_login = 0;";
"#5.passkey = 0;";
"#6.passkey = 0;";
"";
"$composed.archive_sources = \"http://stunt.io/v1/packages.json\";";
"$composed.last_fetch_index = 0;";
"$composed.archived = [];";
"$composed.cached = [];";
"";
"chparents(#0, {#3});";
"chparents(#5, {});";
"chparents(#6, {});";
"";
"package = $composed:export(#2);";
"json = generate_json(package, \"embedded-types\");";
"while (len = length(json))";
"  len = len > 60000 ? 60000 | len;";
"  line = json[1..len];";
"  json[1..len] = \"\";";
"  server_log(line);";
"endwhile";
"";
"reset_max_object();";
"shutdown();";
"";
"chunk_length:48";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:3";
"sha1:2DA1B917545D856B86527743D67B9D47CEEA3A33";
"state:clean";
"updated_at:Sat Jan  5 15:01:55 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"if (player != this)";
"  notify(player, \"I couldn't understand that.\");";
"  return;";
"endif";
"if (!player.wizard)";
"  notify(player, \"You must be a wizard to do that!\");";
"  return;";
"endif";
"";
"if (length($composed.packages) > 1)";
"  notify(player, \"You have non-kernel packages installed.\");";
"  return;";
"endif";
"";
"notify(player, \"Bye!\");";
"boot_player(player);";
"";
"for task in (queued_tasks())";
"  kill_task(task[1]);";
"endfor";
"";
"#0.external_compilers = [];";
"#0.last_login_connection = 0;";
"";
"#0.disable_passkey_login = 0;";
"#5.passkey = 0;";
"#6.passkey = 0;";
"";
"$composed.last_fetch_index = 0;";
"$composed.archived = [];";
"$composed.cached = [];";
"$composed.archive_host = \"stunt.io\";";
"$composed.archive_port = 80;";
"$composed.archive_base_uri = \"/v1\";";
"";
"chparents(#0, {#3});";
"chparents(#5, {});";
"chparents(#6, {});";
"";
"package = $composed:export(#2);";
"json = generate_json(package, \"embedded-types\");";
"while (len = length(json))";
"  len = len > 60000 ? 60000 | len;";
"  line = json[1..len];";
"  json[1..len] = \"\";";
"  server_log(line);";
"endwhile";
"";
"reset_max_object();";
"shutdown();";
"";
"chunk_length:50";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:5C95C676E18ED894FEA3815168B45C61A676C384";
"state:clean";
"updated_at:Fri Jun 15 08:16:15 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"if (player != this)";
"  notify(player, \"I couldn't understand that.\");";
"  return;";
"endif";
"if (!player.wizard)";
"  notify(player, \"You must be a wizard to do that!\");";
"  return;";
"endif";
"";
"notify(player, \"Bye!\");";
"boot_player(player);";
"";
"for task in (queued_tasks())";
"  kill_task(task[1]);";
"endfor";
"";
"#0.external_compilers = [];";
"#0.last_login_connection = 0;";
"";
"#0.disable_passkey_login = 0;";
"#5.passkey = 0;";
"#6.passkey = 0;";
"";
"$composed.last_fetch_index = 0;";
"$composed.archived = [];";
"$composed.cached = [];";
"$composed.archive_host = \"stunt.io\";";
"$composed.archive_port = 80;";
"$composed.archive_base_uri = \"/v1\";";
"";
"chparents(#0, {#3});";
"chparents(#5, {});";
"chparents(#6, {});";
"";
"package = $composed:export(#2);";
"json = generate_json(package, \"embedded-types\");";
"while (len = length(json))";
"  len = len > 60000 ? 60000 | len;";
"  line = json[1..len];";
"  json[1..len] = \"\";";
"  server_log(line);";
"endwhile";
"";
"reset_max_object();";
"shutdown();";
"";
"chunk_length:45";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:5F2772CC24EF8919388024B96775CCE52D7FE6D0";
"state:clean";
"updated_at:Thu Jun 14 07:35:02 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#5:1
callers() && raise(E_PERM, "Server task");
set_task_perms(player);
"very simple, really primitive matching";
if (((prepstr == "with") && (iobjstr == "$composed")) && `valid($composed) ! ANY')
if ((verb in {"@install", "@uninstall", "@list"}) && `respond_to($composed, verb) ! ANY')
return $composed:(verb)(@args);
endif
endif
notify(player, "I couldn't understand that.");
.
#7:0
if (player.location != this)
notify(player, "I couldn't understand that.");
return;
elseif (!player.programmer)
notify(player, "You need to be a programmer to evaluate code.");
return;
endif
set_task_perms(player);
if (!(args[1] in {";", "if", "for", "while", "fork", "return"}))
notify(player, toliteral(eval(("return " + argstr) + ";")[2]));
else
notify(player, toliteral(eval(argstr + ";")[2]));
endif
.
#8:0
$private();
notify(player, tostr(@args));
return;
"$private();";
"notify(player, tostr(@args));";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:4D3218AE4E5E033F8DEBE454635C738FD9A8FC0A";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:1
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
return;
"/* intentionally not $private() */";
"(ticks_left() < 10000 || seconds_left() < 2) && suspend(0);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:2C1EA11D12899B2BA0E13071EB96FB49B19F22AE";
"state:clean";
"updated_at:Fri Jun  8 06:28:02 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:2
{who, what} = args;
return (who == what.owner) || who.wizard;
return;
"{who, what} = args;";
"return who == what.owner || who.wizard;";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:9DD4270A2909D7E9B7ACF51318A725A3B6018DAE";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:3
{who, what, name} = args;
$private();
return (who == verb_info(what, name)[1]) || who.wizard;
return;
"{who, what, name} = args;";
"$private();";
"return who == verb_info(what, name)[1] || who.wizard;";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:1CD475E09642CB93FFE212FC6EBC0D3AE8C6FC0A";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:4
{who, what, name} = args;
$private();
return (who == property_info(what, name)[1]) || who.wizard;
return;
"{who, what, name} = args;";
"$private();";
"return who == property_info(what, name)[1] || who.wizard;";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:E2A6A9525DE1893AB0B8744CC406118FABF8A208";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:5
args && raise(E_ARGS);
set_task_perms(caller_perms());
r = [];
r["Objects"] = {};
return r;
return;
"args && raise(E_ARGS);";
"set_task_perms(caller_perms());";
"r = [];";
"r[\"Objects\"] = {};";
"return r;";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:2A97664DD035B6AD7F03BA1868859F92532B37D5";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:6
{o, ?options = []} = args;
((ticks_left() < 2000) || (seconds_left() < 2)) && suspend(0);
if (`valid(o) ! E_TYPE')
pcount = length(properties(o));
vcount = length(verbs(o));
set_task_perms(caller_perms());
r = ["Attributes" -> []];
v = parents(o);
m = ["id" -> "parents"];
m["status"] = this:_controls(caller_perms(), o) ? "writable" | "readable";
r["Attributes"]["parents"] = ["Meta" -> m, "Value" -> ["value" -> v]];
if (typeof(o) == OBJ)
v = is_player(o);
m = ["id" -> "player"];
m["status"] = `caller_perms().wizard ! E_INVIND' ? "writable" | "readable";
r["Attributes"]["player"] = ["Meta" -> m, "Value" -> ["value" -> v]];
endif
r["Values"] = [];
for a in (this:_values(o))
this:_suspend_if_necessary();
r["Values"][a] = this:read_value(o, a, options);
endfor
r["Properties"] = {};
for p in [1..pcount]
this:_suspend_if_necessary();
r["Properties"] = {@r["Properties"], this:read_property(o, p)};
endfor
r["Verbs"] = {};
for v in [1..vcount]
this:_suspend_if_necessary();
r["Verbs"] = {@r["Verbs"], this:read_verb(o, v)};
endfor
if (p = o.w || this:_controls(caller_perms(), o))
status = "writable";
elseif (o.r)
status = "readable";
else
status = "";
endif
if (typeof(o) == OBJ)
r["Meta"] = ["id" -> toint(o), "status" -> status];
else
r["Meta"] = ["status" -> status];
endif
return r;
else
if (typeof(o) == OBJ)
r = ["Meta" -> ["id" -> toint(o), "status" -> "invalid"]];
else
r = ["Meta" -> ["status" -> "invalid"]];
endif
return r;
endif
return;
"{o, ?options = []} = args;";
"";
"ticks_left() < 2000 || seconds_left() < 2 && suspend(0);";
"";
"if (`valid(o) ! E_TYPE')";
"";
"  /* inform ourselves about basic object structure before losing perms */";
"  pcount = length(properties(o));";
"  vcount = length(verbs(o));";
"";
"  set_task_perms(caller_perms());";
"";
"  r = [\"Attributes\" -> []];";
"  v = parents(o);";
"  m = [\"id\" -> \"parents\"];";
"  m[\"status\"] = this:_controls(caller_perms(), o) ? \"writable\" | \"readable\";";
"  r[\"Attributes\"][\"parents\"] = [\"Meta\" -> m, \"Value\" -> [\"value\" -> v]];";
"";
"  if (typeof(o) == OBJ)";
"    v = is_player(o);";
"    m = [\"id\" -> \"player\"];";
"    m[\"status\"] = `caller_perms().wizard ! E_INVIND' ? \"writable\" | \"readable\";";
"    r[\"Attributes\"][\"player\"] = [\"Meta\" -> m, \"Value\" -> [\"value\" -> v]];";
"  endif";
"";
"  r[\"Values\"] = [];";
"  for a in (this:_values(o))";
"    this:_suspend_if_necessary();";
"    r[\"Values\"][a] = this:read_value(o, a, options);";
"  endfor";
"";
"  r[\"Properties\"] = {};";
"  for p in [1..pcount]";
"    this:_suspend_if_necessary();";
"    r[\"Properties\"] = {@r[\"Properties\"], this:read_property(o, p)};";
"  endfor";
"";
"  r[\"Verbs\"] = {};";
"  for v in [1..vcount]";
"    this:_suspend_if_necessary();";
"    r[\"Verbs\"] = {@r[\"Verbs\"], this:read_verb(o, v)};";
"  endfor";
"";
"  if (p = o.w || this:_controls(caller_perms(), o))";
"    status = \"writable\";";
"  elseif (o.r)";
"    status = \"readable\";";
"  else";
"    status = \"\";";
"  endif";
"";
"  if (typeof(o) == OBJ)";
"    r[\"Meta\"] = [\"id\" -> toint(o), \"status\" -> status];";
"  else";
"    r[\"Meta\"] = [\"status\" -> status];";
"  endif";
"  return r;";
"else";
"  if (typeof(o) == OBJ)";
"    r = [\"Meta\" -> [\"id\" -> toint(o), \"status\" -> \"invalid\"]];";
"  else";
"    r = [\"Meta\" -> [\"status\" -> \"invalid\"]];";
"  endif";
"  return r;";
"endif";
"";
"chunk_length:65";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:3";
"sha1:C88F2C4D74D53093007C94FE472E800669BE0AE6";
"state:clean";
"updated_at:Wed Jan  2 08:06:01 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"{o, ?options = []} = args;";
"";
"ticks_left() < 2000 || seconds_left() < 2 && suspend(0);";
"";
"if (`valid(o) ! E_TYPE => 0')";
"";
"  /* inform ourselves about basic object structure before losing perms */";
"  pcount = length(properties(o));";
"  vcount = length(verbs(o));";
"";
"  set_task_perms(caller_perms());";
"";
"  r = [\"Attributes\" -> []];";
"  v = parents(o);";
"  m = [\"id\" -> \"parents\"];";
"  m[\"status\"] = this:_controls(caller_perms(), o) ? \"writable\" | \"readable\";";
"  r[\"Attributes\"][\"parents\"] = [\"Meta\" -> m, \"Value\" -> [\"value\" -> v]];";
"";
"  if (typeof(o) == OBJ)";
"    v = is_player(o);";
"    m = [\"id\" -> \"player\"];";
"    m[\"status\"] = `caller_perms().wizard ! E_INVIND' ? \"writable\" | \"readable\";";
"    r[\"Attributes\"][\"player\"] = [\"Meta\" -> m, \"Value\" -> [\"value\" -> v]];";
"  endif";
"";
"  r[\"Values\"] = [];";
"  for a in (this:_values(o))";
"    this:_suspend_if_necessary();";
"    r[\"Values\"][a] = this:read_value(o, a);";
"  endfor";
"";
"  r[\"Properties\"] = {};";
"  for p in [1..pcount]";
"    this:_suspend_if_necessary();";
"    r[\"Properties\"] = {@r[\"Properties\"], this:read_property(o, p)};";
"  endfor";
"";
"  r[\"Verbs\"] = {};";
"  for v in [1..vcount]";
"    this:_suspend_if_necessary();";
"    r[\"Verbs\"] = {@r[\"Verbs\"], this:read_verb(o, v)};";
"  endfor";
"";
"  if (p = o.w || this:_controls(caller_perms(), o))";
"    status = \"writable\";";
"  elseif (o.r)";
"    status = \"readable\";";
"  else";
"    status = \"\";";
"  endif";
"";
"  if (typeof(o) == OBJ)";
"    r[\"Meta\"] = [\"id\" -> toint(o), \"status\" -> status];";
"  else";
"    r[\"Meta\"] = [\"status\" -> status];";
"  endif";
"  return r;";
"else";
"  if (typeof(o) == OBJ)";
"    r = [\"Meta\" -> [\"id\" -> toint(o), \"status\" -> \"invalid\"]];";
"  else";
"    r = [\"Meta\" -> [\"status\" -> \"invalid\"]];";
"  endif";
"  return r;";
"endif";
"";
"chunk_length:65";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:8A4A335C584F22C1E1AEB02ABAFDD64FDF8E0A75";
"state:clean";
"updated_at:Wed Dec 26 08:48:37 2012 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"{o, ?options = []} = args;";
"";
"ticks_left() < 2000 || seconds_left() < 2 && suspend(0);";
"";
"if (`valid(o) ! E_TYPE => 0')";
"";
"  /* inform ourselves about basic object structure before losing perms */";
"  pcount = length(properties(o));";
"  vcount = length(verbs(o));";
"";
"  set_task_perms(caller_perms());";
"";
"  r = [\"Attributes\" -> []];";
"  v = parents(o);";
"  m = [\"id\" -> \"parents\"];";
"  m[\"status\"] = this:_controls(caller_perms(), o) ? \"writable\" | \"readable\";";
"  r[\"Attributes\"][\"parents\"] = [\"Meta\" -> m, \"Value\" -> [\"value\" -> v]];";
"";
"  v = is_player(o);";
"  m = [\"id\" -> \"player\"];";
"  m[\"status\"] = `caller_perms().wizard ! E_INVIND' ? \"writable\" | \"readable\";";
"  r[\"Attributes\"][\"player\"] = [\"Meta\" -> m, \"Value\" -> [\"value\" -> v]];";
"";
"  r[\"Values\"] = [];";
"  for a in (this:_values(o))";
"    this:_suspend_if_necessary();";
"    r[\"Values\"][a] = this:read_value(o, a);";
"  endfor";
"";
"  r[\"Properties\"] = {};";
"  for p in [1..pcount]";
"    this:_suspend_if_necessary();";
"    r[\"Properties\"] = {@r[\"Properties\"], this:read_property(o, p)};";
"  endfor";
"";
"  r[\"Verbs\"] = {};";
"  for v in [1..vcount]";
"    this:_suspend_if_necessary();";
"    r[\"Verbs\"] = {@r[\"Verbs\"], this:read_verb(o, v)};";
"  endfor";
"";
"  if (p = o.w || this:_controls(caller_perms(), o))";
"    status = \"writable\";";
"  elseif (o.r)";
"    status = \"readable\";";
"  else";
"    status = \"\";";
"  endif";
"";
"  r[\"Meta\"] = [\"id\" -> toint(o), \"status\" -> status];";
"  return r;";
"else";
"  r = [\"Meta\" -> [\"id\" -> toint(o), \"status\" -> \"invalid\"]];";
"  return r;";
"endif";
"";
"chunk_length:55";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:7E46C2270B6829A9A4C363E630847151A5F1D518";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:7
{o, r, ?options = []} = args;
((ticks_left() < 2000) || (seconds_left() < 2)) && suspend(0);
if (`valid(o) ! E_TYPE')
properties = properties(o);
verbs = verbs(o);
set_task_perms(caller_perms());
try
r["Attributes"];
r["Values"];
r["Properties"];
r["Verbs"];
errors = 0;
parents = `r["Attributes"]["parents"]["Value"]["value"] ! E_RANGE => parents(o)';
if (parents(o) != parents)
x = this:_write_parents(o, ["Value" -> ["value" -> {}]]);
errors = errors + ("Error" in mapkeys(x));
endif
location = `r["Values"]["location"]["Value"]["value"] ! E_RANGE => o.location';
if (o.location != location)
x = this:write_value(o, "location", ["Value" -> ["value" -> $nothing]]);
errors = errors + ("Error" in mapkeys(x));
endif
owner = `r["Values"]["owner"]["Value"]["value"] ! E_RANGE => o.owner';
if ("owner" in mapkeys(r["Values"]))
r["Values"]["owner"] = this:write_value(o, "owner", r["Values"]["owner"]);
errors = errors + ("Error" in mapkeys(r["Values"]["owner"]));
endif
if ("parents" in mapkeys(r["Attributes"]))
r["Attributes"]["parents"] = this:_write_parents(o, r["Attributes"]["parents"]);
errors = errors + ("Error" in mapkeys(r["Attributes"]["parents"]));
endif
if ("player" in mapkeys(r["Attributes"]))
r["Attributes"]["player"] = this:_write_player(o, r["Attributes"]["player"]);
errors = errors + ("Error" in mapkeys(r["Attributes"]["player"]));
endif
if ("location" in mapkeys(r["Values"]))
r["Values"]["location"] = this:write_value(o, "location", r["Values"]["location"]);
errors = errors + ("Error" in mapkeys(r["Values"]["location"]));
endif
if ((lp1 = length(properties)) < (lp2 = length(r["Properties"])))
for p in [lp1 + 1..lp2]
this:_suspend_if_necessary();
`add_property(o, tostr("___", p, "___"), 0, {owner, ""}) ! E_PERM';
endfor
else
for p in [lp2 + 1..lp1]
this:_suspend_if_necessary();
delete_property(o, properties[p]);
endfor
endif
if ((lv1 = length(verbs)) < (lv2 = length(r["Verbs"])))
for v in [lv1 + 1..lv2]
this:_suspend_if_necessary();
`add_verb(o, {owner, "", tostr("___", v, "___")}, {"this", "none", "this"}) ! E_PERM';
endfor
else
for v in [lv2 + 1..lv1]
this:_suspend_if_necessary();
delete_verb(o, lv2 + 1);
endfor
endif
for p in [1..length(r["Properties"])]
this:_suspend_if_necessary();
r["Properties"][p] = this:write_property(o, p, r["Properties"][p]);
if ("Error" in mapkeys(r["Properties"][p]))
if ((lp1 < lp2) && (r["Properties"][p]["Error"]["diagnostic"] == "property is invalid"))
r["Properties"][p]["Error"]["diagnostic"] = "permission denied";
endif
errors = errors + 1;
endif
endfor
for v in [1..length(r["Verbs"])]
this:_suspend_if_necessary();
r["Verbs"][v] = this:write_verb(o, v, r["Verbs"][v], `options["verbs"] ! E_RANGE => []');
if ("Error" in mapkeys(r["Verbs"][v]))
if ((lv1 < lv2) && (r["Verbs"][v]["Error"]["diagnostic"] == "verb is invalid"))
r["Verbs"][v]["Error"]["diagnostic"] = "permission denied";
endif
errors = errors + 1;
endif
endfor
values = setremove(setremove(mapkeys(r["Values"]), "location"), "owner");
for a in (values)
this:_suspend_if_necessary();
r["Values"][a] = this:write_value(o, a, r["Values"][a], options);
errors = errors + ("Error" in mapkeys(r["Values"][a]));
endfor
if (errors < 1)
r = this:read_object(o);
else
r["Meta"] = ["id" -> toint(o), "status" -> "unknown"];
r["Error"] = ["diagnostic" -> "errors in sub-operations"];
endif
return r;
except (E_RANGE, E_TYPE)
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
except (E_PERM)
r["Error"] = ["diagnostic" -> "permission denied"];
return r;
endtry
else
r["Error"] = ["diagnostic" -> "object reference is invalid"];
return r;
endif
return;
"{o, r, ?options = []} = args;";
"";
"ticks_left() < 2000 || seconds_left() < 2 && suspend(0);";
"";
"if (`valid(o) ! E_TYPE')";
"";
"  /* inform ourselves about basic object structure before losing perms */";
"  properties = properties(o);";
"  verbs = verbs(o);";
"";
"  set_task_perms(caller_perms());";
"";
"  try";
"    /* get basic message format checks out of the way */";
"    r[\"Attributes\"];";
"    r[\"Values\"];";
"    r[\"Properties\"];";
"    r[\"Verbs\"];";
"";
"    errors = 0;";
"";
"    /* Before doing anything else, reset the object to a known";
"     * state. If the parents are going to change, set the parents";
"     * to an empty list; if the location is going to change, move";
"     * the object to $nothing.";
"     */";
"";
"    parents = `r[\"Attributes\"][\"parents\"][\"Value\"][\"value\"] ! E_RANGE => parents(o)';";
"";
"    if (parents(o) != parents)";
"      x = this:_write_parents(o, [\"Value\" -> [\"value\" -> {}]]);";
"      errors = errors + (\"Error\" in mapkeys(x));";
"    endif";
"";
"    location = `r[\"Values\"][\"location\"][\"Value\"][\"value\"] ! E_RANGE => o.location';";
"";
"    if (o.location != location)";
"      x = this:write_value(o, \"location\", [\"Value\" -> [\"value\" -> $nothing]]);";
"      errors = errors + (\"Error\" in mapkeys(x));";
"    endif";
"";
"    owner = `r[\"Values\"][\"owner\"][\"Value\"][\"value\"] ! E_RANGE => o.owner';";
"";
"    /* Do the owner, parents, player and location values first, in that";
"     * order.  Then properties and verbs.  Then the rest of the";
"     * values.";
"     */";
"";
"    if (\"owner\" in mapkeys(r[\"Values\"]))";
"      r[\"Values\"][\"owner\"] = this:write_value(o, \"owner\", r[\"Values\"][\"owner\"]);";
"      errors = errors + (\"Error\" in mapkeys(r[\"Values\"][\"owner\"]));";
"    endif";
"";
"    if (\"parents\" in mapkeys(r[\"Attributes\"]))";
"      r[\"Attributes\"][\"parents\"] = this:_write_parents(o, r[\"Attributes\"][\"parents\"]);";
"      errors = errors + (\"Error\" in mapkeys(r[\"Attributes\"][\"parents\"]));";
"    endif";
"";
"    if (\"player\" in mapkeys(r[\"Attributes\"]))";
"      r[\"Attributes\"][\"player\"] = this:_write_player(o, r[\"Attributes\"][\"player\"]);";
"      errors = errors + (\"Error\" in mapkeys(r[\"Attributes\"][\"player\"]));";
"    endif";
"";
"    if (\"location\" in mapkeys(r[\"Values\"]))";
"      r[\"Values\"][\"location\"] = this:write_value(o, \"location\", r[\"Values\"][\"location\"]);";
"      errors = errors + (\"Error\" in mapkeys(r[\"Values\"][\"location\"]));";
"    endif";
"";
"    if ((lp1 = length(properties)) < (lp2 = length(r[\"Properties\"])))";
"      for p in [lp1 + 1..lp2]";
"        this:_suspend_if_necessary();";
"        `add_property(o, tostr(\"___\", p, \"___\"), 0, {owner, \"\"}) ! E_PERM';";
"      endfor";
"    else";
"      for p in [lp2 + 1..lp1]";
"        this:_suspend_if_necessary();";
"        delete_property(o, properties[p]);";
"      endfor";
"    endif";
"";
"    if ((lv1 = length(verbs)) < (lv2 = length(r[\"Verbs\"])))";
"      for v in [lv1 + 1..lv2]";
"        this:_suspend_if_necessary();";
"        `add_verb(o, {owner, \"\", tostr(\"___\", v, \"___\")}, {\"this\", \"none\", \"this\"}) ! E_PERM';";
"      endfor";
"    else";
"      for v in [lv2 + 1..lv1]";
"        this:_suspend_if_necessary();";
"        delete_verb(o, lv2 + 1);";
"      endfor";
"    endif";
"";
"    for p in [1..length(r[\"Properties\"])]";
"      this:_suspend_if_necessary();";
"      r[\"Properties\"][p] = this:write_property(o, p, r[\"Properties\"][p]);";
"      if (\"Error\" in mapkeys(r[\"Properties\"][p]))";
"        if (lp1 < lp2 && r[\"Properties\"][p][\"Error\"][\"diagnostic\"] == \"property is invalid\")";
"          /* if we had to add properties but the property does not actually exist it should have been... */";
"          r[\"Properties\"][p][\"Error\"][\"diagnostic\"] = \"permission denied\";";
"        endif";
"        errors = errors + 1;";
"      endif";
"    endfor";
"";
"    for v in [1..length(r[\"Verbs\"])]";
"      this:_suspend_if_necessary();";
"      r[\"Verbs\"][v] = this:write_verb(o, v, r[\"Verbs\"][v], `options[\"verbs\"] ! E_RANGE => []');";
"      if (\"Error\" in mapkeys(r[\"Verbs\"][v]))";
"        if (lv1 < lv2 && r[\"Verbs\"][v][\"Error\"][\"diagnostic\"] == \"verb is invalid\")";
"          /* if we had to add verbs but the verb does not actually exist it should have been... */";
"          r[\"Verbs\"][v][\"Error\"][\"diagnostic\"] = \"permission denied\";";
"        endif";
"        errors = errors + 1;";
"      endif";
"    endfor";
"";
"    /* do the rest of the values */";
"";
"    values = setremove(setremove(mapkeys(r[\"Values\"]), \"location\"), \"owner\");";
"";
"    for a in (values)";
"      this:_suspend_if_necessary();";
"      r[\"Values\"][a] = this:write_value(o, a, r[\"Values\"][a], options);";
"      errors = errors + (\"Error\" in mapkeys(r[\"Values\"][a]));";
"    endfor";
"";
"    if (errors < 1)";
"      r = this:read_object(o);";
"    else";
"      r[\"Meta\"] = [\"id\" -> toint(o), \"status\" -> \"unknown\"];";
"      r[\"Error\"] = [\"diagnostic\" -> \"errors in sub-operations\"];";
"    endif";
"";
"    return r;";
"";
"  except (E_RANGE, E_TYPE)";
"    r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];";
"    return r;";
"  except (E_PERM)";
"    r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];";
"    return r;";
"  endtry";
"else";
"  r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];";
"  return r;";
"endif";
"";
"chunk_length:146";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:3A4250A3A30EF80C0F2FC484261153890A9BB810";
"state:clean";
"updated_at:Wed Jan  2 08:06:26 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"{o, r, ?options = []} = args;";
"";
"ticks_left() < 2000 || seconds_left() < 2 && suspend(0);";
"";
"if (`valid(o) ! E_TYPE => 0')";
"";
"  /* inform ourselves about basic object structure before losing perms */";
"  properties = properties(o);";
"  verbs = verbs(o);";
"";
"  set_task_perms(caller_perms());";
"";
"  try";
"    /* get basic message format checks out of the way */";
"    r[\"Attributes\"];";
"    r[\"Values\"];";
"    r[\"Properties\"];";
"    r[\"Verbs\"];";
"";
"    errors = 0;";
"";
"    /* Before doing anything else, reset the object to a known";
"     * state. If the parents are going to change, set the parents";
"     * to an empty list; if the location is going to change, move";
"     * the object to $nothing.";
"     */";
"";
"    parents = `r[\"Attributes\"][\"parents\"][\"Value\"][\"value\"] ! E_RANGE => parents(o)';";
"";
"    if (parents(o) != parents)";
"      x = this:_write_parents(o, [\"Value\" -> [\"value\" -> {}]]);";
"      errors = errors + (\"Error\" in mapkeys(x));";
"    endif";
"";
"    location = `r[\"Values\"][\"location\"][\"Value\"][\"value\"] ! E_RANGE => o.location';";
"";
"    if (o.location != location)";
"      x = this:write_value(o, \"location\", [\"Value\" -> [\"value\" -> $nothing]]);";
"      errors = errors + (\"Error\" in mapkeys(x));";
"    endif";
"";
"    owner = `r[\"Values\"][\"owner\"][\"Value\"][\"value\"] ! E_RANGE => o.owner';";
"";
"    /* Do the owner, parents, player and location values first, in that";
"     * order.  Then properties and verbs.  Then the rest of the";
"     * values.";
"     */";
"";
"    if (\"owner\" in mapkeys(r[\"Values\"]))";
"      r[\"Values\"][\"owner\"] = this:write_value(o, \"owner\", r[\"Values\"][\"owner\"]);";
"      errors = errors + (\"Error\" in mapkeys(r[\"Values\"][\"owner\"]));";
"    endif";
"";
"    if (\"parents\" in mapkeys(r[\"Attributes\"]))";
"      r[\"Attributes\"][\"parents\"] = this:_write_parents(o, r[\"Attributes\"][\"parents\"]);";
"      errors = errors + (\"Error\" in mapkeys(r[\"Attributes\"][\"parents\"]));";
"    endif";
"";
"    if (\"player\" in mapkeys(r[\"Attributes\"]))";
"      r[\"Attributes\"][\"player\"] = this:_write_player(o, r[\"Attributes\"][\"player\"]);";
"      errors = errors + (\"Error\" in mapkeys(r[\"Attributes\"][\"player\"]));";
"    endif";
"";
"    if (\"location\" in mapkeys(r[\"Values\"]))";
"      r[\"Values\"][\"location\"] = this:write_value(o, \"location\", r[\"Values\"][\"location\"]);";
"      errors = errors + (\"Error\" in mapkeys(r[\"Values\"][\"location\"]));";
"    endif";
"";
"    if ((lp1 = length(properties)) < (lp2 = length(r[\"Properties\"])))";
"      for p in [lp1 + 1..lp2]";
"        this:_suspend_if_necessary();";
"        `add_property(o, tostr(\"___\", p, \"___\"), 0, {owner, \"\"}) ! E_PERM';";
"      endfor";
"    else";
"      for p in [lp2 + 1..lp1]";
"        this:_suspend_if_necessary();";
"        delete_property(o, properties[p]);";
"      endfor";
"    endif";
"";
"    if ((lv1 = length(verbs)) < (lv2 = length(r[\"Verbs\"])))";
"      for v in [lv1 + 1..lv2]";
"        this:_suspend_if_necessary();";
"        `add_verb(o, {owner, \"\", tostr(\"___\", v, \"___\")}, {\"this\", \"none\", \"this\"}) ! E_PERM';";
"      endfor";
"    else";
"      for v in [lv2 + 1..lv1]";
"        this:_suspend_if_necessary();";
"        delete_verb(o, lv2 + 1);";
"      endfor";
"    endif";
"";
"    for p in [1..length(r[\"Properties\"])]";
"      this:_suspend_if_necessary();";
"      r[\"Properties\"][p] = this:write_property(o, p, r[\"Properties\"][p]);";
"      if (\"Error\" in mapkeys(r[\"Properties\"][p]))";
"        if (lp1 < lp2 && r[\"Properties\"][p][\"Error\"][\"diagnostic\"] == \"property is invalid\")";
"          /* if we had to add properties but the property does not actually exist it should have been... */";
"          r[\"Properties\"][p][\"Error\"][\"diagnostic\"] = \"permission denied\";";
"        endif";
"        errors = errors + 1;";
"      endif";
"    endfor";
"";
"    for v in [1..length(r[\"Verbs\"])]";
"      this:_suspend_if_necessary();";
"      r[\"Verbs\"][v] = this:write_verb(o, v, r[\"Verbs\"][v], `options[\"verbs\"] ! E_RANGE => []');";
"      if (\"Error\" in mapkeys(r[\"Verbs\"][v]))";
"        if (lv1 < lv2 && r[\"Verbs\"][v][\"Error\"][\"diagnostic\"] == \"verb is invalid\")";
"          /* if we had to add verbs but the verb does not actually exist it should have been... */";
"          r[\"Verbs\"][v][\"Error\"][\"diagnostic\"] = \"permission denied\";";
"        endif";
"        errors = errors + 1;";
"      endif";
"    endfor";
"";
"    /* do the rest of the values */";
"";
"    values = setremove(setremove(mapkeys(r[\"Values\"]), \"location\"), \"owner\");";
"";
"    for a in (values)";
"      this:_suspend_if_necessary();";
"      r[\"Values\"][a] = this:write_value(o, a, r[\"Values\"][a]);";
"      errors = errors + (\"Error\" in mapkeys(r[\"Values\"][a]));";
"    endfor";
"";
"    if (errors < 1)";
"      r = this:read_object(o);";
"    else";
"      r[\"Meta\"] = [\"id\" -> toint(o), \"status\" -> \"unknown\"];";
"      r[\"Error\"] = [\"diagnostic\" -> \"errors in sub-operations\"];";
"    endif";
"";
"    return r;";
"";
"  except (E_RANGE, E_TYPE)";
"    r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];";
"    return r;";
"  except (E_PERM)";
"    r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];";
"    return r;";
"  endtry";
"else";
"  r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];";
"  return r;";
"endif";
"";
"chunk_length:146";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:2599BC910CE8865857727CC8C76455A1013330DC";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:8
{object, property} = args;
$private();
for parent in (parents(object))
this:_suspend_if_necessary();
if (ret = `property_info(parent, property) ! E_PROPNF')
return ret;
endif
endfor
return {};
return;
"{object, property} = args;";
"$private();";
"for parent in (parents(object))";
"  this:_suspend_if_necessary();";
"  if (ret = `property_info(parent, property) ! E_PROPNF')";
"    return ret;";
"  endif";
"endfor";
"return {};";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:6828227C67A26B9EB2F5086E7854A55943E5A2C5";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:9
{o} = args;
$private();
x = {};
for t in ({o, @ancestors(o)})
this:_suspend_if_necessary();
y = {};
for z in (properties(t))
this:_suspend_if_necessary();
y = {z, @y};
endfor
x = {@y, @x};
endfor
x = {"name", "owner", "location", "programmer", "wizard", "r", "w", "f", "a", @x};
return x;
return;
"{o} = args;";
"$private();";
"x = {};";
"for t in ({o, @ancestors(o)})";
"  this:_suspend_if_necessary();";
"  y = {};";
"  for z in (properties(t))";
"    this:_suspend_if_necessary();";
"    y = {z, @y};";
"  endfor";
"  x = {@y, @x};";
"endfor";
"x = {\"name\", \"owner\", \"location\", \"programmer\", \"wizard\", \"r\", \"w\", \"f\", \"a\", @x};";
"return x;";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:2F864E57D535E087E2CA7BD57C8195299E171A57";
"state:clean";
"updated_at:Thu Dec 27 08:35:47 2012 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"{o} = args;";
"$private();";
"x = {};";
"for t in ({o, @ancestors(o)})";
"  this:_suspend_if_necessary();";
"  y = {};";
"  for z in (properties(t))";
"    this:_suspend_if_necessary();";
"    y = {z, @y};";
"  endfor";
"  x = {@y, @x};";
"endfor";
"x = {\"name\", \"owner\", \"location\", \"programmer\", \"wizard\", \"r\", \"w\", \"f\", @x};";
"return x;";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:78C6751317BA2FCD27B13194182091EDF75588E2";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:10
{o} = args;
set_task_perms(caller_perms());
r = ["Values" -> {}];
for value in (this:_values(o))
this:_suspend_if_necessary();
r["Values"] = {@r["Values"], this:read_value(o, value)};
endfor
return r;
return;
"{o} = args;";
"set_task_perms(caller_perms());";
"r = [\"Values\" -> {}];";
"for value in (this:_values(o))";
"  this:_suspend_if_necessary();";
"  r[\"Values\"] = {@r[\"Values\"], this:read_value(o, value)};";
"endfor";
"return r;";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:9AA9361F32A2726062ACD072432C55955CD1CAB1";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:11
{o, a, ?options = []} = args;
strip_clear_values = `options["strip_clear_values"] ! E_RANGE';
set_task_perms(caller_perms());
try
if (a == "location")
v = o.location;
p = this:_controls(caller_perms(), o) ? "rw" | "r";
elseif (a in {"owner", "programmer", "wizard"})
v = o.(a);
p = `caller_perms().wizard ! E_INVIND' ? "rw" | "r";
elseif (a in {"r", "w", "f", "a"})
v = o.(a);
p = this:_controls(caller_perms(), o) ? "rw" | "r";
elseif (a in {"name"})
v = o.(a);
p = (`caller_perms().wizard ! E_INVIND' || (this:_controls(caller_perms(), o) && (!is_player(o)))) ? "rw" | "r";
else
v = o.(a);
pi = property_info(o, a);
p = (index(pi[2], "w") || this:_controls_property(caller_perms(), o, a)) ? "rw" | "r";
c = is_clear_property(o, a);
endif
except (E_INVIND, E_PROPNF)
r = ["Meta" -> ["id" -> a, "status" -> "invalid"]];
return r;
except (E_PERM)
r = ["Meta" -> ["id" -> a, "status" -> "denied"]];
return r;
endtry
m = ["id" -> a];
m["status"] = index(p, "w") ? "writable" | "readable";
r = ["Meta" -> m, "Value" -> ["value" -> v]];
if (`r["Value"]["clear"] = c ! E_VARNF' && strip_clear_values)
r["Value"] = mapdelete(r["Value"], "value");
endif
if (`pi ! E_VARNF')
if ((ppi = this:_parent_property_info(o, a)) && (ppi != pi))
r["Value"]["owner"] = pi[1];
r["Value"]["perms"] = pi[2];
endif
endif
return r;
return;
"{o, a, ?options = []} = args;";
"";
"strip_clear_values = `options[\"strip_clear_values\"] ! E_RANGE';";
"";
"set_task_perms(caller_perms());";
"";
"try";
"  if (a == \"location\")";
"    v = o.location;";
"    p = this:_controls(caller_perms(), o) ? \"rw\" | \"r\";";
"  elseif (a in {\"owner\", \"programmer\", \"wizard\"})";
"    v = o.(a);";
"    p = `caller_perms().wizard ! E_INVIND' ? \"rw\" | \"r\";";
"  elseif (a in {\"r\", \"w\", \"f\", \"a\"})";
"    v = o.(a);";
"    p = this:_controls(caller_perms(), o) ? \"rw\" | \"r\";";
"  elseif (a in {\"name\"})";
"    v = o.(a);";
"    p = `caller_perms().wizard ! E_INVIND' || (this:_controls(caller_perms(), o) && !is_player(o)) ? \"rw\" | \"r\";";
"  else";
"    v = o.(a);";
"    pi = property_info(o, a);";
"    p = index(pi[2], \"w\") || this:_controls_property(caller_perms(), o, a) ? \"rw\" | \"r\";";
"    c = is_clear_property(o, a);";
"  endif";
"except (E_INVIND, E_PROPNF)";
"  r = [\"Meta\" -> [\"id\" -> a, \"status\" -> \"invalid\"]];";
"  return r;";
"except (E_PERM)";
"  r = [\"Meta\" -> [\"id\" -> a, \"status\" -> \"denied\"]];";
"  return r;";
"endtry";
"m = [\"id\" -> a];";
"m[\"status\"] = index(p, \"w\") ? \"writable\" | \"readable\";";
"r = [\"Meta\" -> m, \"Value\" -> [\"value\" -> v]];";
"if (`r[\"Value\"][\"clear\"] = c ! E_VARNF' && strip_clear_values) /* `c' is not defined for built-in properties */";
"  r[\"Value\"] = mapdelete(r[\"Value\"], \"value\");";
"endif";
"if (`pi ! E_VARNF')";
"  if ((ppi = this:_parent_property_info(o, a)) && ppi != pi)";
"    r[\"Value\"][\"owner\"] = pi[1];";
"    r[\"Value\"][\"perms\"] = pi[2];";
"  endif";
"endif";
"";
"return r;";
"";
"chunk_length:46";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:3";
"sha1:E51DADB807832C3FA5A13490E55B70B98D580B0B";
"state:clean";
"updated_at:Wed Jan  2 08:07:00 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"{o, a, ?options = []} = args;";
"";
"set_task_perms(caller_perms());";
"";
"try";
"  if (a == \"location\")";
"    v = o.location;";
"    p = this:_controls(caller_perms(), o) ? \"rw\" | \"r\";";
"  elseif (a in {\"owner\", \"programmer\", \"wizard\"})";
"    v = o.(a);";
"    p = `caller_perms().wizard ! E_INVIND => 0' ? \"rw\" | \"r\";";
"  elseif (a in {\"r\", \"w\", \"f\", \"a\"})";
"    v = o.(a);";
"    p = this:_controls(caller_perms(), o) ? \"rw\" | \"r\";";
"  elseif (a in {\"name\"})";
"    v = o.(a);";
"    p = `caller_perms().wizard ! E_INVIND' || (this:_controls(caller_perms(), o) && !is_player(o)) ? \"rw\" | \"r\";";
"  else";
"    v = o.(a);";
"    pi = property_info(o, a);";
"    p = index(pi[2], \"w\") || this:_controls_property(caller_perms(), o, a) ? \"rw\" | \"r\";";
"    c = is_clear_property(o, a);";
"  endif";
"except (E_INVIND, E_PROPNF)";
"  r = [\"Meta\" -> [\"id\" -> a, \"status\" -> \"invalid\"]];";
"  return r;";
"except (E_PERM)";
"  r = [\"Meta\" -> [\"id\" -> a, \"status\" -> \"denied\"]];";
"  return r;";
"endtry";
"m = [\"id\" -> a];";
"m[\"status\"] = index(p, \"w\") ? \"writable\" | \"readable\";";
"r = [\"Meta\" -> m, \"Value\" -> [\"value\" -> v]];";
"`r[\"Value\"][\"clear\"] = c ! E_VARNF'; /* `c' is not defined for built-in properties */";
"if (`pi ! E_VARNF')";
"  if ((ppi = this:_parent_property_info(o, a)) && ppi != pi)";
"    r[\"Value\"][\"owner\"] = pi[1];";
"    r[\"Value\"][\"perms\"] = pi[2];";
"  endif";
"endif";
"";
"return r;";
"";
"chunk_length:42";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:3161CA506E9E51416A2B2BA1600FB88EA1DA996D";
"state:clean";
"updated_at:Thu Dec 27 08:36:11 2012 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"{o, a, ?options = []} = args;";
"";
"set_task_perms(caller_perms());";
"";
"try";
"  if (a == \"location\")";
"    v = o.location;";
"    p = this:_controls(caller_perms(), o) ? \"rw\" | \"r\";";
"  elseif (a in {\"owner\", \"programmer\", \"wizard\"})";
"    v = o.(a);";
"    p = `caller_perms().wizard ! E_INVIND => 0' ? \"rw\" | \"r\";";
"  elseif (a in {\"r\", \"w\", \"f\"})";
"    v = o.(a);";
"    p = this:_controls(caller_perms(), o) ? \"rw\" | \"r\";";
"  elseif (a in {\"name\"})";
"    v = o.(a);";
"    p = `caller_perms().wizard ! E_INVIND' || (this:_controls(caller_perms(), o) && !is_player(o)) ? \"rw\" | \"r\";";
"  else";
"    v = o.(a);";
"    pi = property_info(o, a);";
"    p = index(pi[2], \"w\") || this:_controls_property(caller_perms(), o, a) ? \"rw\" | \"r\";";
"    c = is_clear_property(o, a);";
"  endif";
"except (E_INVIND, E_PROPNF)";
"  r = [\"Meta\" -> [\"id\" -> a, \"status\" -> \"invalid\"]];";
"  return r;";
"except (E_PERM)";
"  r = [\"Meta\" -> [\"id\" -> a, \"status\" -> \"denied\"]];";
"  return r;";
"endtry";
"m = [\"id\" -> a];";
"m[\"status\"] = index(p, \"w\") ? \"writable\" | \"readable\";";
"r = [\"Meta\" -> m, \"Value\" -> [\"value\" -> v]];";
"`r[\"Value\"][\"clear\"] = c ! E_VARNF'; /* `c' is not defined for built-in properties */";
"if (`pi ! E_VARNF')";
"  if ((ppi = this:_parent_property_info(o, a)) && ppi != pi)";
"    r[\"Value\"][\"owner\"] = pi[1];";
"    r[\"Value\"][\"perms\"] = pi[2];";
"  endif";
"endif";
"";
"return r;";
"";
"chunk_length:42";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:2E8CB4270CA662D0DF1515975B7B7F28232A5325";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:12
{o, a, r, ?options = []} = args;
set_task_perms(caller_perms());
mk = mapkeys(r);
if ((!("Meta" in mk)) && (!("Value" in mk)))
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
endif
old = this:read_value(o, a, options);
if (`old["Value"] ! E_RANGE' == `r["Value"] ! E_RANGE')
return old;
endif
try
mk = mapkeys(r["Value"]);
if (a in {"name", "owner", "location", "programmer", "wizard", "r", "w", "f", "a"})
if ("clear" in mk)
r["Error"] = ["diagnostic" -> "clear is not applicable"];
return r;
endif
if ("owner" in mk)
r["Error"] = ["diagnostic" -> "owner is not applicable"];
return r;
endif
if ("perms" in mk)
r["Error"] = ["diagnostic" -> "perms is not applicable"];
return r;
endif
endif
c = `r["Value"]["clear"] ! E_RANGE';
if (c)
clear_property(o, a);
else
v = r["Value"]["value"];
if (a == "location")
(o.location != v) && move(o, v);
else
o.(a) = v;
endif
endif
if (("owner" in mk) || ("perms" in mk))
set_property_info(o, a, {`r["Value"]["owner"] ! E_RANGE => caller_perms()', r["Value"]["perms"]});
endif
except (E_RANGE)
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
except (E_INVIND)
r["Error"] = ["diagnostic" -> "object reference is invalid"];
return r;
except (E_PROPNF)
r["Error"] = ["diagnostic" -> "value is invalid"];
return r;
except (E_PERM)
r["Error"] = ["diagnostic" -> "permission denied"];
return r;
except (E_TYPE)
r["Error"] = ["diagnostic" -> "data type is invalid"];
return r;
except (E_NACC)
r["Error"] = ["diagnostic" -> "move refused by destination"];
return r;
except (E_RECMOVE)
r["Error"] = ["diagnostic" -> "recursive move"];
return r;
endtry
return this:read_value(o, a, options);
return;
"{o, a, r, ?options = []} = args;";
"";
"set_task_perms(caller_perms());";
"";
"/* My thinking is that a valid input will either have meta data";
" * (from a prior read) or a value.  If both are missing, this";
" * input is garbage of some sort.";
" */";
"mk = mapkeys(r);";
"if (!(\"Meta\" in mk) && !(\"Value\" in mk))";
"  r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];";
"  return r;";
"endif";
"";
"old = this:read_value(o, a, options);";
"if (`old[\"Value\"] ! E_RANGE' == `r[\"Value\"] ! E_RANGE')";
"  return old;";
"endif";
"";
"try";
"  mk = mapkeys(r[\"Value\"]);";
"  if (a in {\"name\", \"owner\", \"location\", \"programmer\", \"wizard\", \"r\", \"w\", \"f\", \"a\"})";
"    if (\"clear\" in mk)";
"      r[\"Error\"] = [\"diagnostic\" -> \"clear is not applicable\"];";
"      return r;";
"    endif";
"    if (\"owner\" in mk)";
"      r[\"Error\"] = [\"diagnostic\" -> \"owner is not applicable\"];";
"      return r;";
"    endif";
"    if (\"perms\" in mk)";
"      r[\"Error\"] = [\"diagnostic\" -> \"perms is not applicable\"];";
"      return r;";
"    endif";
"  endif";
"  c = `r[\"Value\"][\"clear\"] ! E_RANGE';";
"  if (c)";
"    clear_property(o, a);";
"  else";
"    v = r[\"Value\"][\"value\"];";
"    if (a == \"location\")";
"      o.location != v && move(o, v);";
"    else";
"      o.(a) = v;";
"    endif";
"  endif";
"  if (\"owner\" in mk || \"perms\" in mk)";
"    set_property_info(o, a, {`r[\"Value\"][\"owner\"] ! E_RANGE => caller_perms()', r[\"Value\"][\"perms\"]});";
"  endif";
"except (E_RANGE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];";
"  return r;";
"except (E_INVIND)";
"  r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];";
"  return r;";
"except (E_PROPNF)";
"  r[\"Error\"] = [\"diagnostic\" -> \"value is invalid\"];";
"  return r;";
"except (E_PERM)";
"  r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];";
"  return r;";
"except (E_TYPE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"data type is invalid\"];";
"  return r;";
"except (E_NACC)";
"  r[\"Error\"] = [\"diagnostic\" -> \"move refused by destination\"];";
"  return r;";
"except (E_RECMOVE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"recursive move\"];";
"  return r;";
"endtry";
"";
"return this:read_value(o, a, options);";
"";
"chunk_length:73";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:3";
"sha1:C4A0362C17C05647E05D00C699D093AE43D007DC";
"state:clean";
"updated_at:Wed Jan  2 07:36:11 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"{o, a, r, ?options = []} = args;";
"";
"set_task_perms(caller_perms());";
"";
"/* My thinking is that a valid input will either have meta data";
" * (from a prior read) or a value.  If both are missing, this";
" * input is garbage of some sort.";
" */";
"mk = mapkeys(r);";
"if (!(\"Meta\" in mk) && !(\"Value\" in mk))";
"  r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];";
"  return r;";
"endif";
"";
"old = this:read_value(o, a);";
"if (`old[\"Value\"] ! E_RANGE' == `r[\"Value\"] ! E_RANGE')";
"  return old;";
"endif";
"";
"try";
"  mk = mapkeys(r[\"Value\"]);";
"  if (a in {\"name\", \"owner\", \"location\", \"programmer\", \"wizard\", \"r\", \"w\", \"f\", \"a\"})";
"    if (\"clear\" in mk)";
"      r[\"Error\"] = [\"diagnostic\" -> \"clear is not applicable\"];";
"      return r;";
"    endif";
"    if (\"owner\" in mk)";
"      r[\"Error\"] = [\"diagnostic\" -> \"owner is not applicable\"];";
"      return r;";
"    endif";
"    if (\"perms\" in mk)";
"      r[\"Error\"] = [\"diagnostic\" -> \"perms is not applicable\"];";
"      return r;";
"    endif";
"  endif";
"  c = `r[\"Value\"][\"clear\"] ! E_RANGE';";
"  if (c)";
"    clear_property(o, a);";
"  else";
"    v = r[\"Value\"][\"value\"];";
"    if (a == \"location\")";
"      o.location != v && move(o, v);";
"    else";
"      o.(a) = v;";
"    endif";
"  endif";
"  if (\"owner\" in mk || \"perms\" in mk)";
"    set_property_info(o, a, {`r[\"Value\"][\"owner\"] ! E_RANGE => caller_perms()', r[\"Value\"][\"perms\"]});";
"  endif";
"except (E_RANGE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];";
"  return r;";
"except (E_INVIND)";
"  r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];";
"  return r;";
"except (E_PROPNF)";
"  r[\"Error\"] = [\"diagnostic\" -> \"value is invalid\"];";
"  return r;";
"except (E_PERM)";
"  r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];";
"  return r;";
"except (E_TYPE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"data type is invalid\"];";
"  return r;";
"except (E_NACC)";
"  r[\"Error\"] = [\"diagnostic\" -> \"move refused by destination\"];";
"  return r;";
"except (E_RECMOVE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"recursive move\"];";
"  return r;";
"endtry";
"";
"return this:read_value(o, a);";
"";
"chunk_length:73";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:63BA8F377460DBC032C47C0DFA6D4DD46A8A989E";
"state:clean";
"updated_at:Thu Dec 27 08:36:39 2012 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"{o, a, r, ?options = []} = args;";
"";
"set_task_perms(caller_perms());";
"";
"/* My thinking is that a valid input will either have meta data";
" * (from a prior read) or a value.  If both are missing, this";
" * input is garbage of some sort.";
" */";
"mk = mapkeys(r);";
"if (!(\"Meta\" in mk) && !(\"Value\" in mk))";
"  r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];";
"  return r;";
"endif";
"";
"old = this:read_value(o, a);";
"if (`old[\"Value\"] ! E_RANGE' == `r[\"Value\"] ! E_RANGE')";
"  return old;";
"endif";
"";
"try";
"  mk = mapkeys(r[\"Value\"]);";
"  if (a in {\"name\", \"owner\", \"location\", \"programmer\", \"wizard\", \"r\", \"w\", \"f\"})";
"    if (\"clear\" in mk)";
"      r[\"Error\"] = [\"diagnostic\" -> \"clear is not applicable\"];";
"      return r;";
"    endif";
"    if (\"owner\" in mk)";
"      r[\"Error\"] = [\"diagnostic\" -> \"owner is not applicable\"];";
"      return r;";
"    endif";
"    if (\"perms\" in mk)";
"      r[\"Error\"] = [\"diagnostic\" -> \"perms is not applicable\"];";
"      return r;";
"    endif";
"  endif";
"  c = `r[\"Value\"][\"clear\"] ! E_RANGE';";
"  if (c)";
"    clear_property(o, a);";
"  else";
"    v = r[\"Value\"][\"value\"];";
"    if (a == \"location\")";
"      o.location != v && move(o, v);";
"    else";
"      o.(a) = v;";
"    endif";
"  endif";
"  if (\"owner\" in mk || \"perms\" in mk)";
"    set_property_info(o, a, {`r[\"Value\"][\"owner\"] ! E_RANGE => caller_perms()', r[\"Value\"][\"perms\"]});";
"  endif";
"except (E_RANGE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];";
"  return r;";
"except (E_INVIND)";
"  r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];";
"  return r;";
"except (E_PROPNF)";
"  r[\"Error\"] = [\"diagnostic\" -> \"value is invalid\"];";
"  return r;";
"except (E_PERM)";
"  r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];";
"  return r;";
"except (E_TYPE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"data type is invalid\"];";
"  return r;";
"except (E_NACC)";
"  r[\"Error\"] = [\"diagnostic\" -> \"move refused by destination\"];";
"  return r;";
"except (E_RECMOVE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"recursive move\"];";
"  return r;";
"endtry";
"";
"return this:read_value(o, a);";
"";
"chunk_length:73";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:CF452BA63F8E905475FC4C9A5F601EB8FE65FA1B";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:13
{o, r} = args;
$private();
set_task_perms(caller_perms());
try
v = r["Value"]["value"];
(parents(o) != v) && chparents(o, v);
except (E_RANGE)
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
except (E_INVARG)
r["Error"] = ["diagnostic" -> "argument is invalid"];
return r;
except (E_TYPE)
r["Error"] = ["diagnostic" -> "data type is invalid"];
return r;
except (E_PERM)
r["Error"] = ["diagnostic" -> "permission denied"];
return r;
endtry
v = parents(o);
m = ["id" -> "parents"];
m["status"] = this:_controls(caller_perms(), o) ? "writable" | "readable";
return ["Meta" -> m, "Value" -> ["value" -> v]];
return;
"{o, r} = args;";
"";
"$private();";
"";
"set_task_perms(caller_perms());";
"";
"try";
"  v = r[\"Value\"][\"value\"];";
"  parents(o) != v && chparents(o, v);";
"except (E_RANGE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];";
"  return r;";
"except (E_INVARG)";
"  r[\"Error\"] = [\"diagnostic\" -> \"argument is invalid\"];";
"  return r;";
"except (E_TYPE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"data type is invalid\"];";
"  return r;";
"except (E_PERM)";
"  r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];";
"  return r;";
"endtry";
"v = parents(o);";
"m = [\"id\" -> \"parents\"];";
"m[\"status\"] = this:_controls(caller_perms(), o) ? \"writable\" | \"readable\";";
"";
"return [\"Meta\" -> m, \"Value\" -> [\"value\" -> v]];";
"";
"chunk_length:27";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:13295564FAFF9F44B09B6E7E1EBA217EACD36506";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:14
{o, r} = args;
$private();
set_task_perms(caller_perms());
try
v = r["Value"]["value"];
(is_player(o) != v) && set_player_flag(o, v);
except (E_RANGE)
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
except (E_INVARG)
r["Error"] = ["diagnostic" -> "argument is invalid"];
return r;
except (E_TYPE)
r["Error"] = ["diagnostic" -> "data type is invalid"];
return r;
except (E_PERM)
r["Error"] = ["diagnostic" -> "permission denied"];
return r;
endtry
v = is_player(o);
m = ["id" -> "player"];
m["status"] = `caller_perms().wizard ! E_INVIND' ? "writable" | "readable";
return ["Meta" -> m, "Value" -> ["value" -> v]];
return;
"{o, r} = args;";
"";
"$private();";
"";
"set_task_perms(caller_perms());";
"";
"try";
"  v = r[\"Value\"][\"value\"];";
"  is_player(o) != v && set_player_flag(o, v);";
"except (E_RANGE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];";
"  return r;";
"except (E_INVARG)";
"  r[\"Error\"] = [\"diagnostic\" -> \"argument is invalid\"];";
"  return r;";
"except (E_TYPE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"data type is invalid\"];";
"  return r;";
"except (E_PERM)";
"  r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];";
"  return r;";
"endtry";
"v = is_player(o);";
"m = [\"id\" -> \"player\"];";
"m[\"status\"] = `caller_perms().wizard ! E_INVIND' ? \"writable\" | \"readable\";";
"";
"return [\"Meta\" -> m, \"Value\" -> [\"value\" -> v]];";
"";
"chunk_length:27";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:2F9B28A8C6CB72E794788386CBEC7597681A088E";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:15
{o, v, ?options = []} = args;
try
vx = verbs(o);
except (E_TYPE, E_INVARG)
r = ["Meta" -> ["id" -> o, "status" -> "invalid"]];
return r;
endtry
try
vn = vx[v];
except (E_TYPE, E_RANGE)
r = ["Meta" -> ["id" -> v, "status" -> "invalid"]];
return r;
endtry
set_task_perms(caller_perms());
try
vd = $verb_detail(o, v);
d = ["owner" -> vd["owner"], "perms" -> vd["perms"], "names" -> vd["names"], "dobj" -> vd["dobj"], "prep" -> vd["prep"], "iobj" -> vd["iobj"], "code" -> verb_code(o, v)];
`d["content_type"] = vd["content_type"] ! E_RANGE';
p = (index(d["perms"], "w") || this:_controls_verb(caller_perms(), o, v)) ? "rw" | "r";
except (E_TYPE, E_INVARG, E_VERBNF)
r = ["Meta" -> ["id" -> v, "status" -> "invalid"]];
return r;
except (E_PERM)
r = ["Meta" -> ["id" -> v, "status" -> "denied"]];
return r;
endtry
m = ["id" -> v];
m["status"] = index(p, "w") ? "writable" | "readable";
r = ["Meta" -> m, "Verb" -> d];
return r;
return;
"{o, v, ?options = []} = args;";
"";
"try";
"  vx = verbs(o);";
"except (E_TYPE, E_INVARG)";
"  r = [\"Meta\" -> [\"id\" -> o, \"status\" -> \"invalid\"]];";
"  return r;";
"endtry";
"try";
"  vn = vx[v];";
"except (E_TYPE, E_RANGE)";
"  r = [\"Meta\" -> [\"id\" -> v, \"status\" -> \"invalid\"]];";
"  return r;";
"endtry";
"";
"set_task_perms(caller_perms());";
"";
"try";
"  vd = $verb_detail(o, v);";
"  d = [\"owner\" -> vd[\"owner\"], \"perms\" -> vd[\"perms\"], \"names\" -> vd[\"names\"], \"dobj\" -> vd[\"dobj\"], \"prep\" -> vd[\"prep\"], \"iobj\" -> vd[\"iobj\"], \"code\" -> verb_code(o, v)];";
"  `d[\"content_type\"] = vd[\"content_type\"] ! E_RANGE';";
"  p = index(d[\"perms\"], \"w\") || this:_controls_verb(caller_perms(), o, v) ? \"rw\" | \"r\";";
"except (E_TYPE, E_INVARG, E_VERBNF)";
"  r = [\"Meta\" -> [\"id\" -> v, \"status\" -> \"invalid\"]];";
"  return r;";
"except (E_PERM)";
"  r = [\"Meta\" -> [\"id\" -> v, \"status\" -> \"denied\"]];";
"  return r;";
"endtry";
"m = [\"id\" -> v];";
"m[\"status\"] = index(p, \"w\") ? \"writable\" | \"readable\";";
"r = [\"Meta\" -> m, \"Verb\" -> d];";
"";
"return r;";
"";
"chunk_length:34";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:367EFEFF3C7E1489CF550095CC307D080EFB64A0";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:16
{o, v, r, ?options = []} = args;
error1 = error2 = 0;
try
vx = verbs(o);
except (E_TYPE, E_INVARG)
error1 = 1;
endtry
try
vn = vx[v];
except (E_VARNF)
except (E_TYPE, E_RANGE)
error2 = 1;
endtry
set_task_perms(caller_perms());
old = this:read_verb(o, v);
if (`old["Verb"] ! E_RANGE' == `r["Verb"] ! E_RANGE')
return old;
endif
if (error1)
r["Error"] = ["diagnostic" -> "object reference is invalid"];
return r;
elseif (error2)
r["Error"] = ["diagnostic" -> "verb is invalid"];
return r;
endif
try
r1 = r["Verb"];
set_verb_info(o, v, {`r1["owner"] ! E_RANGE => caller_perms()', r1["perms"], r1["names"]});
set_verb_args(o, v, {r1["dobj"], r1["prep"], r1["iobj"]});
vc = `r1["code"] ! E_RANGE => {}';
t = options;
`t["content_type"] = r1["content_type"] ! E_RANGE';
if (set_verb_code(o, v, vc, t))
r["Error"] = ["diagnostic" -> "compilation errors"];
return r;
endif
except (E_RANGE)
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
except (E_INVIND, E_INVARG)
r["Error"] = ["diagnostic" -> "object reference is invalid"];
return r;
except (E_PERM)
r["Error"] = ["diagnostic" -> "permission denied"];
return r;
except (E_TYPE)
r["Error"] = ["diagnostic" -> "data type is invalid"];
return r;
endtry
return this:read_verb(o, v);
return;
"{o, v, r, ?options = []} = args;";
"";
"/* measure, then drop perms, then take action if necessary */";
"";
"error1 = error2 = 0;";
"";
"try";
"  vx = verbs(o);";
"except (E_TYPE, E_INVARG)";
"  error1 = 1;";
"endtry";
"try";
"  vn = vx[v];";
"except (E_VARNF)";
"  /* vx is not defined because `verbs(o)' failed */";
"except (E_TYPE, E_RANGE)";
"  error2 = 1;";
"endtry";
"";
"set_task_perms(caller_perms());";
"";
"old = this:read_verb(o, v);";
"if (`old[\"Verb\"] ! E_RANGE' == `r[\"Verb\"] ! E_RANGE')";
"  return old;";
"endif";
"";
"if (error1)";
"  r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];";
"  return r;";
"elseif (error2)";
"  r[\"Error\"] = [\"diagnostic\" -> \"verb is invalid\"];";
"  return r;";
"endif";
"";
"try";
"  r1 = r[\"Verb\"];";
"";
"  set_verb_info(o, v, {`r1[\"owner\"] ! E_RANGE => caller_perms()', r1[\"perms\"], r1[\"names\"]});";
"  set_verb_args(o, v, {r1[\"dobj\"], r1[\"prep\"], r1[\"iobj\"]});";
"";
"  vc = `r1[\"code\"] ! E_RANGE => {}';";
"";
"  t = options;";
"  `t[\"content_type\"] = r1[\"content_type\"] ! E_RANGE';";
"  if (set_verb_code(o, v, vc, t))";
"    r[\"Error\"] = [\"diagnostic\" -> \"compilation errors\"];";
"    return r;";
"  endif";
"";
"except (E_RANGE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];";
"  return r;";
"except (E_INVIND, E_INVARG)";
"  r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];";
"  return r;";
"except (E_PERM)";
"  r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];";
"  return r;";
"except (E_TYPE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"data type is invalid\"];";
"  return r;";
"endtry";
"";
"return this:read_verb(o, v);";
"";
"chunk_length:64";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:5A8575C934879C2B75E8CC91E6481163FA7C565F";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:17
{o, p, ?options = []} = args;
try
px = properties(o);
except (E_TYPE, E_INVARG)
r = ["Meta" -> ["id" -> o, "status" -> "invalid"]];
return r;
endtry
try
pn = px[p];
except (E_TYPE, E_RANGE)
r = ["Meta" -> ["id" -> p, "status" -> "invalid"]];
return r;
endtry
set_task_perms(caller_perms());
try
pi = property_info(o, pn);
pv = o.(pn);
s = (index(pi[2], "w") || this:_controls_property(caller_perms(), o, pn)) ? "rw" | "r";
except (E_TYPE, E_INVARG, E_PROPNF)
r = ["Meta" -> ["id" -> p, "status" -> "invalid"]];
return r;
except (E_PERM)
r = ["Meta" -> ["id" -> p, "status" -> "denied"]];
return r;
endtry
m = ["id" -> p];
m["status"] = index(s, "w") ? "writable" | "readable";
r = ["Meta" -> m, "Property" -> ["owner" -> pi[1], "perms" -> pi[2], "name" -> pn, "value" -> pv]];
return r;
return;
"{o, p, ?options = []} = args;";
"";
"try";
"  px = properties(o);";
"except (E_TYPE, E_INVARG)";
"  r = [\"Meta\" -> [\"id\" -> o, \"status\" -> \"invalid\"]];";
"  return r;";
"endtry";
"try";
"  pn = px[p];";
"except (E_TYPE, E_RANGE)";
"  r = [\"Meta\" -> [\"id\" -> p, \"status\" -> \"invalid\"]];";
"  return r;";
"endtry";
"";
"set_task_perms(caller_perms());";
"";
"try";
"  pi = property_info(o, pn);";
"  pv = o.(pn);";
"  s = index(pi[2], \"w\") || this:_controls_property(caller_perms(), o, pn) ? \"rw\" | \"r\";";
"except (E_TYPE, E_INVARG, E_PROPNF)";
"  r = [\"Meta\" -> [\"id\" -> p, \"status\" -> \"invalid\"]];";
"  return r;";
"except (E_PERM)";
"  r = [\"Meta\" -> [\"id\" -> p, \"status\" -> \"denied\"]];";
"  return r;";
"endtry";
"m = [\"id\" -> p];";
"m[\"status\"] = index(s, \"w\") ? \"writable\" | \"readable\";";
"r = [\"Meta\" -> m, \"Property\" -> [\"owner\" -> pi[1], \"perms\" -> pi[2], \"name\" -> pn, \"value\" -> pv]];";
"";
"return r;";
"";
"chunk_length:33";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:A68B9AEA6EB6F822FAFF6105D1A109B9F99D6025";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:18
{o, p, r, ?options = []} = args;
error1 = error2 = 0;
try
px = properties(o);
except (E_TYPE, E_INVARG)
error1 = 1;
endtry
try
pn = px[p];
except (E_VARNF)
except (E_TYPE, E_RANGE)
error2 = 1;
endtry
set_task_perms(caller_perms());
old = this:read_property(o, p);
if (`old["Property"] ! E_RANGE' == `r["Property"] ! E_RANGE')
return old;
endif
if (error1)
r["Error"] = ["diagnostic" -> "object reference is invalid"];
return r;
elseif (error2)
r["Error"] = ["diagnostic" -> "property is invalid"];
return r;
endif
try
r1 = r["Property"];
set_property_info(o, pn, {`r1["owner"] ! E_RANGE => caller_perms()', r1["perms"], r1["name"]});
o.(r1["name"]) = r1["value"];
except (E_RANGE)
r["Error"] = ["diagnostic" -> "bad message format"];
return r;
except (E_INVIND, E_INVARG)
r["Error"] = ["diagnostic" -> "object reference is invalid"];
return r;
except (E_PERM)
r["Error"] = ["diagnostic" -> "permission denied"];
return r;
except (E_TYPE)
r["Error"] = ["diagnostic" -> "data type is invalid"];
return r;
endtry
return this:read_property(o, p);
return;
"{o, p, r, ?options = []} = args;";
"";
"/* measure, then drop perms, then take action if necessary */";
"";
"error1 = error2 = 0;";
"";
"try";
"  px = properties(o);";
"except (E_TYPE, E_INVARG)";
"  error1 = 1;";
"endtry";
"try";
"  pn = px[p];";
"except (E_VARNF)";
"  /* px is not defined because `properties(o)' failed */";
"except (E_TYPE, E_RANGE)";
"  error2 = 1;";
"endtry";
"";
"set_task_perms(caller_perms());";
"";
"old = this:read_property(o, p);";
"if (`old[\"Property\"] ! E_RANGE' == `r[\"Property\"] ! E_RANGE')";
"  return old;";
"endif";
"";
"if (error1)";
"  r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];";
"  return r;";
"elseif (error2)";
"  r[\"Error\"] = [\"diagnostic\" -> \"property is invalid\"];";
"  return r;";
"endif";
"";
"try";
"  r1 = r[\"Property\"];";
"";
"  set_property_info(o, pn, {`r1[\"owner\"] ! E_RANGE => caller_perms()', r1[\"perms\"], r1[\"name\"]});";
"  o.(r1[\"name\"]) = r1[\"value\"];";
"";
"except (E_RANGE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"bad message format\"];";
"  return r;";
"except (E_INVIND, E_INVARG)";
"  r[\"Error\"] = [\"diagnostic\" -> \"object reference is invalid\"];";
"  return r;";
"except (E_PERM)";
"  r[\"Error\"] = [\"diagnostic\" -> \"permission denied\"];";
"  return r;";
"except (E_TYPE)";
"  r[\"Error\"] = [\"diagnostic\" -> \"data type is invalid\"];";
"  return r;";
"endtry";
"";
"return this:read_property(o, p);";
"";
"chunk_length:55";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:D78DD21D8FA7CEC926AF6779C32C69E66E7F2311";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:19
{?parents = {}} = args;
o = ["Attributes" -> [], "Values" -> [], "Properties" -> {}, "Verbs" -> {}];
if (parents)
o["Attributes"]["parents"] = ["Value" -> ["value" -> parents]];
endif
return o;
return;
"{?parents = {}} = args;";
"o = [\"Attributes\" -> [], \"Values\" -> [], \"Properties\" -> {}, \"Verbs\" -> {}];";
"if (parents)";
"  o[\"Attributes\"][\"parents\"] = [\"Value\" -> [\"value\" -> parents]];";
"endif";
"return o;";
"";
"chunk_length:6";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:9969B59DEBF0F2BC6F62679AF94EBE480E3A6B38";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:20
{t, n, v} = args;
t["Values"][n] = ["Value" -> ["value" -> v]];
return t;
return;
"{t, n, v} = args;";
"";
"t[\"Values\"][n] = [\"Value\" -> [\"value\" -> v]];";
"";
"return t;";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:6B7C622565FB5DA32263B609A8125AB3BCF3F229";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:21
{t, pn, pv, pi} = args;
p = ["Property" -> ["owner" -> pi[1], "perms" -> pi[2], "name" -> pn, "value" -> pv]];
t["Properties"] = {@t["Properties"], p};
return t;
return;
"{t, pn, pv, pi} = args;";
"";
"p = [\"Property\" -> [\"owner\" -> pi[1], \"perms\" -> pi[2], \"name\" -> pn, \"value\" -> pv]];";
"";
"t[\"Properties\"] = {@t[\"Properties\"], p};";
"";
"return t;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:4EA890888B90932C61B555A4FF4158BEDB2B945E";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#8:22
{t, vi, va, ?vc = {}} = args;
v = ["Verb" -> ["owner" -> vi[1], "perms" -> vi[2], "names" -> vi[3], "dobj" -> va[1], "prep" -> va[2], "iobj" -> va[3], "code" -> vc]];
t["Verbs"] = {@t["Verbs"], v};
return t;
return;
"{t, vi, va, ?vc = {}} = args;";
"";
"v = [\"Verb\" -> [\"owner\" -> vi[1], \"perms\" -> vi[2], \"names\" -> vi[3], \"dobj\" -> va[1], \"prep\" -> va[2], \"iobj\" -> va[3], \"code\" -> vc]];";
"";
"t[\"Verbs\"] = {@t[\"Verbs\"], v};";
"";
"return t;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:8A4B8E29A09479CE3DED7B5855A8AEA121411BCB";
"state:clean";
"updated_at:Fri Jun  8 06:45:56 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:0
$private();
notify(player, tostr(@args));
return;
"$private();";
"";
"/* Log args -- for debugging. */";
"";
"notify(player, tostr(@args));";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:490E6AF4153E0141BFBA78C901285331F568EB41";
"state:clean";
"updated_at:Sun Dec 30 19:04:42 2012 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:1
$private();
{what, where} = args;
`move(what, where) ! ANY';
return;
"$private();";
"";
"{what, where} = args;";
"";
"/* Move `what' to `where'.  Runs with wiz-perms.  Won't raise an error. */";
"";
"`move(what, where) ! ANY';";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:D8E4C8B1FC542890503A041C595CD6A7507E8CF3";
"state:clean";
"updated_at:Thu Feb 14 21:59:46 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"$private();";
"";
"{what, where} = args;";
"";
"/* Move `what' to `where'.  Runs with wiz-perms.  Won't raise an error. */";
"";
"move(what, where);";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:50E79F1ACB7D517A843095394583F99DA4EF96A2";
"state:clean";
"updated_at:Sun Dec 30 19:04:42 2012 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:2
((ticks_left() < 5000) || (seconds_left() < 2)) && suspend(0);
.
#9:3
{specifier} = args;
$private();
if (r = match(specifier, "^%([0-9]+%.[0-9]+%.[0-9]+%),%([_a-zA-Z0-9]+%)$"))
version = specifier[r[3][1][1]..r[3][1][2]];
identifier = specifier[r[3][2][1]..r[3][2][2]];
return {identifier, version};
else
raise(E_INVARG, tostr("Invalid package specifier:  ", specifier));
endif
.
#9:4
{operation} = args;
$private();
if (r = match(operation, "^%(<=%|>=%|<%|>%|=%)? *%([0-9]+%)?%(%.%([0-9]+%)%)?%(%.%([0-9]+%)%)?$"))
op = operation[r[3][1][1]..r[3][1][2]] || "=";
major = operation[r[3][2][1]..r[3][2][2]];
minor = operation[r[3][4][1]..r[3][4][2]];
build = operation[r[3][6][1]..r[3][6][2]];
return {op, major, minor, build};
else
raise(E_INVARG, tostr("Invalid operation:  ", operation));
endif
.
#9:5
{version} = args;
$private();
if (r = match(version, "^%([0-9]+%)%(%.%([0-9]+%)%)%(%.%([0-9]+%)%)$"))
major = version[r[3][1][1]..r[3][1][2]];
minor = version[r[3][3][1]..r[3][3][2]];
build = version[r[3][5][1]..r[3][5][2]];
return {major, minor, build};
else
raise(E_INVARG, tostr("Invalid version:  ", version));
endif
.
#9:6
{ver1, ver2} = args;
$private();
res = 0;
if (ver1[1] && ver2[1])
if (((!(res = toint(ver1[1]) - toint(ver2[1]))) && ver1[2]) && ver2[2])
if (((!(res = toint(ver1[2]) - toint(ver2[2]))) && ver1[3]) && ver2[3])
res = toint(ver1[3]) - toint(ver2[3]);
endif
endif
endif
return res;
.
#9:7
{vers} = args;
$private();
l = length(vers);
i = 1;
while (i <= l)
v = vers[i];
j = i - 1;
while (j > 0)
if (this:_compare_versions(vers[j], v) >= 0)
break;
endif
vers[j + 1] = vers[j];
j = j - 1;
endwhile
vers[j + 1] = v;
i = i + 1;
endwhile
return vers;
.
#9:8
{identifier, @args} = args;
if (args && (typeof(args[$]) == MAP))
patterns = args[1..$ - 1];
provides = args[$];
else
patterns = args;
provides = this.provides_cache;
endif
if ((patterns && (length(patterns) == 1)) && (typeof(patterns[1]) == LIST))
patterns = patterns[1];
endif
if ((versions = `provides[identifier] ! E_RANGE => $nothing') == $nothing)
return {$failed_match};
endif
operations = {};
for pattern in (patterns)
this:_suspend_if_necessary();
operations = {@operations, this:_parse_operation(pattern)};
endfor
for _, version in (versions)
this:_suspend_if_necessary();
v1 = this:_parse_version(version);
for operation in (operations)
this:_suspend_if_necessary();
{op, @v2} = operation;
if (((((("=" == op) && this:_compare_versions(v1, v2)) || ((">=" == op) && (this:_compare_versions(v1, v2) < 0))) || (("<=" == op) && (this:_compare_versions(v1, v2) > 0))) || ((">" == op) && (this:_compare_versions(v1, v2) <= 0))) || (("<" == op) && (this:_compare_versions(v1, v2) >= 0)))
versions = mapdelete(versions, version);
break;
endif
endfor
endfor
if (length(versions) < 1)
return {$failed_match};
elseif (length(versions) > 1)
return {$ambiguous_match};
else
version = mapkeys(versions)[1];
object = mapvalues(versions)[1][1];
return {object, identifier, version};
endif
.
#9:9
{MAP, specifier, object} = args;
$private();
if (typeof(specifier) == LIST)
{identifier, version} = specifier;
else
{identifier, version} = this:_parse_specifier(specifier);
endif
(identifier in mapkeys(MAP)) || (MAP[identifier] = []);
(version in mapkeys(MAP[identifier])) || (MAP[identifier][version] = {});
MAP[identifier][version] = setadd(MAP[identifier][version], object);
return MAP;
.
#9:10
{MAP, specifier, object} = args;
$private();
if (typeof(specifier) == LIST)
{identifier, version} = specifier;
else
{identifier, version} = this:_parse_specifier(specifier);
endif
((identifier in mapkeys(MAP)) && (version in mapkeys(MAP[identifier]))) && (MAP[identifier][version] = setremove(MAP[identifier][version], object));
`MAP[identifier][version] ! E_RANGE => 1' || (MAP[identifier] = mapdelete(MAP[identifier], version));
`MAP[identifier] ! E_RANGE => 1' || (MAP = mapdelete(MAP, identifier));
return MAP;
.
#9:11
{identifier, version, object} = args;
$private();
this.packages = setadd(this.packages, object);
this.provides_cache = this:_map_specifier(this.provides_cache, {identifier, version}, object);
for provides in (`object.provides ! E_INVIND, E_TYPE, E_PROPNF => {}')
this.provides_cache = this:_map_specifier(this.provides_cache, provides, object);
endfor
for requires in (`object.requires ! E_INVIND, E_TYPE, E_PROPNF => {}')
provider = this:_match(@requires, this.provides_cache);
this.requires_cache = this:_map_specifier(this.requires_cache, provider[2..3], object);
endfor
.
#9:12
{identifier, version, object} = args;
$private();
this.packages = setremove(this.packages, object);
this.provides_cache = this:_unmap_specifier(this.provides_cache, {identifier, version}, object);
for provides in (`object.provides ! E_INVIND, E_TYPE, E_PROPNF => {}')
this.provides_cache = this:_unmap_specifier(this.provides_cache, provides, object);
endfor
for requires in (`object.requires ! E_INVIND, E_TYPE, E_PROPNF => {}')
provider = this:_find_requires_provider(requires[1], object);
this.requires_cache = this:_unmap_specifier(this.requires_cache, provider[2..3], object);
endfor
.
#9:13
{identifier, object} = args;
$private();
for _, version in (this.requires_cache[identifier])
if (object in this.requires_cache[identifier][version])
return {this.provides_cache[identifier][version][1], identifier, version};
endif
endfor
.
#9:14
$permit("wizard");
objects = (args && (typeof(args[1]) == LIST)) ? args[1] | args;
packages_backup = this.packages;
requires_cache_backup = this.requires_cache;
provides_cache_backup = this.provides_cache;
this.packages = {};
this.requires_cache = [];
this.provides_cache = [];
try
for object in (objects)
this:_install(object.identifier, object.version, object);
endfor
except ex (ANY)
this.packages = packages_backup;
this.requires_cache = requires_cache_backup;
this.provides_cache = provides_cache_backup;
raise(@ex[1..3]);
endtry
return;
"$permit(\"wizard\");";
"";
"/* Reinitializes the package caches from the specified list of";
" * packages.";
" */";
"";
"objects = (args && typeof(args[1]) == LIST) ? args[1] | args;";
"";
"packages_backup = this.packages;";
"requires_cache_backup = this.requires_cache;";
"provides_cache_backup = this.provides_cache;";
"";
"this.packages = {};";
"this.requires_cache = [];";
"this.provides_cache = [];";
"";
"try";
"  for object in (objects)";
"    this:_install(object.identifier, object.version, object);";
"  endfor";
"except ex (ANY)";
"  this.packages = packages_backup;";
"  this.requires_cache = requires_cache_backup;";
"  this.provides_cache = provides_cache_backup;";
"  /* can't re-raise, unfortunately... */";
"  raise(@ex[1..3]);";
"endtry";
"";
"chunk_length:27";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:CB7DD7B8F4FFA9D71A17E484D5F0E2D9A7438C8B";
"state:clean";
"updated_at:Thu Dec 20 08:22:23 2012 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:15
{required} = args;
$private();
for selector in (required)
object = this:_match(@selector, this.provides_cache)[1];
if (valid(object))
required = setremove(required, selector);
endif
endfor
return required;
.
#9:16
{provided} = args;
$private();
for package in (provided)
{identifier, version} = package;
object = `this.requires_cache[identifier][version][1] ! E_RANGE => $failed_match';
if (!valid(object))
provided = setremove(provided, package);
endif
endfor
return provided;
.
#9:17
$private();
{specifiers} = args;
global = {};
for specifier in (specifiers)
this:_suspend_if_necessary();
{package, ?identifier, ?version} = this:_match(@specifier, this.provides_cache);
if ($failed_match == package)
raise(E_INVARG, tostr("Failed match:  ", toliteral(specifier)));
elseif ($ambiguous_match == package)
raise(E_INVARG, tostr("Ambiguous match:  ", toliteral(specifier)));
endif
for item in (`package.manifest ! E_PROPNF => {}')
{object, label} = item;
global = {@global, {object, tostr(label, "|", identifier)}};
endfor
endfor
global = {@global, {$nothing, "__nothing__"}};
return global;
return;
"$private();";
"";
"{specifiers} = args;";
"";
"/*";
" * Take a list of package specifiers, ensure that the specified";
" * packages are present/installed, and generate a mapping between";
" * objects and identifiers based on the information in each";
" * package manifest.";
" *";
" * $nothing maps to \"__nothing__\", and is included for free.";
" */";
"";
"global = {};";
"";
"for specifier in (specifiers)";
"  this:_suspend_if_necessary();";
"  {package, ?identifier, ?version} = this:_match(@specifier, this.provides_cache);";
"  if ($failed_match == package)";
"    raise(E_INVARG, tostr(\"Failed match:  \", toliteral(specifier)));";
"  elseif ($ambiguous_match == package)";
"    raise(E_INVARG, tostr(\"Ambiguous match:  \", toliteral(specifier)));";
"  endif";
"  for item in (`package.manifest ! E_PROPNF => {}')";
"    {object, label} = item;";
"    global = {@global, {object, tostr(label, \"|\", identifier)}};";
"  endfor";
"endfor";
"";
"global = {@global, {$nothing, \"__nothing__\"}};";
"";
"return global;";
"";
"chunk_length:32";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:D230EE830DC6DADFDA69CF0E029566BDD9C2AFDF";
"state:clean";
"updated_at:Sun Dec 30 13:18:21 2012 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:18
$private();
{specifiers} = args;
global = {};
for specifier in (specifiers)
this:_suspend_if_necessary();
{package, ?identifier, ?version} = this:_match(@specifier, this.provides_cache);
if ($failed_match == package)
raise(E_INVARG, tostr("Failed match:  ", toliteral(specifier)));
elseif ($ambiguous_match == package)
raise(E_INVARG, tostr("Ambiguous match:  ", toliteral(specifier)));
endif
for item in (`package.manifest ! E_PROPNF => {}')
{object, label} = item;
global = {@global, {tostr(label, "|", identifier), object}};
endfor
endfor
global = {@global, {"__nothing__", $nothing}};
return global;
return;
"$private();";
"";
"{specifiers} = args;";
"";
"/*";
" * Take a list of package specifiers, ensure that the specified";
" * packages are present/installed, and generate a mapping between";
" * identifiers and objects based on the information in each";
" * package manifest.";
" *";
" * \"__nothing__\" maps to $nothing, and is included for free.";
" */";
"";
"global = {};";
"";
"for specifier in (specifiers)";
"  this:_suspend_if_necessary();";
"  {package, ?identifier, ?version} = this:_match(@specifier, this.provides_cache);";
"  if ($failed_match == package)";
"    raise(E_INVARG, tostr(\"Failed match:  \", toliteral(specifier)));";
"  elseif ($ambiguous_match == package)";
"    raise(E_INVARG, tostr(\"Ambiguous match:  \", toliteral(specifier)));";
"  endif";
"  for item in (`package.manifest ! E_PROPNF => {}')";
"    {object, label} = item;";
"    global = {@global, {tostr(label, \"|\", identifier), object}};";
"  endfor";
"endfor";
"";
"global = {@global, {\"__nothing__\", $nothing}};";
"";
"return global;";
"";
"chunk_length:32";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:24DDBE3F1CE3D27790AA712723A575665F37AA31";
"state:clean";
"updated_at:Sun Dec 30 17:52:10 2012 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:19
{verb, LIST, @options} = args;
$private();
for i in [1..length(LIST)]
this:_suspend_if_necessary();
LIST[i] = this:(verb)(LIST[i], @options);
endfor
return LIST;
.
#9:20
$private();
{collection, index} = args;
if (typeof(collection) == MAP)
return collection[index];
else
for item in (collection)
if (item[1] == index)
return item[2];
endif
endfor
endif
return E_RANGE;
return;
"$private();";
"";
"{collection, index} = args;";
"";
"if (typeof(collection) == MAP)";
"  return collection[index];";
"else";
"  for item in (collection)";
"    if (item[1] == index)";
"      return item[2];";
"    endif";
"  endfor";
"endif";
"";
"return E_RANGE;";
"";
"chunk_length:15";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:CB252079DCCFB98DF55C376BD0BA7DB8471DDE94";
"state:clean";
"updated_at:Fri Dec 28 20:48:25 2012 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:21
$private();
{object, global, local, package, ?target = ""} = args;
if (typeof(object) == LIST)
return this:_map(verb, @args);
endif
if ((ret = this:_lookup(local, object)) != E_RANGE)
return ret;
elseif ((ret = this:_lookup(global, object)) != E_RANGE)
return ret;
elseif (`object.wizard ! E_INVIND')
return "__wizard__";
elseif (object == caller_perms())
return "__owner__";
elseif (object == package)
return "__package__";
endif
if (target)
raise(E_INVARG, tostr("Lookup failed for:  ", object, " on ", target));
else
raise(E_INVARG, tostr("Lookup failed for:  ", object));
endif
return;
"$private();";
"";
"{object, global, local, package, ?target = \"\"} = args;";
"";
"/* Given an object look up the corresponding reference/label. */";
"";
"if (typeof(object) == LIST)";
"  return this:_map(verb, @args);";
"endif";
"";
"if ((ret = this:_lookup(local, object)) != E_RANGE)";
"  return ret;";
"elseif ((ret = this:_lookup(global, object)) != E_RANGE)";
"  return ret;";
"elseif (`object.wizard ! E_INVIND')";
"  return \"__wizard__\";";
"elseif (object == caller_perms())";
"  return \"__owner__\";";
"elseif (object == package)";
"  return \"__package__\";";
"endif";
"";
"if (target)";
"  raise(E_INVARG, tostr(\"Lookup failed for:  \", object, \" on \", target));";
"else";
"  raise(E_INVARG, tostr(\"Lookup failed for:  \", object));";
"endif";
"";
"chunk_length:27";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:6F6CE157CEC9A11B4A52B217E159ECA43AD57D69";
"state:clean";
"updated_at:Tue Jan  1 14:12:47 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:22
$private();
{label, global, local, package} = args;
if (typeof(label) == LIST)
return this:_map(verb, @args);
endif
if ("__nothing__" == label)
return this:_lookup(global, "__nothing__");
elseif ("__wizard__" == label)
return caller_perms();
elseif ("__owner__" == label)
return caller_perms();
elseif ("__package__" == label)
return package;
elseif (r = match(label, "^%([a-z_][a-z0-9_]*%)%(|%([a-z][a-z0-9_]*%)%)?$"))
reference = label[r[3][1][1]..r[3][1][2]];
identifier = label[r[3][3][1]..r[3][3][2]];
if (reference && identifier)
if ((ret = this:_lookup(global, label)) != E_RANGE)
return ret;
endif
else
if ((ret = this:_lookup(local, label)) != E_RANGE)
return ret;
endif
endif
endif
raise(E_INVARG, tostr("Lookup failed for:  ", toliteral(label)));
return;
"$private();";
"";
"{label, global, local, package} = args;";
"";
"/* Given a reference/label look up the corresponding object. */";
"";
"if (typeof(label) == LIST)";
"  return this:_map(verb, @args);";
"endif";
"";
"if (\"__nothing__\" == label)";
"  return this:_lookup(global, \"__nothing__\");";
"elseif (\"__wizard__\" == label)";
"  return caller_perms();";
"elseif (\"__owner__\" == label)";
"  return caller_perms();";
"elseif (\"__package__\" == label)";
"  return package;";
"elseif (r = match(label, \"^%([a-z_][a-z0-9_]*%)%(|%([a-z][a-z0-9_]*%)%)?$\"))";
"  reference = label[r[3][1][1]..r[3][1][2]];";
"  identifier = label[r[3][3][1]..r[3][3][2]];";
"  if (reference && identifier)";
"    if ((ret = this:_lookup(global, label)) != E_RANGE)";
"      return ret;";
"    endif";
"  else";
"    if ((ret = this:_lookup(local, label)) != E_RANGE)";
"      return ret;";
"    endif";
"  endif";
"endif";
"";
"raise(E_INVARG, tostr(\"Lookup failed for:  \", toliteral(label)));";
"";
"chunk_length:33";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:DCE8E6339CD12567ED1B5C7E3B3694E167F80CAE";
"state:clean";
"updated_at:Tue Jan  1 14:12:55 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:23
{subject, target, MAP} = args;
$private();
keys = mapkeys(MAP);
stack = {target};
while (stack)
this:_suspend_if_necessary();
{target, @stack} = stack;
if (target in keys)
parents = `MAP[target]["Attributes"]["parents"]["Value"]["value"] ! E_RANGE => "__nothing__"';
if (typeof(parents) == LIST)
if (subject in parents)
return 1;
else
stack = {@parents, @stack};
endif
else
if (subject == parents)
return 1;
else
stack = {parents, @stack};
endif
endif
endif
endwhile
return 0;
.
#9:24
{object} = args;
$private();
objects = {};
if (valid(object))
stack = {object};
while (stack)
top = stack[1];
stack = {@top.contents, @stack[2..$]};
objects = {@objects, top};
endwhile
endif
return objects;
.
#9:25
$permit("wizard");
`{package, @options} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  package, @options")';
if (options)
if (typeof(options[1]) != MAP)
{?identifier, ?version, ?options = []} = options;
else
options = options[1];
endif
endif
try
identifier;
version;
except (E_VARNF)
identifier = package.identifier;
version = package.version;
endtry
(!valid(package.location)) || raise(E_INVARG, "Not in $nothing");
(package in this.packages) && raise(E_INVARG, "Package is already installed");
provides = `package.provides ! E_PROPNF => {}';
provides = {{identifier, version}, @provides};
for p in (provides)
{id, v} = p;
valid(this:_match(id, v)[1]) && raise(E_INVARG, tostr("Package is already installed:  identifier = ", id, ", version = ", v));
endfor
requires = `package.requires ! E_PROPNF => {}';
(requires = this:_check_required_provides(requires)) && raise(E_INVARG, tostr("Package requires:  ", toliteral(requires)));
errors = [];
if (respond_to(package, "before_install"))
try
package:before_install();
except ex (ANY)
errors["before_install"] = ex;
endtry
endif
if (`options["follow-instructions"] ! ANY')
this:_do_instructions(identifier, version, package);
endif
this:_install(identifier, version, package);
if (respond_to(package, "after_install"))
try
package:after_install();
except ex (ANY)
errors["after_install"] = ex;
endtry
endif
return errors || 0;
.
#9:26
$permit("wizard");
`{identifier, version, ?options = []} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  identifier, version, ?options")';
valid(object = this:_match(identifier, version)[1]) || raise(E_INVARG, tostr("Package is not installed:  identifier = ", identifier, ", version = ", version));
provides = `object.provides ! E_PROPNF => {}';
provides = {{identifier, version}, @provides};
(provides = this:_check_provided_requires(provides)) && raise(E_INVARG, tostr("Package provides:  ", toliteral(provides)));
errors = [];
if (respond_to(object, "before_uninstall"))
try
object:before_uninstall();
except ex (ANY)
errors["before_uninstall"] = ex;
endtry
endif
if (`options["follow-instructions"] ! ANY')
this:_undo_instructions(identifier, version, object);
endif
this:_uninstall(identifier, version, object);
if (respond_to(object, "after_uninstall"))
try
object:after_uninstall();
except ex (ANY)
errors["after_uninstall"] = ex;
endtry
endif
return errors || 0;
.
#9:27
args || raise(E_ARGS);
packages = this.packages;
set_task_perms(caller_perms());
if (((t = typeof(args[1])) == OBJ) || (t == ANON))
{object, ?options = []} = args;
identifier = version = "";
else
{identifier, version, ?options = []} = args;
object = this:_match(identifier, version)[1];
(object == $failed_match) && raise(E_INVARG, tostr("Package is not installed:  identifier = ", identifier, ", version = ", version));
endif
(object == $lookup("__package__")) && raise(E_INVARG, tostr("Can't delete privileged package:  identifier = ", object.identifier, ", version = ", object.version));
p = caller_perms();
while (valid(p))
(p == object) && raise(E_INVARG, tostr(caller_perms(), " is/is inside of ", object));
p = p.location;
endwhile
errors = [];
if (object in packages)
identifier = identifier || object.identifier;
version = version || object.version;
provides = {{identifier, version}};
(provides = this:_check_provided_requires(provides)) && raise(E_INVARG, tostr("Package provides:  ", toliteral(provides)));
if (valid(object) && respond_to(object, "before_uninstall"))
try
object:before_uninstall();
except ex (ANY)
errors["before_uninstall"] = ex;
endtry
endif
if (`options["follow-instructions"] ! ANY')
this:_undo_instructions(identifier, version, object);
endif
this:_uninstall(identifier, version, object);
if (valid(object) && respond_to(object, "after_uninstall"))
try
object:after_uninstall();
except ex (ANY)
errors["after_uninstall"] = ex;
endtry
endif
endif
if (valid(object))
for item in (this:_contents(object))
`recycle(item) ! ANY => 0';
endfor
endif
return errors || 0;
.
#9:28
$private();
bg_seconds = $server_options.bg_seconds;
bg_ticks = $server_options.bg_ticks;
$server_options.bg_seconds = 60 * 60;
$server_options.bg_ticks = (1024 * 1024) * 1024;
suspend(0);
return {bg_seconds, bg_ticks};
.
#9:29
$private();
{args} = args;
{bg_seconds, bg_ticks} = args;
$server_options.bg_seconds = bg_seconds;
$server_options.bg_ticks = bg_ticks;
.
#9:30
{package} = args;
set_task_perms(caller_perms());
try
configuration = package["Configuration"];
version = configuration["version"];
top = configuration["top"];
objects = package["Objects"];
objects[top];
except ex (E_TYPE, E_RANGE)
raise(E_INVARG, "Incompatible package format");
endtry
(version in {"0.1", "0.2"}) || raise(E_INVARG, "Unsupported package version");
anonymous = (version == "0.2") ? configuration["anonymous"] | {};
requires = `objects[top]["Values"]["requires"]["Value"]["value"] ! E_RANGE => {}';
manifest = `objects[top]["Values"]["manifest"]["Value"]["value"] ! E_RANGE => {}';
relocate = `objects[top]["Values"]["relocate"]["Value"]["value"] ! E_RANGE => {}';
(missing = this:_check_required_provides(requires)) && raise(E_INVARG, tostr("Package requires:  ", toliteral(missing)));
global = this:_generate_global_mapping_keyed_on_identifier(requires);
labels = {};
mapkeys_objects = mapkeys(objects);
for label in (manifest)
(label in mapkeys_objects) || raise(E_INVARG, tostr("Invalid value in `manifest':  ", label));
labels = setadd(labels, label);
endfor
for label in (mapkeys_objects)
labels = setadd(labels, label);
endfor
unsorted = labels;
labels = {};
for label in (unsorted)
i = 1;
for target in (labels)
if (this:_is_ancestor(label, target, objects))
break;
endif
i = i + 1;
endfor
labels = {@labels[1..i - 1], label, @labels[i..$]};
endfor
success = 0;
try
local = {};
locations = [];
local = {@local, {top, top_object = create($nothing, top in anonymous)}};
for label in (setremove(labels, top))
this:_suspend_if_necessary();
local = {@local, {label, object = create($nothing, label in anonymous)}};
this:_move(object, top_object);
endfor
relocate_map = [];
for reference in (relocate)
this:_suspend_if_necessary();
if (r = match(reference, "^%([a-z_][a-z0-9_]*%)%.%([a-z_][a-z0-9_]*%)$"))
r1 = reference[r[3][1][1]..r[3][1][2]];
r2 = reference[r[3][2][1]..r[3][2][2]];
if (!(r2 in {"owner", "parents", "location"}))
(r1 in mapkeys(relocate_map)) || (relocate_map[r1] = {});
relocate_map[r1] = {@relocate_map[r1], r2};
endif
else
raise(E_INVARG, tostr("Invalid reference in `relocate':  ", reference));
endif
endfor
for label in (labels)
this:_suspend_if_necessary();
object = this:_lookup(local, label);
definition = objects[label];
if (`definition["Values"]["owner"] ! E_RANGE' != E_RANGE)
if (caller_perms().wizard)
definition["Values"]["owner"]["Value"]["value"] = this:_lookup_by_label(definition["Values"]["owner"]["Value"]["value"], global, local, top_object);
else
definition["Values"] = mapdelete(definition["Values"], "owner");
endif
endif
if (`definition["Attributes"]["parents"] ! E_RANGE' != E_RANGE)
definition["Attributes"]["parents"]["Value"]["value"] = this:_lookup_by_label(definition["Attributes"]["parents"]["Value"]["value"], global, local, top_object);
endif
if (`definition["Values"]["location"] ! E_RANGE' != E_RANGE)
locations[label] = definition["Values"]["location"]["Value"]["value"];
definition["Values"] = mapdelete(definition["Values"], "location");
endif
if (`relocate_map[label] ! E_RANGE => 0')
for name in (relocate_map[label])
this:_suspend_if_necessary();
if (`definition["Values"][name]["Value"]["value"] ! E_RANGE => 0')
definition["Values"][name]["Value"]["value"] = this:_lookup_by_label(definition["Values"][name]["Value"]["value"], global, local, top_object);
else
for property in (definition["Properties"])
this:_suspend_if_necessary();
if (property["Property"]["name"] == name)
value = this:_lookup_by_label(property["Property"]["value"], global, local, top_object);
definition["Values"][name] = ["Value" -> ["value" -> value]];
endif
endfor
endif
endfor
endif
for _, value in (definition["Values"])
this:_suspend_if_necessary();
if (`definition["Values"][value]["Value"]["owner"] ! E_RANGE' != E_RANGE)
if (caller_perms().wizard)
definition["Values"][value]["Value"]["owner"] = this:_lookup_by_label(definition["Values"][value]["Value"]["owner"], global, local, top_object);
else
definition["Values"][value]["Value"] = mapdelete(definition["Values"][value]["Value"], "owner");
endif
endif
endfor
for index in [1..length(definition["Verbs"])]
this:_suspend_if_necessary();
if (`definition["Verbs"][index]["Verb"]["owner"] ! E_RANGE' != E_RANGE)
if (caller_perms().wizard)
definition["Verbs"][index]["Verb"]["owner"] = this:_lookup_by_label(definition["Verbs"][index]["Verb"]["owner"], global, local, top_object);
else
definition["Verbs"][index]["Verb"] = mapdelete(definition["Verbs"][index]["Verb"], "owner");
endif
endif
endfor
for index in [1..length(definition["Properties"])]
this:_suspend_if_necessary();
if (`definition["Properties"][index]["Property"]["owner"] ! E_RANGE' != E_RANGE)
if (caller_perms().wizard)
definition["Properties"][index]["Property"]["owner"] = this:_lookup_by_label(definition["Properties"][index]["Property"]["owner"], global, local, top_object);
else
definition["Properties"][index]["Property"] = mapdelete(definition["Properties"][index]["Property"], "owner");
endif
endif
endfor
definition = $shapes:write_object(object, definition, ["verbs" -> ["do-not-version" -> 1, "do-not-stamp" -> 1]]);
objects[label] = definition;
package["Objects"] = objects;
endfor
for label in (labels)
this:_suspend_if_necessary();
if ("Error" in mapkeys(package["Objects"][label]))
raise("E_PACKAGE", "Error in package operation", package);
endif
endfor
for label in (labels)
this:_suspend_if_necessary();
if (label != top)
object = this:_lookup(local, label);
value = `locations[label] ! E_RANGE => "__package__"';
value = (value == "__package__") ? top_object | this:_lookup(local, value);
this:_move(object, value);
endif
endfor
for entry in [1..`length(top_object.manifest) ! E_PROPNF => 0']
this:_suspend_if_necessary();
top_object.manifest[entry] = {this:_lookup(local, top_object.manifest[entry]), top_object.manifest[entry]};
endfor
success = 1;
finally
success || this:delete(top_object);
endtry
return top_object;
.
#9:31
{package, ?options = []} = args;
set_task_perms(caller_perms());
strip = `options["strip"] ! E_RANGE => {}';
truncate = `options["truncate"] ! E_RANGE => {}';
`valid(package) ! E_TYPE => 0' || raise(E_INVARG, "Not a valid package");
(!valid(package.location)) || raise(E_INVARG, "Not a valid package:  must not have a location");
requires = `package.requires ! E_PROPNF => {}';
manifest = `package.manifest ! E_PROPNF => {}';
relocate = `package.relocate ! E_PROPNF => {}';
objects = this:_contents(package);
for item in (manifest)
{object, label} = item;
`valid(object) ! E_TYPE' || raise(E_INVARG, tostr("Invalid object in manifest:  ", label));
(caller_perms().wizard || (package.owner == object.owner)) || raise(E_PERM, tostr("Invalid object in manifest:  ", label));
objects = setadd(objects, object);
endfor
definition = ["Configuration" -> ["Version" -> "0.2"], "Objects" -> []];
(missing = this:_check_required_provides(requires)) && raise(E_INVARG, tostr("Package requires:  ", toliteral(missing)));
global = this:_generate_global_mapping_keyed_on_object(requires);
for key in (`mapkeys(options["global"]) ! E_RANGE => {}')
this:_suspend_if_necessary();
global = {@global, {key, options["global"][key]}};
endfor
local = {};
anonymous = {};
for object in (objects)
this:_suspend_if_necessary();
if ((t = typeof(object)) == OBJ)
label = tostr("__", toint(object), "__");
else
label = tostr("__", random(), "__");
endif
if (object == package)
label = "__package__";
endif
for entry in (manifest)
if (entry[1] == object)
label = entry[2];
break;
endif
endfor
local = {@local, {object, label}};
if (t == ANON)
anonymous = {@anonymous, label};
endif
definition["Objects"][label] = $shapes:read_object(object, ["strip_clear_values" -> 1]);
if (object in strip)
values = [];
for name in ({"name", "owner", "location", "programmer", "wizard", "r", "w", "f", "a"})
values[name] = definition["Objects"][label]["Values"][name];
endfor
for index in [1..length(definition["Objects"][label]["Properties"])]
name = definition["Objects"][label]["Properties"][index]["property"]["name"];
values[name] = definition["Objects"][label]["Values"][name];
endfor
definition["Objects"][label]["Values"] = values;
endif
endfor
top = definition["Configuration"]["top"] = this:_lookup(local, package);
definition["Configuration"]["anonymous"] = anonymous;
labels = {};
for entry in (manifest)
this:_suspend_if_necessary();
labels = {@labels, entry[2]};
endfor
for object in (objects)
this:_suspend_if_necessary();
label = this:_lookup(local, object);
for _, v in (definition["Objects"][label]["Values"])
this:_suspend_if_necessary();
if (`"owner" in mapkeys(definition["Objects"][label]["Values"][v]["Value"]) ! E_RANGE')
definition["Objects"][label]["Values"][v]["Value"]["owner"] = this:_lookup_by_object(definition["Objects"][label]["Values"][v]["Value"]["owner"], global, local, package, label);
endif
endfor
for i in [1..length(definition["Objects"][label]["Properties"])]
this:_suspend_if_necessary();
definition["Objects"][label]["Properties"][i]["Property"]["owner"] = this:_lookup_by_object(definition["Objects"][label]["Properties"][i]["Property"]["owner"], global, local, package, label);
endfor
for i in [1..length(definition["Objects"][label]["Verbs"])]
this:_suspend_if_necessary();
definition["Objects"][label]["Verbs"][i]["Verb"]["owner"] = this:_lookup_by_object(definition["Objects"][label]["Verbs"][i]["Verb"]["owner"], global, local, package, label);
endfor
if ("owner" in mapkeys(definition["Objects"][label]["Values"]))
definition["Objects"][label]["Values"]["owner"]["Value"]["value"] = this:_lookup_by_object(definition["Objects"][label]["Values"]["owner"]["Value"]["value"], global, local, package, label);
endif
definition["Objects"][label]["Attributes"]["parents"]["Value"]["value"] = this:_lookup_by_object(definition["Objects"][label]["Attributes"]["parents"]["Value"]["value"], global, local, package, label);
definition["Objects"][label]["Values"]["location"]["Value"]["value"] = this:_lookup_by_object(definition["Objects"][label]["Values"]["location"]["Value"]["value"], global, local, package, label);
endfor
for reference in (relocate)
this:_suspend_if_necessary();
if (r = match(reference, "^%([a-z_][a-z0-9_]*%)%.%([a-z_][a-z0-9_]*%)$"))
r1 = reference[r[3][1][1]..r[3][1][2]];
r2 = reference[r[3][2][1]..r[3][2][2]];
if (r1 in labels)
if (((r2 != "parents") && (r2 != "location")) && (r2 != "owner"))
try
definition["Objects"][r1]["Values"][r2]["Value"]["value"];
except (E_RANGE)
raise(E_INVARG, tostr("Invalid reference in `relocate':  \"", r2, "\" in \"", reference, "\""));
endtry
definition["Objects"][r1]["Values"][r2]["Value"]["value"] = this:_lookup_by_object(definition["Objects"][r1]["Values"][r2]["Value"]["value"], global, local, package, r1);
for property in [1..length(definition["Objects"][r1]["Properties"])]
this:_suspend_if_necessary();
if (definition["Objects"][r1]["Properties"][property]["Property"]["name"] == r2)
definition["Objects"][r1]["Properties"][property]["Property"]["value"] = definition["Objects"][r1]["Values"][r2]["Value"]["value"];
break property;
endif
endfor
endif
else
raise(E_INVARG, tostr("Invalid reference in `relocate':  \"", r1, "\" in \"", reference, "\""));
endif
else
raise(E_INVARG, tostr("Invalid reference in `relocate':  ", reference));
endif
endfor
for object in (truncate)
this:_suspend_if_necessary();
if (object in objects)
label = this:_lookup(local, object);
values = [];
for _, value in (definition["Objects"][label]["Values"])
this:_suspend_if_necessary();
if (value in {"name", "owner", "location", "programmer", "wizard", "r", "w", "f", "a"})
values[value] = definition["Objects"][label]["Values"][value];
endif
endfor
definition["Objects"][label]["Values"] = values;
endif
endfor
if (("manifest" in mapkeys(definition["Objects"][top]["Values"])) && (!definition["Objects"][top]["Values"]["manifest"]["Value"]["clear"]))
for entry in [1..length(definition["Objects"][top]["Values"]["manifest"]["Value"]["value"])]
this:_suspend_if_necessary();
definition["Objects"][top]["Values"]["manifest"]["Value"]["value"][entry] = definition["Objects"][top]["Values"]["manifest"]["Value"]["value"][entry][2];
endfor
endif
for property in [1..length(definition["Objects"][top]["Properties"])]
this:_suspend_if_necessary();
if (definition["Objects"][top]["Properties"][property]["Property"]["name"] == "manifest")
for entry in [1..length(definition["Objects"][top]["Properties"][property]["Property"]["value"])]
this:_suspend_if_necessary();
definition["Objects"][top]["Properties"][property]["Property"]["value"][entry] = definition["Objects"][top]["Properties"][property]["Property"]["value"][entry][2];
endfor
break;
endif
endfor
return definition;
.
#9:32
$private();
{url} = args;
if (r = match(url, "^http://%([^/:]+%)%(:[0-9]+%)?%(.*%)$"))
host = url[r[3][1][1]..r[3][1][2]];
port = toint(url[r[3][2][1] + 1..r[3][2][2]]) || 80;
path = url[r[3][3][1]..r[3][3][2]];
return {host, port, path};
else
return 0;
endif
return;
"$private();";
"";
"{url} = args;";
"";
"if ((r = match(url, \"^http://%([^/:]+%)%(:[0-9]+%)?%(.*%)$\")))";
"  host = url[r[3][1][1]..r[3][1][2]];";
"  port = toint(url[r[3][2][1] + 1..r[3][2][2]]) || 80;";
"  path = url[r[3][3][1]..r[3][3][2]];";
"  return {host, port, path};";
"else";
"  return 0;";
"endif";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:C8D6E8A9369CE73B1A13EBE02B3990C010133F8D";
"state:clean";
"updated_at:Sat Jan  5 13:26:29 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:33
$private();
{url} = args;
while redirect (1)
try
connection = 0;
url = strsub(url, "~", "~7E");
if (r = this:_parse_url(url))
{host, port, path} = r;
else
raise(E_INVARG, "Bad URL");
endif
try
connection = open_network_connection(host, port);
except (E_INVARG)
raise(E_INVARG, "Open network connection failed");
endtry
set_connection_option(connection, "hold-input", 1);
set_connection_option(connection, "binary", 1);
notify(connection, tostr("GET ", path, " HTTP/1.1~0D~0A"));
notify(connection, (port != 80) ? tostr("Host: ", host, ":", port, "~0D~0A") | tostr("Host: ", host, "~0D~0A"));
notify(connection, "Accept: application/json~0D~0A");
notify(connection, "~0D~0A");
response = read_http("response", connection);
if (`reason = response["error"] ! E_RANGE')
raise(E_INVARG, tostr("Fetch failed: ", reason[2]));
elseif (!((status = response["status"]) in {200, 301, 302, 303, 307}))
raise(E_INVARG, tostr("Fetch failed: invalid HTTP status: ", status));
elseif ((status / 100) == 3)
try
url = response["headers"]["location"];
continue redirect;
except (E_RANGE)
raise(E_INVARG, "Fetch failed: missing HTTP header: Location");
endtry
endif
json = strsub(response["body"], "~7E", "~");
try
return parse_json(json, "embedded-types");
except (E_RANGE, E_INVARG)
raise(E_INVARG, "Bad JSON");
endtry
finally
`boot_player(connection) ! ANY';
endtry
endwhile
return;
"$private();";
"";
"{url} = args;";
"";
"/* Attempt an HTTP connection; handle success, follow redirects and";
" * raise errors on everything else.  Note: this verb is optimized for";
" * fetching package lists/packages, and takes a few short-cuts.  In";
" * particular, it simply uses `strsub()' to encode/decode the MOO";
" * binary string representation of tilde (\"~\"), relying on the fact";
" * that packages _should not have_ any binary (non-printable)";
" * characters in them.";
" */";
"";
"while redirect (1)";
"  try";
"    connection = 0;";
"";
"    url = strsub(url, \"~\", \"~7E\");";
"";
"    if ((r = this:_parse_url(url)))";
"      {host, port, path} = r;";
"    else";
"      raise(E_INVARG, \"Bad URL\");";
"    endif";
"";
"    try";
"      connection = open_network_connection(host, port);";
"    except (E_INVARG)";
"      raise(E_INVARG, \"Open network connection failed\");";
"    endtry";
"";
"    set_connection_option(connection, \"hold-input\", 1);";
"    set_connection_option(connection, \"binary\", 1);";
"";
"    notify(connection, tostr(\"GET \", path, \" HTTP/1.1~0D~0A\"));";
"    notify(connection, (port != 80) ? tostr(\"Host: \", host, \":\", port, \"~0D~0A\") | tostr(\"Host: \", host, \"~0D~0A\"));";
"    notify(connection, \"Accept: application/json~0D~0A\");";
"    notify(connection, \"~0D~0A\");";
"";
"    response = read_http(\"response\", connection);";
"";
"    if (`reason = response[\"error\"] ! E_RANGE')";
"      raise(E_INVARG, tostr(\"Fetch failed: \", reason[2]));";
"    elseif (!((status = response[\"status\"]) in {200, 301, 302, 303, 307}))";
"      raise(E_INVARG, tostr(\"Fetch failed: invalid HTTP status: \", status));";
"    elseif (status / 100 == 3)";
"      try";
"        url = response[\"headers\"][\"location\"];";
"        continue redirect;";
"      except (E_RANGE)";
"        raise(E_INVARG, \"Fetch failed: missing HTTP header: Location\");";
"      endtry";
"    endif";
"";
"    json = strsub(response[\"body\"], \"~7E\", \"~\");";
"";
"    try";
"      return parse_json(json, \"embedded-types\");";
"    except (E_RANGE, E_INVARG)";
"      raise(E_INVARG, \"Bad JSON\");";
"    endtry";
"";
"  finally";
"    `boot_player(connection) ! ANY';";
"  endtry";
"";
"endwhile";
"";
"chunk_length:67";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:4";
"sha1:D83D736F33D7938C27F62A0AD910A718DA0CE0BF";
"state:clean";
"updated_at:Tue Feb 12 06:36:06 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"$private();";
"";
"{url} = args;";
"";
"/* Attempt an HTTP connection, follow redirects and raise errors on";
" * everything else.";
" */";
"";
"while redirect (1)";
"  try";
"    connection = 0;";
"";
"    if ((r = this:_parse_url(url)))";
"      {host, port, path} = r;";
"    else";
"      raise(E_INVARG, \"Bad URL\");";
"    endif";
"";
"    try";
"      connection = open_network_connection(host, port);";
"    except (E_INVARG)";
"      raise(E_INVARG, \"Open network connection failed\");";
"    endtry";
"";
"    set_connection_option(connection, \"hold-input\", 1);";
"    set_connection_option(connection, \"binary\", 1);";
"";
"    notify(connection, tostr(\"GET \", path, \" HTTP/1.1~0D~0A\"));";
"    notify(connection, (port != 80) ? tostr(\"Host: \", host, \":\", port, \"~0D~0A\") | tostr(\"Host: \", host, \"~0D~0A\"));";
"    notify(connection, \"Accept: application/json~0D~0A\");";
"    notify(connection, \"~0D~0A\");";
"";
"    response = read_http(\"response\", connection);";
"";
"    if (`reason = response[\"error\"] ! E_RANGE')";
"      raise(E_INVARG, tostr(\"Fetch failed: \", reason[2]));";
"    elseif (!((status = response[\"status\"]) in {200, 301, 302, 303, 307}))";
"      raise(E_INVARG, tostr(\"Fetch failed: invalid HTTP status: \", status));";
"    elseif (status / 100 == 3)";
"      try";
"        url = response[\"headers\"][\"location\"];";
"        continue redirect;";
"      except (E_RANGE)";
"        raise(E_INVARG, \"Fetch failed: missing HTTP header: Location\");";
"      endtry";
"    endif";
"";
"    try";
"      json = response[\"body\"];";
"      return parse_json(json, \"embedded-types\");";
"    except (E_RANGE, E_INVARG)";
"      raise(E_INVARG, \"Bad JSON\");";
"    endtry";
"";
"  finally";
"    `boot_player(connection) ! ANY';";
"  endtry";
"";
"endwhile";
"";
"chunk_length:59";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:3";
"sha1:54FEEA95E3C2135EDA3DBD5969661EC3A5CD6629";
"state:clean";
"updated_at:Sat Jan  5 13:32:12 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"$private();";
"";
"{host, port, uri} = args;";
"";
"/* Attempt an HTTP connection, follow redirects and raise errors on";
" * everything else.";
" */";
"";
"while redirect (1)";
"  try";
"    connection = 0;";
"";
"    try";
"      connection = open_network_connection(host, port);";
"    except (E_INVARG)";
"      raise(E_INVARG, \"Open network connection failed\");";
"    endtry";
"";
"    set_connection_option(connection, \"hold-input\", 1);";
"    set_connection_option(connection, \"binary\", 1);";
"";
"    notify(connection, tostr(\"GET \", uri, \" HTTP/1.1~0D~0A\"));";
"    notify(connection, (port != 80) ? tostr(\"Host: \", host, \":\", port, \"~0D~0A\") | tostr(\"Host: \", host, \"~0D~0A\"));";
"    notify(connection, \"Accept: application/json~0D~0A\");";
"    notify(connection, \"~0D~0A\");";
"";
"    response = read_http(\"response\", connection);";
"";
"    if (`reason = response[\"error\"] ! E_RANGE')";
"      raise(E_INVARG, tostr(\"Fetch failed: \", reason[2]));";
"    elseif (!((status = response[\"status\"]) in {200, 301, 302, 303, 307}))";
"      raise(E_INVARG, tostr(\"Fetch failed: invalid HTTP status: \", status));";
"    elseif (status / 100 == 3)";
"      location = `response[\"headers\"][\"location\"] ! E_RANGE => \"\"';";
"      if ((r = match(location, \"^http://%([^/:]+%)%(:[0-9]+%)?%(.*%)$\")))";
"        host = location[r[3][1][1]..r[3][1][2]];";
"        port = toint(location[r[3][2][1] + 1..r[3][2][2]]) || 80;";
"        uri = location[r[3][3][1]..r[3][3][2]];";
"        continue redirect;";
"      endif";
"      raise(E_INVARG, \"Fetch failed: bad HTTP header: Location\");";
"    endif";
"";
"    try";
"      json = response[\"body\"];";
"      return parse_json(json, \"embedded-types\");";
"    except (E_RANGE, E_INVARG)";
"      raise(E_INVARG, \"Bad JSON\");";
"    endtry";
"";
"  finally";
"    `boot_player(connection) ! ANY';";
"  endtry";
"";
"endwhile";
"";
"chunk_length:55";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:97C8E331DC4F92BEC2F199B720972E2803C37EB2";
"state:clean";
"updated_at:Sat Jan  5 12:02:07 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"$private();";
"";
"{host, port, uri} = args;";
"";
"host = encode_binary(host);";
"uri = encode_binary(uri);";
"";
"/* Attempt an HTTP connection, follow redirects and raise errors on";
" * everything else.";
" */";
"";
"while redirect (1)";
"  try";
"    connection = 0;";
"";
"    try";
"      connection = open_network_connection(host, port);";
"    except (E_INVARG)";
"      raise(E_INVARG, \"Open network connection failed\");";
"    endtry";
"";
"    set_connection_option(connection, \"hold-input\", 1);";
"    set_connection_option(connection, \"binary\", 1);";
"";
"    notify(connection, tostr(\"GET \", uri, \" HTTP/1.1~0D~0A\"));";
"    notify(connection, (port != 80) ? tostr(\"Host: \", host, \":\", port, \"~0D~0A\") | tostr(\"Host: \", host, \"~0D~0A\"));";
"    notify(connection, \"Accept: application/json~0D~0A\");";
"    notify(connection, \"~0D~0A\");";
"";
"    response = read_http(\"response\", connection);";
"";
"    if (`reason = response[\"error\"] ! E_RANGE')";
"      raise(E_INVARG, tostr(\"Fetch failed: \", reason[2]));";
"    elseif (!((status = response[\"status\"]) in {200, 301, 302, 303, 307}))";
"      raise(E_INVARG, tostr(\"Fetch failed: invalid HTTP status: \", status));";
"    elseif (status / 100 == 3)";
"      location = `response[\"headers\"][\"location\"] ! E_RANGE => \"\"';";
"      if ((r = match(location, \"^http://%([^/:]+%)%(:[0-9]+%)?%(.*%)$\")))";
"        host = location[r[3][1][1]..r[3][1][2]];";
"        port = toint(location[r[3][2][1] + 1..r[3][2][2]]) || 80;";
"        uri = location[r[3][3][1]..r[3][3][2]];";
"        continue redirect;";
"      endif";
"      raise(E_INVARG, \"Fetch failed: bad HTTP header: Location\");";
"    endif";
"";
"    try";
"      json = response[\"body\"];";
"      return parse_json(json, \"embedded-types\");";
"    except (E_RANGE, E_INVARG)";
"      raise(E_INVARG, \"Bad JSON\");";
"    endtry";
"";
"  finally";
"    `boot_player(connection) ! ANY';";
"  endtry";
"";
"endwhile";
"";
"chunk_length:58";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:5738934FBCCFFDE22312A1B902B31C8C41B1F4E3";
"state:clean";
"updated_at:Sat Jan  5 11:03:58 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:34
$permit("wizard");
args && raise(E_ARGS);
packages = [];
sources = this.archive_sources;
while (sources)
source = sources[$];
sources = sources[^..$ - 1];
index = this:_fetch(source);
if (`index["_links"] ! E_RANGE')
for package in (index["_embedded"]["packages"])
mk = mapkeys(package);
if ((("identifier" in mk) && ("version" in mk)) && ("_links" in mk))
if (`href = package["_links"]["self"]["href"] ! E_RANGE')
if (r = this:_parse_url(href))
else
r = this:_parse_url(source);
if (href[1] == "/")
href = tostr("http://", r[1], ":", r[2], href);
else
if (i = rindex(r[3], "/"))
href = tostr("http://", r[1], ":", r[2], r[3][1..i], href);
else
href = tostr("http://", r[1], ":", r[2], "/", href);
endif
endif
endif
identifier = package["identifier"];
version = package["version"];
requires = `package["requires"] ! E_RANGE => {}';
`packages[identifier] ! E_RANGE' || (packages[identifier] = []);
packages[identifier][version] = ["href" -> href, "requires" -> requires];
endif
endif
endfor
else
for package in (index["Packages"])
mk = mapkeys(package);
if ((("identifier" in mk) && ("version" in mk)) && ("link" in mk))
mk = mapkeys(package["link"]);
if ((("uri" in mk) && ("rel" in mk)) && (package["link"]["rel"] == "package"))
uri = package["link"]["uri"];
r = this:_parse_url(source);
if (i = rindex(r[3], "/"))
href = tostr("http://", r[1], ":", r[2], r[3][1..i], uri);
else
href = tostr("http://", r[1], ":", r[2], "/", uri);
endif
identifier = package["identifier"];
version = package["version"];
requires = `package["requires"] ! E_RANGE => {}';
`packages[identifier] ! E_RANGE' || (packages[identifier] = []);
packages[identifier][version] = ["href" -> href, "requires" -> requires];
endif
endif
endfor
endif
endwhile
this.archived = packages;
this.last_fetch_index = time();
return packages;
return;
"$permit(\"wizard\");";
"";
"args && raise(E_ARGS);";
"";
"packages = [];";
"sources = this.archive_sources;";
"";
"while (sources)";
"  source = sources[$];";
"  sources = sources[^..$ - 1];";
"";
"  /* Handle both the old and new index formats.  Look for \"_links\" at";
"   * the top-level to distinguish the two.  See the HAL JSON";
"   * specification for details on the format.";
"   */";
"";
"  index = this:_fetch(source);";
"";
"  if (`index[\"_links\"] ! E_RANGE')";
"    for package in (index[\"_embedded\"][\"packages\"])";
"      mk = mapkeys(package);";
"      if (\"identifier\" in mk && \"version\" in mk && \"_links\" in mk)";
"        if (`href = package[\"_links\"][\"self\"][\"href\"] ! E_RANGE')";
"          if ((r = this:_parse_url(href)))";
"            /* full URL -- use it as is */";
"          else";
"            r = this:_parse_url(source);";
"            if (href[1] == \"/\")              /* absolute URL */";
"              href = tostr(\"http://\", r[1], \":\", r[2], href);";
"            else                             /* relative URL */";
"              if ((i = rindex(r[3], \"/\")))";
"                href = tostr(\"http://\", r[1], \":\", r[2], r[3][1..i], href);";
"              else";
"                href = tostr(\"http://\", r[1], \":\", r[2], \"/\", href);";
"              endif";
"            endif";
"          endif";
"          identifier = package[\"identifier\"];";
"          version = package[\"version\"];";
"          requires = `package[\"requires\"] ! E_RANGE => {}';";
"          `packages[identifier] ! E_RANGE' || (packages[identifier] = []);";
"          packages[identifier][version] = [\"href\" -> href, \"requires\" -> requires];";
"        endif";
"      endif";
"    endfor";
"  else";
"    for package in (index[\"Packages\"])";
"      mk = mapkeys(package);";
"      if (\"identifier\" in mk && \"version\" in mk && \"link\" in mk)";
"        mk = mapkeys(package[\"link\"]);";
"        if (\"uri\" in mk && \"rel\" in mk && package[\"link\"][\"rel\"] == \"package\")";
"          /* old style is relative URLs */";
"          uri = package[\"link\"][\"uri\"];";
"          r = this:_parse_url(source);";
"          if ((i = rindex(r[3], \"/\")))";
"            href = tostr(\"http://\", r[1], \":\", r[2], r[3][1..i], uri);";
"          else";
"            href = tostr(\"http://\", r[1], \":\", r[2], \"/\", uri);";
"          endif";
"          identifier = package[\"identifier\"];";
"          version = package[\"version\"];";
"          requires = `package[\"requires\"] ! E_RANGE => {}';";
"          `packages[identifier] ! E_RANGE' || (packages[identifier] = []);";
"          packages[identifier][version] = [\"href\" -> href, \"requires\" -> requires];";
"        endif";
"      endif";
"    endfor";
"  endif";
"endwhile";
"";
"this.archived = packages;";
"";
"this.last_fetch_index = time();";
"";
"return packages;";
"";
"chunk_length:75";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:5";
"sha1:C11791303321FED3935DA5EF97D97677D6FF650D";
"state:clean";
"updated_at:Sat Jan  5 15:44:06 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"$permit(\"wizard\");";
"";
"args && raise(E_ARGS);";
"";
"packages = [];";
"sources = this.archive_sources;";
"";
"while (sources)";
"  source = sources[$];";
"  sources = sources[^..$ - 1];";
"";
"  /* Handle both the old and new index formats.  Look for \"_links\" at";
"   * the top-level to distinguish the two.  See the HAL JSON";
"   * specification for details on the format.";
"   */";
"";
"  index = this:_fetch(source);";
"";
"  if (`index[\"_links\"] ! E_RANGE')";
"    for package in (index[\"_embedded\"][\"packages\"])";
"      mk = mapkeys(package);";
"      if (\"identifier\" in mk && \"version\" in mk && \"_links\" in mk)";
"        if (`href = package[\"_links\"][\"self\"][\"href\"] ! E_RANGE')";
"          if ((r = this:_parse_url(href)))";
"            /* full URL -- use it as is */";
"          else";
"            r = this:_parse_url(source);";
"            if (href[1] == \"/\")              /* absolute URL */";
"              href = tostr(\"http://\", r[1], \":\", r[2], href);";
"            else                             /* relative URL */";
"              if ((i = rindex(r[3], \"/\")))";
"                href = tostr(\"http://\", r[1], \":\", r[2], r[3][1..i], href);";
"              else";
"                href = tostr(\"http://\", r[1], \":\", r[2], \"/\", href);";
"              endif";
"            endif";
"          endif";
"          identifier = package[\"identifier\"];";
"          version = package[\"version\"];";
"          `packages[identifier] ! E_RANGE' || (packages[identifier] = []);";
"          packages[identifier][version] = [\"href\" -> href];";
"        endif";
"      endif";
"    endfor";
"  else";
"    for package in (index[\"Packages\"])";
"      mk = mapkeys(package);";
"      if (\"identifier\" in mk && \"version\" in mk && \"link\" in mk)";
"        mk = mapkeys(package[\"link\"]);";
"        if (\"uri\" in mk && \"rel\" in mk && package[\"link\"][\"rel\"] == \"package\")";
"          /* old style is relative URLs */";
"          uri = package[\"link\"][\"uri\"];";
"          r = this:_parse_url(source);";
"          if ((i = rindex(r[3], \"/\")))";
"            href = tostr(\"http://\", r[1], \":\", r[2], r[3][1..i], uri);";
"          else";
"            href = tostr(\"http://\", r[1], \":\", r[2], \"/\", uri);";
"          endif";
"          identifier = package[\"identifier\"];";
"          version = package[\"version\"];";
"          `packages[identifier] ! E_RANGE' || (packages[identifier] = []);";
"          packages[identifier][version] = [\"href\" -> href];";
"        endif";
"      endif";
"    endfor";
"  endif";
"endwhile";
"";
"this.archived = packages;";
"";
"this.last_fetch_index = time();";
"";
"return packages;";
"";
"chunk_length:73";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:4";
"sha1:AB5A76F414DE16BAE59F830B349F722A1E16B103";
"state:clean";
"updated_at:Sat Jan  5 15:37:55 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"$permit(\"wizard\");";
"";
"args && raise(E_ARGS);";
"";
"packages = [];";
"sources = this.archive_sources;";
"";
"while (sources)";
"  source = sources[$];";
"  sources = sources[^..$ - 1];";
"";
"  /* Handle both the old and new index formats.  Look for \"_links\" at";
"   * the top-level to distinguish the two.  See the HAL JSON";
"   * specification for details on the format.";
"   */";
"";
"  index = this:_fetch(source);";
"";
"  if (`index[\"_links\"] ! E_RANGE')";
"    for package in (index[\"_embedded\"][\"packages\"])";
"      mk = mapkeys(package);";
"      if (\"identifier\" in mk && \"version\" in mk && \"_links\" in mk)";
"        if (`href = package[\"_links\"][\"self\"][\"href\"] ! E_RANGE')";
"          if ((r = this:_parse_url(href)))";
"            /* full URL -- use it as is */";
"          else";
"            r = this:_parse_url(source);";
"            if (href[1] == \"/\")              /* absolute URL */";
"              href = tostr(\"http://\", r[1], \":\", r[2], href);";
"            else                             /* relative URL */";
"              if ((i = rindex(r[3], \"/\")))";
"                href = tostr(\"http://\", r[1], \":\", r[2], r[3][1..i], href);";
"              else";
"                href = tostr(\"http://\", r[1], \":\", r[2], \"/\", href);";
"              endif";
"            endif";
"          endif";
"          identifier = package[\"identifier\"];";
"          version = package[\"version\"];";
"          `packages[identifier] ! E_RANGE' || (packages[identifier] = []);";
"          packages[identifier][version] = href;";
"        endif";
"      endif";
"    endfor";
"  else";
"    for package in (index[\"Packages\"])";
"      mk = mapkeys(package);";
"      if (\"identifier\" in mk && \"version\" in mk && \"link\" in mk)";
"        mk = mapkeys(package[\"link\"]);";
"        if (\"uri\" in mk && \"rel\" in mk && package[\"link\"][\"rel\"] == \"package\")";
"          /* old style is relative URLs */";
"          uri = package[\"link\"][\"uri\"];";
"          r = this:_parse_url(source);";
"          if ((i = rindex(r[3], \"/\")))";
"            href = tostr(\"http://\", r[1], \":\", r[2], r[3][1..i], uri);";
"          else";
"            href = tostr(\"http://\", r[1], \":\", r[2], \"/\", uri);";
"          endif";
"          identifier = package[\"identifier\"];";
"          version = package[\"version\"];";
"          `packages[identifier] ! E_RANGE' || (packages[identifier] = []);";
"          packages[identifier][version] = href;";
"        endif";
"      endif";
"    endfor";
"  endif";
"endwhile";
"";
"this.archived = packages;";
"";
"this.last_fetch_index = time();";
"";
"return packages;";
"";
"chunk_length:73";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:3";
"sha1:FB5550B69E47603FC52BA559CE4C36E3C46F530B";
"state:clean";
"updated_at:Sat Jan  5 14:37:26 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"$permit(\"wizard\");";
"";
"args && raise(E_ARGS);";
"";
"index = this:_fetch(this.archive_host, this.archive_port, this.archive_base_uri);";
"";
"packages = [];";
"";
"/* Handle both the old and new index formats.  Look for \"_links\" at";
" * the top-level to distinguish the two.  See the HAL JSON";
" * specification for details on the format.";
" */";
"";
"if (`index[\"_links\"] ! E_RANGE')";
"  for package in (index[\"_embedded\"][\"packages\"])";
"    mk = mapkeys(package);";
"    if (\"identifier\" in mk && \"version\" in mk && \"_links\" in mk)";
"      if (`href = package[\"_links\"][\"self\"][\"href\"] ! E_RANGE')";
"        identifier = package[\"identifier\"];";
"        version = package[\"version\"];";
"        `packages[identifier] ! E_RANGE' || (packages[identifier] = []);";
"        packages[identifier][version] = href;";
"      endif";
"    endif";
"  endfor";
"else";
"  for package in (index[\"Packages\"])";
"    mk = mapkeys(package);";
"    if (\"identifier\" in mk && \"version\" in mk && \"link\" in mk)";
"      mk = mapkeys(package[\"link\"]);";
"      if (\"uri\" in mk && \"rel\" in mk && package[\"link\"][\"rel\"] == \"package\")";
"        identifier = package[\"identifier\"];";
"        version = package[\"version\"];";
"        uri = package[\"link\"][\"uri\"];";
"        `packages[identifier] ! E_RANGE' || (packages[identifier] = []);";
"        packages[identifier][version] = uri;";
"      endif";
"    endif";
"  endfor";
"endif";
"";
"this.archived = packages;";
"";
"this.last_fetch_index = time();";
"";
"return packages;";
"";
"chunk_length:46";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:E79EA38FD73A50B9B89B0A457E8AD51312AC2EC5";
"state:clean";
"updated_at:Sat Jan  5 12:05:27 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"$permit(\"wizard\");";
"";
"args && raise(E_ARGS);";
"";
"index = this:_fetch(this.archive_host, this.archive_port, this.archive_base_uri + \"/packages.json\");";
"";
"packages = [];";
"";
"for package in (index[\"Packages\"])";
"  mk = mapkeys(package);";
"  if (\"identifier\" in mk && \"version\" in mk && \"link\" in mk)";
"    mk = mapkeys(package[\"link\"]);";
"    if (\"uri\" in mk && \"rel\" in mk && package[\"link\"][\"rel\"] == \"package\")";
"      identifier = package[\"identifier\"];";
"      version = package[\"version\"];";
"      uri = package[\"link\"][\"uri\"];";
"      `packages[identifier] ! E_RANGE' || (packages[identifier] = []);";
"      packages[identifier][version] = uri;";
"    endif";
"  endif";
"endfor";
"";
"this.archived = packages;";
"";
"this.last_fetch_index = time();";
"";
"return packages;";
"";
"chunk_length:27";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:900BB1080C0E706C414F55287330720890A066E4";
"state:clean";
"updated_at:Wed Jan  2 21:28:44 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:35
$permit("wizard");
`{identifier, version} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  identifier, version")';
package = this:_fetch(this.archived[identifier][version]["href"]);
top = package["Configuration"]["top"];
requires = `package["Objects"][top]["Values"]["requires"]["Value"]["value"] ! E_RANGE => {}';
packages = this.cached;
`packages[identifier] ! E_RANGE' || (packages[identifier] = []);
packages[identifier][version] = ["definition" -> package, "requires" -> requires];
this.cached = packages;
return package;
return;
"$permit(\"wizard\");";
"";
"`{identifier, version} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  identifier, version\")';";
"";
"package = this:_fetch(this.archived[identifier][version][\"href\"]);";
"";
"top = package[\"Configuration\"][\"top\"];";
"";
"requires = `package[\"Objects\"][top][\"Values\"][\"requires\"][\"Value\"][\"value\"] ! E_RANGE => {}';";
"";
"packages = this.cached;";
"";
"`packages[identifier] ! E_RANGE' || (packages[identifier] = []);";
" packages[identifier][version] = [\"definition\" -> package, \"requires\" -> requires];";
"";
"this.cached = packages;";
"";
"return package;";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:4";
"sha1:01C2E9E16C30CD5AD646D51ED98F9427F6BCE58A";
"state:clean";
"updated_at:Sat Jan  5 17:22:53 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"$permit(\"wizard\");";
"";
"`{identifier, version} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  identifier, version\")';";
"";
"package = this:_fetch(this.archived[identifier][version][\"href\"]);";
"";
"packages = this.cached;";
"";
"`packages[identifier] ! E_RANGE' || (packages[identifier] = []);";
" packages[identifier][version] = package;";
"";
"this.cached = packages;";
"";
"return package;";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:3";
"sha1:79F266C70F9EE2234878E450E195B37970235790";
"state:clean";
"updated_at:Sat Jan  5 15:37:55 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"$permit(\"wizard\");";
"";
"`{identifier, version} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  identifier, version\")';";
"";
"package = this:_fetch(this.archived[identifier][version]);";
"";
"packages = this.cached;";
"";
"`packages[identifier] ! E_RANGE' || (packages[identifier] = []);";
" packages[identifier][version] = package;";
"";
"this.cached = packages;";
"";
"return package;";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:0DADBF05E98DE422F76CC5E6A3781F1C747AAF70";
"state:clean";
"updated_at:Sat Jan  5 14:18:44 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"$permit(\"wizard\");";
"";
"`{identifier, version} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  identifier, version\")';";
"";
"package = this:_fetch(this.archive_host, this.archive_port, this.archived[identifier][version]);";
"";
"packages = this.cached;";
"";
"`packages[identifier] ! E_RANGE' || (packages[identifier] = []);";
" packages[identifier][version] = package;";
"";
"this.cached = packages;";
"";
"return package;";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:9D6F42708C660EB6368CF49D8C460F2B637979C9";
"state:clean";
"updated_at:Sat Jan  5 11:59:18 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:36
$permit("wizard");
`{identifier, version, ?upgrade = 0} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  identifier, version, ?upgrade = 0")';
package = this:_fetch(this.archived[identifier][version]["href"]);
try
package = this:import(package);
except ex ("E_PACKAGE")
package = ex[3];
endtry
return package;
return;
"$permit(\"wizard\");";
"";
"`{identifier, version, ?upgrade = 0} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  identifier, version, ?upgrade = 0\")';";
"";
"package = this:_fetch(this.archived[identifier][version][\"href\"]);";
"";
"try";
"  package = this:import(package);";
"except ex (\"E_PACKAGE\")";
"  package = ex[3];";
"endtry";
"";
"return package;";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:3";
"sha1:768048A2249D537CDF385450EF126B3F8ED37ABA";
"state:clean";
"updated_at:Sat Jan  5 15:37:55 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"$permit(\"wizard\");";
"";
"`{identifier, version, ?upgrade = 0} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  identifier, version, ?upgrade = 0\")';";
"";
"package = this:_fetch(this.archived[identifier][version]);";
"";
"try";
"  package = this:import(package);";
"except ex (\"E_PACKAGE\")";
"  package = ex[3];";
"endtry";
"";
"return package;";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:64EDEF41960E533F6C85782EDE06D2C2855AD264";
"state:clean";
"updated_at:Sat Jan  5 14:18:44 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"$permit(\"wizard\");";
"";
"`{identifier, version, ?upgrade = 0} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  identifier, version, ?upgrade = 0\")';";
"";
"package = this:_fetch(this.archive_host, this.archive_port, this.archived[identifier][version]);";
"";
"try";
"  package = this:import(package);";
"except ex (\"E_PACKAGE\")";
"  package = ex[3];";
"endtry";
"";
"return package;";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:DC3647B7900853DB594963CD166C25DE7800B2E3";
"state:clean";
"updated_at:Sat Jan  5 11:59:18 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:37
$permit("wizard");
`{identifier, version, ?upgrade = 0} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  identifier, version, ?upgrade = 0")';
package = this.cached[identifier][version]["definition"];
try
package = this:import(package);
except ex ("E_PACKAGE")
package = ex[3];
endtry
return package;
return;
"$permit(\"wizard\");";
"";
"`{identifier, version, ?upgrade = 0} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  identifier, version, ?upgrade = 0\")';";
"";
"package = this.cached[identifier][version][\"definition\"];";
"";
"try";
"  package = this:import(package);";
"except ex (\"E_PACKAGE\")";
"  package = ex[3];";
"endtry";
"";
"return package;";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:C4387772ACDB5AFF8A343A478627B7A4B57A5369";
"state:clean";
"updated_at:Sat Jan  5 17:04:50 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"$permit(\"wizard\");";
"";
"`{identifier, version, ?upgrade = 0} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  identifier, version, ?upgrade = 0\")';";
"";
"package = this.cached[identifier][version];";
"";
"try";
"  package = this:import(package);";
"except ex (\"E_PACKAGE\")";
"  package = ex[3];";
"endtry";
"";
"return package;";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:74BEE386E26CFD584EC3C7DA4A0F6946DEA6ACF4";
"state:clean";
"updated_at:Sat Jan  5 15:03:52 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:38
$permit("wizard");
`{identifier, version, ?force = 1} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  identifier, version, ?force = 1")';
package = this:_match(identifier, version)[1];
package = this:export(package);
top = package["Configuration"]["top"];
requires = `package["Objects"][top]["Values"]["requires"]["Value"]["value"] ! E_RANGE => {}';
packages = this.cached;
`packages[identifier] ! E_RANGE' || (packages[identifier] = []);
packages[identifier][version] = ["definition" -> package, "requires" -> requires];
this.cached = packages;
return package;
return;
"$permit(\"wizard\");";
"";
"`{identifier, version, ?force = 1} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  identifier, version, ?force = 1\")';";
"";
"package = this:_match(identifier, version)[1];";
"";
"package = this:export(package);";
"";
"top = package[\"Configuration\"][\"top\"];";
"";
"requires = `package[\"Objects\"][top][\"Values\"][\"requires\"][\"Value\"][\"value\"] ! E_RANGE => {}';";
"";
"packages = this.cached;";
"";
"`packages[identifier] ! E_RANGE' || (packages[identifier] = []);";
"packages[identifier][version] = [\"definition\" -> package, \"requires\" -> requires];";
"";
"this.cached = packages;";
"";
"return package;";
"";
"chunk_length:20";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:B78AE0CE24624889878E8E0BA80DA97EA363F0E9";
"state:clean";
"updated_at:Sat Jan  5 17:18:17 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"$permit(\"wizard\");";
"";
"`{identifier, version, ?force = 1} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  identifier, version, ?force = 1\")';";
"";
"package = this:_match(identifier, version)[1];";
"";
"package = this:export(package);";
"";
"packages = this.cached;";
"";
"`packages[identifier] ! E_RANGE' || (packages[identifier] = []);";
"packages[identifier][version] = package;";
"";
"this.cached = packages;";
"";
"return package;";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:42459EF9E1C5257EE63BE6D3BC13602152C23FF4";
"state:clean";
"updated_at:Sat Jan  5 15:03:52 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:39
$permit("wizard");
`{pathname, ?options = []} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  pathname, ?options")';
fh = -1;
try
fh = file_open(pathname, "r-tn");
package = parse_json(file_readline(fh), "embedded-types");
finally
(fh > -1) && file_close(fh);
endtry
try
package = this:import(package);
except ex ("E_PACKAGE")
package = ex[3];
endtry
return package;
return;
"$permit(\"wizard\");";
"";
"`{pathname, ?options = []} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  pathname, ?options\")';";
"";
"fh = -1;";
"try";
"  fh = file_open(pathname, \"r-tn\");";
"  package = parse_json(file_readline(fh), \"embedded-types\");";
"finally";
"  (fh > -1) && file_close(fh);";
"endtry";
"";
"try";
"  package = this:import(package);";
"except ex (\"E_PACKAGE\")";
"  package = ex[3];";
"endtry";
"";
"return package;";
"";
"chunk_length:19";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:A25F06C67428605F0AEC8DC2B5B84ADC6631BC35";
"state:clean";
"updated_at:Wed Jun  6 08:10:40 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"$permit(\"wizard\");";
"";
"`{pathname, ?options = []} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  pathname, ?options\")';";
"";
"fh = 0;";
"try";
"  fh = file_open(pathname, \"r-tn\");";
"  package = parse_json(file_readline(fh), \"embedded-types\");";
"finally";
"  fh && file_close(fh);";
"endtry";
"";
"try";
"  package = this:import(package);";
"except ex (\"E_PACKAGE\")";
"  package = ex[3];";
"endtry";
"";
"return package;";
"";
"chunk_length:19";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:8ACFF788841A5B066AD9D7DF77D960B27065D729";
"state:clean";
"updated_at:Mon May 28 08:30:13 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:40
$permit("wizard");
`{identifier, version, pathname, ?options = []} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  identifier, version, pathname, ?options")';
package = this:_match(identifier, version)[1];
package = this:export(package, options);
fh = -1;
try
fh = file_open(pathname, "w-tn");
file_writeline(fh, generate_json(package, "embedded-types"));
finally
(fh > -1) && file_close(fh);
endtry
return package;
return;
"$permit(\"wizard\");";
"";
"`{identifier, version, pathname, ?options = []} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  identifier, version, pathname, ?options\")';";
"";
"package = this:_match(identifier, version)[1];";
"";
"package = this:export(package, options);";
"";
"fh = -1;";
"try";
"  fh = file_open(pathname, \"w-tn\");";
"  file_writeline(fh, generate_json(package, \"embedded-types\"));";
"finally";
"  (fh > -1) && file_close(fh);";
"endtry";
"";
"return package;";
"";
"chunk_length:17";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:5FF1F9D03E4E435B1FF4ACD865F3FE8BA9895ADF";
"state:clean";
"updated_at:Wed Jun  6 08:10:40 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"$permit(\"wizard\");";
"";
"`{identifier, version, pathname, ?options = []} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  identifier, version, pathname, ?options\")';";
"";
"package = this:_match(identifier, version)[1];";
"";
"package = this:export(package, options);";
"";
"fh = 0;";
"try";
"  fh = file_open(pathname, \"w-tn\");";
"  file_writeline(fh, generate_json(package, \"embedded-types\"));";
"finally";
"  fh && file_close(fh);";
"endtry";
"";
"return package;";
"";
"chunk_length:17";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:5C79C8F91B13195E19ED5FA48BF128669E3B31EC";
"state:clean";
"updated_at:Mon May 28 08:30:13 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:41
$permit("wizard");
`{identifier, version} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  identifier, version")';
package = this.cached[identifier][version]["definition"];
json = generate_json(package, "embedded-types");
suspend(0);
while (len = length(json))
suspend(0);
len = (len > 60000) ? 60000 | len;
line = json[1..len];
json[1..len] = "";
while (buffered_output_length(player))
suspend(0);
endwhile
notify(player, line);
endwhile
return;
"$permit(\"wizard\");";
"";
"`{identifier, version} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  identifier, version\")';";
"";
"package = this.cached[identifier][version][\"definition\"];";
"";
"json = generate_json(package, \"embedded-types\");";
"";
"suspend(0);";
"";
"while (len = length(json))";
"  suspend(0);";
"  len = len > 60000 ? 60000 | len;";
"  line = json[1..len];";
"  json[1..len] = \"\";";
"  while (buffered_output_length(player))";
"    suspend(0);";
"  endwhile";
"  notify(player, line);";
"endwhile";
"";
"chunk_length:20";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:A3D783A1BC444F7C27CA80179A894EE4D89EE423";
"state:clean";
"updated_at:Sat Jan  5 17:04:50 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:42
if (callers() && (caller_perms() != player))
raise(E_PERM);
endif
if (!player.wizard)
notify(player, "Only wizards can do that!");
return;
endif
if (r = match(dobjstr, "^ *%([_a-z0-9]+%) *%([0-9]+%.[0-9]+%.[0-9]+%)? *$"))
seconds_and_ticks = 0;
try
seconds_and_ticks = this:_set_seconds_and_ticks();
identifier = dobjstr[r[3][1][1]..r[3][1][2]];
version = dobjstr[r[3][2][1]..r[3][2][2]];
if (`this.provides_cache[identifier] ! E_RANGE' != E_RANGE)
notify(player, tostr("Package \"", identifier, "\" is already installed."));
return;
elseif ((`this.archived[identifier] ! E_RANGE' == E_RANGE) && (`this.cached[identifier] ! E_RANGE' == E_RANGE))
notify(player, tostr("Package \"", identifier, "\" doesn't exist in either the remote archive or local cache."));
return;
else
if (version)
if ((`this.archived[identifier][version] ! E_RANGE' == E_RANGE) && (`this.cached[identifier][version] ! E_RANGE' == E_RANGE))
notify(player, tostr("Version \"", version, "\" of package \"", identifier, "\" doesn't exist in either the remote archive or local cache."));
return;
endif
else
cached = `mapkeys(this.cached[identifier]) ! E_RANGE => {}';
archived = `mapkeys(this.archived[identifier]) ! E_RANGE => {}';
versions = {@cached, @archived};
versions = this:_map("_parse_version", versions);
versions = this:_sort_versions(versions);
version = versions[1];
version = tostr(version[1], ".", version[2], ".", version[3]);
endif
endif
if (`this.cached[identifier][version] ! E_RANGE' != E_RANGE)
requires = `this.cached[identifier][version]["requires"] ! E_RANGE => {}';
else
requires = `this.archived[identifier][version]["requires"] ! E_RANGE => {}';
endif
if (requires && (requires = this:_check_required_provides(requires)))
notify(player, tostr("Version \"", version, "\" of package \"", identifier, "\" couldn't be installed because it requires:"));
sep = "";
line = "  ";
for require in (requires)
line = tostr(line, sep, require[1], " ", require[2]);
sep = ", ";
endfor
notify(player, line);
return;
endif
if (`this.cached[identifier][version] ! E_RANGE' != E_RANGE)
notify(player, tostr("Installing version \"", version, "\" of package \"", identifier, "\" from the local cache..."));
package = this:import_package_from_cache(identifier, version);
else
notify(player, tostr("Installing version \"", version, "\" of package \"", identifier, "\" from the remote archive..."));
package = this:import_package_from_archive(identifier, version);
endif
if (((t = typeof(package)) == OBJ) || (t == ANON))
this:install(package, ["follow-instructions" -> 1]);
else
notify(player, tostr("Version \"", version, "\" of package \"", identifier, "\" couldn't be installed (raw package below)."));
notify(player, toliteral(package));
return;
endif
notify(player, tostr("Version \"", version, "\" of package \"", identifier, "\" (", package.name, ") was successfully installed as ", package, "."));
finally
this:_reset_seconds_and_ticks(seconds_and_ticks);
endtry
else
notify(player, tostr("Correct usage is:  @install <package identifier> <package version> with $composed"));
notify(player, tostr("     for example:  @install foobar 1.2.3 with $composed"));
endif
return;
"if (callers() && caller_perms() != player)";
"  raise(E_PERM);";
"endif";
"if (!player.wizard)";
"  notify(player, \"Only wizards can do that!\");";
"  return;";
"endif";
"if (r = match(dobjstr, \"^ *%([_a-z0-9]+%) *%([0-9]+%.[0-9]+%.[0-9]+%)? *$\"))";
"  /* Modify the execution limits to give this (potentially)";
"   * long-running task some breathing room, and to keep things";
"   * atomic.";
"   */";
"  seconds_and_ticks = 0;";
"  try";
"    seconds_and_ticks = this:_set_seconds_and_ticks();";
"";
"    identifier = dobjstr[r[3][1][1]..r[3][1][2]];";
"    version = dobjstr[r[3][2][1]..r[3][2][2]];";
"";
"    if (`this.provides_cache[identifier] ! E_RANGE' != E_RANGE)";
"      notify(player, tostr(\"Package \\\"\", identifier, \"\\\" is already installed.\"));";
"      return;";
"    elseif (`this.archived[identifier] ! E_RANGE' == E_RANGE && `this.cached[identifier] ! E_RANGE' == E_RANGE)";
"      notify(player, tostr(\"Package \\\"\", identifier, \"\\\" doesn't exist in either the remote archive or local cache.\"));";
"      return;";
"    else";
"      if (version)";
"        if (`this.archived[identifier][version] ! E_RANGE' == E_RANGE && `this.cached[identifier][version] ! E_RANGE' == E_RANGE)";
"          notify(player, tostr(\"Version \\\"\", version, \"\\\" of package \\\"\", identifier, \"\\\" doesn't exist in either the remote archive or local cache.\"));";
"          return;";
"        endif";
"      else";
"        cached = `mapkeys(this.cached[identifier]) ! E_RANGE => {}';";
"        archived = `mapkeys(this.archived[identifier]) ! E_RANGE => {}';";
"        versions = {@cached, @archived};";
"        versions = this:_map(\"_parse_version\", versions);";
"        versions = this:_sort_versions(versions);";
"        version = versions[1];";
"        version = tostr(version[1], \".\", version[2], \".\", version[3]);";
"      endif";
"    endif";
"";
"    if (`this.cached[identifier][version] ! E_RANGE' != E_RANGE)";
"      requires = `this.cached[identifier][version][\"requires\"] ! E_RANGE => {}';";
"    else";
"      requires = `this.archived[identifier][version][\"requires\"] ! E_RANGE => {}';";
"    endif";
"";
"    if (requires && (requires = this:_check_required_provides(requires)))";
"      notify(player, tostr(\"Version \\\"\", version, \"\\\" of package \\\"\", identifier, \"\\\" couldn't be installed because it requires:\"));";
"      sep = \"\";";
"      line = \"  \";";
"      for require in (requires)";
"        line = tostr(line, sep, require[1], \" \", require[2]);";
"        sep = \", \";";
"      endfor";
"      notify(player, line);";
"      return;";
"    endif";
"";
"    if (`this.cached[identifier][version] ! E_RANGE' != E_RANGE)";
"      notify(player, tostr(\"Installing version \\\"\", version, \"\\\" of package \\\"\", identifier, \"\\\" from the local cache...\"));";
"      package = this:import_package_from_cache(identifier, version);";
"    else";
"      notify(player, tostr(\"Installing version \\\"\", version, \"\\\" of package \\\"\", identifier, \"\\\" from the remote archive...\"));";
"      package = this:import_package_from_archive(identifier, version);";
"    endif";
"";
"    if ((t = typeof(package)) == OBJ || t == ANON)";
"      this:install(package, [\"follow-instructions\" -> 1]);";
"";
"    else";
"      notify(player, tostr(\"Version \\\"\", version, \"\\\" of package \\\"\", identifier, \"\\\" couldn't be installed (raw package below).\"));";
"      notify(player, toliteral(package));";
"      return;";
"    endif";
"";
"    notify(player, tostr(\"Version \\\"\", version, \"\\\" of package \\\"\", identifier, \"\\\" (\", package.name, \") was successfully installed as \", package, \".\"));";
"";
"  finally";
"    this:_reset_seconds_and_ticks(seconds_and_ticks);";
"  endtry";
"";
"else";
"  notify(player, tostr(\"Correct usage is:  @install <package identifier> <package version> with $composed\"));";
"  notify(player, tostr(\"     for example:  @install foobar 1.2.3 with $composed\"));";
"endif";
"";
"chunk_length:87";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:0B61BB6FBC7398770509368641C995551E3F6EB8";
"state:clean";
"updated_at:Sat Jan  5 16:55:11 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"if (callers() && caller_perms() != player)";
"  raise(E_PERM);";
"endif";
"if (!player.wizard)";
"  notify(player, \"Only wizards can do that!\");";
"  return;";
"endif";
"if (r = match(dobjstr, \"^ *%([_a-z0-9]+%) *%([0-9]+%.[0-9]+%.[0-9]+%)? *$\"))";
"  /* Modify the execution limits to give this (potentially)";
"   * long-running task some breathing room, and to keep things";
"   * atomic.";
"   */";
"  seconds_and_ticks = 0;";
"  try";
"    seconds_and_ticks = this:_set_seconds_and_ticks();";
"";
"    try";
"      notify(player, \"Updating index...\");";
"      this:fetch_index();";
"    except ex (E_INVARG)";
"      notify(player, tostr(\"Update failed:  \", ex[2]));";
"    endtry";
"";
"    identifier = dobjstr[r[3][1][1]..r[3][1][2]];";
"    version = dobjstr[r[3][2][1]..r[3][2][2]];";
"";
"    if (`this.provides_cache[identifier] ! E_RANGE' != E_RANGE)";
"      notify(player, tostr(\"Package \\\"\", identifier, \"\\\" is already installed.\"));";
"      return;";
"    elseif (`this.archived[identifier] ! E_RANGE' == E_RANGE && `this.cached[identifier] ! E_RANGE' == E_RANGE)";
"      notify(player, tostr(\"Package \\\"\", identifier, \"\\\" doesn't exist in either the remote archive or local cache.\"));";
"      return;";
"    else";
"      if (version)";
"        if (`this.archived[identifier][version] ! E_RANGE' == E_RANGE && `this.cached[identifier][version] ! E_RANGE' == E_RANGE)";
"          notify(player, tostr(\"Version \\\"\", version, \"\\\" of package \\\"\", identifier, \"\\\" doesn't exist in either the remote archive or local cache.\"));";
"          return;";
"        endif";
"      else";
"        cached = `mapkeys(this.cached[identifier]) ! E_RANGE => {}';";
"        archived = `mapkeys(this.archived[identifier]) ! E_RANGE => {}';";
"        versions = {@cached, @archived};";
"        versions = this:_map(\"_parse_version\", versions);";
"        versions = this:_sort_versions(versions);";
"        version = versions[1];";
"        version = tostr(version[1], \".\", version[2], \".\", version[3]);";
"      endif";
"    endif";
"";
"    if (`this.cached[identifier][version] ! E_RANGE' != E_RANGE)";
"      notify(player, tostr(\"Installing version \\\"\", version, \"\\\" of package \\\"\", identifier, \"\\\" from the local cache...\"));";
"      package = this:import_package_from_cache(identifier, version);";
"    else";
"      notify(player, tostr(\"Installing version \\\"\", version, \"\\\" of package \\\"\", identifier, \"\\\" from the remote archive...\"));";
"      package = this:import_package_from_archive(identifier, version);";
"    endif";
"";
"    if (typeof(package) == OBJ)";
"      this:install(package, [\"follow-instructions\" -> 1]);";
"";
"    else";
"      notify(player, tostr(\"Version \\\"\", version, \"\\\" of package \\\"\", identifier, \"\\\" couldn't be installed (raw package below).\"));";
"      notify(player, toliteral(package));";
"      return;";
"    endif";
"";
"    notify(player, tostr(\"Version \\\"\", version, \"\\\" of package \\\"\", identifier, \"\\\" (\", package.name, \") was successfully installed as \", package, \".\"));";
"";
"  finally";
"    this:_reset_seconds_and_ticks(seconds_and_ticks);";
"  endtry";
"";
"else";
"  notify(player, tostr(\"Correct usage is:  @install <package identifier> <package version> with $composed\"));";
"  notify(player, tostr(\"     for example:  @install foobar 1.2.3 with $composed\"));";
"endif";
"";
"chunk_length:76";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:32E733A91C2765C4E1D4C5A996FACCAE4A95F261";
"state:clean";
"updated_at:Sat Jan  5 15:34:39 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:43
if (callers() && (caller_perms() != player))
raise(E_PERM);
endif
if (!player.wizard)
notify(player, "Only wizards can do that!");
return;
endif
if (r = match(dobjstr, "^ *%([_a-z0-9]+%) *%([0-9]+%.[0-9]+%.[0-9]+%) *$"))
identifier = dobjstr[r[3][1][1]..r[3][1][2]];
version = dobjstr[r[3][2][1]..r[3][2][2]];
if (`this.provides_cache[identifier][version] ! E_RANGE' == E_RANGE)
notify(player, tostr("Version \"", version, "\" of package \"", identifier, "\" is not installed."));
return;
endif
package = this.provides_cache[identifier][version][1];
this:delete(package, ["follow-instructions" -> 1]);
notify(player, tostr("Version \"", version, "\" of package \"", identifier, "\" was successfully uninstalled."));
else
notify(player, tostr("Correct usage is:  @uninstall <package identifier> <package version> with $composed"));
notify(player, tostr("     for example:  @uninstall foobar 1.2.3 with $composed"));
endif
return;
"if (callers() && caller_perms() != player)";
"  raise(E_PERM);";
"endif";
"if (!player.wizard)";
"  notify(player, \"Only wizards can do that!\");";
"  return;";
"endif";
"if (r = match(dobjstr, \"^ *%([_a-z0-9]+%) *%([0-9]+%.[0-9]+%.[0-9]+%) *$\"))";
"  identifier = dobjstr[r[3][1][1]..r[3][1][2]];";
"  version = dobjstr[r[3][2][1]..r[3][2][2]];";
"";
"  if (`this.provides_cache[identifier][version] ! E_RANGE' == E_RANGE)";
"    notify(player, tostr(\"Version \\\"\", version, \"\\\" of package \\\"\", identifier, \"\\\" is not installed.\"));";
"    return;";
"  endif";
"";
"  package = this.provides_cache[identifier][version][1];";
"";
"  this:delete(package, [\"follow-instructions\" -> 1]);";
"";
"  notify(player, tostr(\"Version \\\"\", version, \"\\\" of package \\\"\", identifier, \"\\\" was successfully uninstalled.\"));";
"";
"else";
"  notify(player, tostr(\"Correct usage is:  @uninstall <package identifier> <package version> with $composed\"));";
"  notify(player, tostr(\"     for example:  @uninstall foobar 1.2.3 with $composed\"));";
"endif";
"";
"chunk_length:26";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:A15B0A62082BBE4A51C8B55CAF095F8C743CBED9";
"state:clean";
"updated_at:Sat Jan  5 15:34:39 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:44
if (callers() && (caller_perms() != player))
raise(E_PERM);
endif
if (!player.wizard)
notify(player, "Only wizards can do that!");
return;
endif
if (dobjstr != "packages")
notify(player, tostr("Correct usage is:  @list packages with $composed"));
return;
endif
notify(player, "Updating index from sources...");
for source in (this.archive_sources)
try
try
old = connection_option(player, "binary");
set_connection_option(player, "binary", 1);
notify(player, tostr("  ", strsub(source, "~", "~7E"), " ... "));
finally
set_connection_option(player, "binary", old);
endtry
this:fetch_index();
notify(player, "done");
except ex (E_INVARG)
notify(player, ex[2]);
endtry
endfor
cached = this.cached;
archived = this.archived;
notify(player, "Installed packages");
for _, identifier in (this.provides_cache)
for _, version in (this.provides_cache[identifier])
if ((version in `mapkeys(cached[identifier]) ! E_RANGE => {}') || (version in `mapkeys(archived[identifier]) ! E_RANGE => {}'))
flags = "   ";
else
flags = " ! ";
endif
notify(player, tostr(flags, identifier, ", ", version, " (", objnum = this.provides_cache[identifier][version][1], ") ", objnum.name));
endfor
endfor
notify(player, "Cached packages");
for _, identifier in (this.cached)
versions = "";
for _, version in (this.cached[identifier])
versions = (versions + ", ") + version;
endfor
notify(player, tostr("   ", identifier, versions));
endfor
notify(player, msg = tostr("Archived packages"));
for _, identifier in (this.archived)
versions = "";
for _, version in (this.archived[identifier])
versions = (versions + ", ") + version;
endfor
notify(player, tostr("   ", identifier, versions));
endfor
notify(player, "(done)");
return;
"if (callers() && caller_perms() != player)";
"  raise(E_PERM);";
"endif";
"if (!player.wizard)";
"  notify(player, \"Only wizards can do that!\");";
"  return;";
"endif";
"if (dobjstr != \"packages\")";
"  notify(player, tostr(\"Correct usage is:  @list packages with $composed\"));";
"  return;";
"endif";
"";
"notify(player, \"Updating index from sources...\");";
"";
"for source in (this.archive_sources)";
"  try";
"    try";
"      old = connection_option(player, \"binary\");";
"      set_connection_option(player, \"binary\", 1);";
"      notify(player, tostr(\"  \", strsub(source, \"~\", \"~7E\"), \" ... \"));";
"    finally";
"      set_connection_option(player, \"binary\", old);";
"    endtry";
"    this:fetch_index();";
"    notify(player, \"done\");";
"  except ex (E_INVARG)";
"    notify(player, ex[2]);";
"  endtry";
"endfor";
"";
"cached = this.cached;";
"archived = this.archived;";
"";
"notify(player, \"Installed packages\");";
"for _, identifier in (this.provides_cache)";
"  for _, version in (this.provides_cache[identifier])";
"    if (version in `mapkeys(cached[identifier]) ! E_RANGE => {}' || version in `mapkeys(archived[identifier]) ! E_RANGE => {}')";
"      flags = \"   \";";
"    else";
"      flags = \" ! \";";
"    endif";
"    notify(player, tostr(flags, identifier, \", \", version, \" (\", objnum = this.provides_cache[identifier][version][1], \") \", objnum.name));";
"  endfor";
"endfor";
"notify(player, \"Cached packages\");";
"for _, identifier in (this.cached)";
"  versions = \"\";";
"  for _, version in (this.cached[identifier])";
"    versions = versions + \", \" + version;";
"  endfor";
"  notify(player, tostr(\"   \", identifier, versions));";
"endfor";
"notify(player, msg = tostr(\"Archived packages\"));";
"for _, identifier in (this.archived)";
"  versions = \"\";";
"  for _, version in (this.archived[identifier])";
"    versions = versions + \", \" + version;";
"  endfor";
"  notify(player, tostr(\"   \", identifier, versions));";
"endfor";
"";
"notify(player, \"(done)\");";
"";
"chunk_length:62";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:4";
"sha1:1A6D08D51B53666B19195D0BBBA2F5A895DF74E7";
"state:clean";
"updated_at:Thu Feb 14 21:36:24 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"if (callers() && caller_perms() != player)";
"  raise(E_PERM);";
"endif";
"if (!player.wizard)";
"  notify(player, \"Only wizards can do that!\");";
"  return;";
"endif";
"if (dobjstr != \"packages\")";
"  notify(player, tostr(\"Correct usage is:  @list packages with $composed\"));";
"  return;";
"endif";
"";
"notify(player, \"Updating index from sources...\");";
"";
"for source in (this.archive_sources)";
"  try";
"    try";
"      old = connection_option(player, \"binary\");";
"      set_connection_option(player, \"binary\", 1);";
"      notify(player, tostr(\"  \", source, \" ... \"));";
"    finally";
"      set_connection_option(player, \"binary\", old);";
"    endtry";
"    this:fetch_index();";
"    notify(player, \"done\");";
"  except ex (E_INVARG)";
"    notify(player, ex[2]);";
"  endtry";
"endfor";
"";
"cached = this.cached;";
"archived = this.archived;";
"";
"notify(player, \"Installed packages\");";
"for _, identifier in (this.provides_cache)";
"  for _, version in (this.provides_cache[identifier])";
"    if (version in `mapkeys(cached[identifier]) ! E_RANGE => {}' || version in `mapkeys(archived[identifier]) ! E_RANGE => {}')";
"      flags = \"   \";";
"    else";
"      flags = \" ! \";";
"    endif";
"    notify(player, tostr(flags, identifier, \", \", version, \" (\", objnum = this.provides_cache[identifier][version][1], \") \", objnum.name));";
"  endfor";
"endfor";
"notify(player, \"Cached packages\");";
"for _, identifier in (this.cached)";
"  versions = \"\";";
"  for _, version in (this.cached[identifier])";
"    versions = versions + \", \" + version;";
"  endfor";
"  notify(player, tostr(\"   \", identifier, versions));";
"endfor";
"notify(player, msg = tostr(\"Archived packages\"));";
"for _, identifier in (this.archived)";
"  versions = \"\";";
"  for _, version in (this.archived[identifier])";
"    versions = versions + \", \" + version;";
"  endfor";
"  notify(player, tostr(\"   \", identifier, versions));";
"endfor";
"";
"notify(player, \"(done)\");";
"";
"chunk_length:62";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:3";
"sha1:CA5DFA614BB48D1C858D4493D368C6E447EE4D74";
"state:clean";
"updated_at:Sat Jan 12 07:42:29 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"if (callers() && caller_perms() != player)";
"  raise(E_PERM);";
"endif";
"if (!player.wizard)";
"  notify(player, \"Only wizards can do that!\");";
"  return;";
"endif";
"if (dobjstr != \"packages\")";
"  notify(player, tostr(\"Correct usage is:  @list packages with $composed\"));";
"  return;";
"endif";
"";
"try";
"  notify(player, \"Updating index from sources...\");";
"  for source in (this.archive_sources)";
"    notify(player, tostr(\"  \", source));";
"  endfor";
"  this:fetch_index();";
"except ex (E_INVARG)";
"  notify(player, tostr(\"Update failed:  \", ex[2]));";
"endtry";
"";
"cached = this.cached;";
"archived = this.archived;";
"";
"notify(player, \"Installed packages\");";
"for _, identifier in (this.provides_cache)";
"  for _, version in (this.provides_cache[identifier])";
"    if (version in `mapkeys(cached[identifier]) ! E_RANGE => {}' || version in `mapkeys(archived[identifier]) ! E_RANGE => {}')";
"      flags = \"   \";";
"    else";
"      flags = \" ! \";";
"    endif";
"    notify(player, tostr(flags, identifier, \", \", version, \" (\", objnum = this.provides_cache[identifier][version][1], \") \", objnum.name));";
"  endfor";
"endfor";
"notify(player, \"Cached packages\");";
"for _, identifier in (this.cached)";
"  versions = \"\";";
"  for _, version in (this.cached[identifier])";
"    versions = versions + \", \" + version;";
"  endfor";
"  notify(player, tostr(\"   \", identifier, versions));";
"endfor";
"notify(player, msg = tostr(\"Archived packages\"));";
"for _, identifier in (this.archived)";
"  versions = \"\";";
"  for _, version in (this.archived[identifier])";
"    versions = versions + \", \" + version;";
"  endfor";
"  notify(player, tostr(\"   \", identifier, versions));";
"endfor";
"";
"notify(player, \"(done)\");";
"";
"chunk_length:54";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:2";
"sha1:30365373D4F1A774C48D9D29F0695221CEF01A81";
"state:clean";
"updated_at:Sun Jan  6 00:18:49 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
"if (callers() && caller_perms() != player)";
"  raise(E_PERM);";
"endif";
"if (!player.wizard)";
"  notify(player, \"Only wizards can do that!\");";
"  return;";
"endif";
"if (dobjstr != \"packages\")";
"  notify(player, tostr(\"Correct usage is:  @list packages with $composed\"));";
"  return;";
"endif";
"";
"try";
"  notify(player, \"Updating index from sources...\");";
"  for source in (this.archive_sources)";
"    notify(player, tostr(\"  \", source));";
"  endfor";
"  this:fetch_index();";
"except ex (E_INVARG)";
"  notify(player, tostr(\"Update failed:  \", ex[2]));";
"endtry";
"";
"cached = this.cached;";
"archived = this.archived;";
"";
"notify(player, \"Installed packages\");";
"for identifier in (mapkeys(this.provides_cache))";
"  for version in (mapkeys(this.provides_cache[identifier]))";
"    if (version in `mapkeys(cached[identifier]) ! E_RANGE => []' || version in `mapkeys(archived[identifier]) ! E_RANGE => {}')";
"      flags = \"   \";";
"    else";
"      flags = \" ! \";";
"    endif";
"    notify(player, tostr(flags, identifier, \", \", version, \" (\", objnum = this.provides_cache[identifier][version][1], \") \", objnum.name));";
"  endfor";
"endfor";
"notify(player, \"Cached packages\");";
"for identifier in (mapkeys(this.cached))";
"  versions = \"\";";
"  for version in (mapkeys(this.cached[identifier]))";
"    versions = versions + \", \" + version;";
"  endfor";
"  notify(player, tostr(\"   \", identifier, versions));";
"endfor";
"notify(player, msg = tostr(\"Archived packages\"));";
"for identifier in (mapkeys(this.archived))";
"  versions = \"\";";
"  for version in (mapkeys(this.archived[identifier]))";
"    versions = versions + \", \" + version;";
"  endfor";
"  notify(player, tostr(\"   \", identifier, versions));";
"endfor";
"";
"notify(player, \"(done)\");";
"";
"chunk_length:54";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:1996EA9126E9432A9D2DADFE9F0E6B19CE2BA4FD";
"state:clean";
"updated_at:Sat Jan  5 14:53:22 2013 EST";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:45
$private();
{identifier, version, package} = args;
manifest = `package.manifest ! E_PROPNF => {}';
instructions = `package.instructions ! E_PROPNF => {}';
if ("install-dictionary" in instructions)
for item in (manifest)
{object, label} = item;
if ("dictionary" == label)
notify(player, tostr("Adding package dictionary (", object.name, ") to parents of $system..."));
parents = {@parents($system), object};
chparents($system, parents);
break;
endif
endfor
endif
if ("install-namespace" in instructions)
for item in (manifest)
{object, label} = item;
if ("dictionary" == label)
notify(player, tostr("Adding namespace (", identifier, ") as a property on $system..."));
add_property($system, identifier, object, {package, "r"});
break;
endif
endfor
endif
for instruction in (instructions)
if ((typeof(`$sysobj ! ANY') == OBJ) && (r = match(instruction, "^install-%([_a-z0-9]+%)-on-legacy-core$")))
property = instruction[r[3][1][1]..r[3][1][2]];
for item in (manifest)
{object, label} = item;
if (property == label)
notify(player, tostr("Adding property (", label, ") to $sysobj..."));
add_property($sysobj, label, object, {package, "r"});
endif
endfor
endif
endfor
return;
"$private();";
"";
"{identifier, version, package} = args;";
"";
"manifest = `package.manifest ! E_PROPNF => {}';";
"instructions = `package.instructions ! E_PROPNF => {}';";
"if (\"install-dictionary\" in instructions)";
"  for item in (manifest)";
"    {object, label} = item;";
"    if (\"dictionary\" == label)";
"      notify(player, tostr(\"Adding package dictionary (\", object.name, \") to parents of $system...\"));";
"      parents = {@parents($system), object};";
"      chparents($system, parents);";
"      break;";
"    endif";
"  endfor";
"endif";
"if (\"install-namespace\" in instructions)";
"  for item in (manifest)";
"    {object, label} = item;";
"    if (\"dictionary\" == label)";
"      notify(player, tostr(\"Adding namespace (\", identifier, \") as a property on $system...\"));";
"      add_property($system, identifier, object, {package, \"r\"});";
"      break;";
"    endif";
"  endfor";
"endif";
"for instruction in (instructions)";
"  if (typeof(`$sysobj ! ANY') == OBJ && (r = match(instruction, \"^install-%([_a-z0-9]+%)-on-legacy-core$\")))";
"    property = instruction[r[3][1][1]..r[3][1][2]];";
"    for item in (manifest)";
"      {object, label} = item;";
"      if (property == label)";
"        notify(player, tostr(\"Adding property (\", label, \") to $sysobj...\"));";
"        add_property($sysobj, label, object, {package, \"r\"});";
"      endif";
"    endfor";
"  endif";
"endfor";
"";
"chunk_length:39";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:2CB1F7A334A9700390CBAC2EE32FCE6189E284DC";
"state:clean";
"updated_at:Thu May 31 20:37:09 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#9:46
$private();
{identifier, version, package} = args;
manifest = `package.manifest ! E_PROPNF => {}';
instructions = `package.instructions ! E_PROPNF => {}';
if ("install-dictionary" in instructions)
for item in (manifest)
{object, label} = item;
if (("dictionary" == label) && (object in parents($system)))
notify(player, tostr("Removing package dictionary (", object.name, ") from parents of $system..."));
parents = setremove(parents($system), object);
chparents($system, parents);
break;
endif
endfor
endif
if ("install-namespace" in instructions)
for item in (manifest)
{object, label} = item;
if (("dictionary" == label) && (identifier in properties($system)))
notify(player, tostr("Removing namespace (", identifier, ") as a property on $system..."));
delete_property($system, identifier);
break;
endif
endfor
endif
for instruction in (instructions)
if ((typeof(`$sysobj ! ANY') == OBJ) && (r = match(instruction, "^install-%([_a-z0-9]+%)-on-legacy-core$")))
property = instruction[r[3][1][1]..r[3][1][2]];
for item in (manifest)
{object, label} = item;
if ((property == label) && (property in properties($sysobj)))
notify(player, tostr("Removing property (", label, ") from $sysobj..."));
delete_property($sysobj, label);
endif
endfor
endif
endfor
return;
"$private();";
"";
"{identifier, version, package} = args;";
"";
"manifest = `package.manifest ! E_PROPNF => {}';";
"instructions = `package.instructions ! E_PROPNF => {}';";
"if (\"install-dictionary\" in instructions)";
"  for item in (manifest)";
"    {object, label} = item;";
"    if (\"dictionary\" == label && object in parents($system))";
"      notify(player, tostr(\"Removing package dictionary (\", object.name, \") from parents of $system...\"));";
"      parents = setremove(parents($system), object);";
"      chparents($system, parents);";
"      break;";
"    endif";
"  endfor";
"endif";
"if (\"install-namespace\" in instructions)";
"  for item in (manifest)";
"    {object, label} = item;";
"    if (\"dictionary\" == label && identifier in properties($system))";
"      notify(player, tostr(\"Removing namespace (\", identifier, \") as a property on $system...\"));";
"      delete_property($system, identifier);";
"      break;";
"    endif";
"  endfor";
"endif";
"for instruction in (instructions)";
"  if (typeof(`$sysobj ! ANY') == OBJ && (r = match(instruction, \"^install-%([_a-z0-9]+%)-on-legacy-core$\")))";
"    property = instruction[r[3][1][1]..r[3][1][2]];";
"    for item in (manifest)";
"      {object, label} = item;";
"      if (property == label && property in properties($sysobj))";
"        notify(player, tostr(\"Removing property (\", label, \") from $sysobj...\"));";
"        delete_property($sysobj, label);";
"      endif";
"    endfor";
"  endif";
"endfor";
"";
"chunk_length:39";
"chunk_type:source";
"content_type:application/x-moocode";
"revision:1";
"sha1:8DF7C5499DB29B394C664EC5978F5EE705A8E030";
"state:clean";
"updated_at:Thu May 31 20:26:10 2012 EDT";
"updated_by:#50";
"-=-=-mxyzptlk-=-=-";
.
#10:0
{message} = args;
$permit("owner", "wizard");
add_property(this, tostr(time()), message, {this.owner, "r"});
return;
"{message} = args;";
"";
"$permit(\"owner\", \"wizard\");";
"";
"add_property(this, tostr(time()), message, {this.owner, \"r\"});";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"updated_at:Tue Oct 25 06:17:39 2011 EDT";
"-=-=-mxyzptlk-=-=-";
.
#12:0
{what} = args;
valid(what) || raise(E_INVARG);
((caller_perms = caller_perms()).wizard || (caller_perms == what.owner)) || raise(E_PERM);
return what.owner == this.owner;
.
#16:0
{r} = args;
return r[4];
return;
"{r} = args;";
"";
"return r[4];";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:71706F2F64CAC53C5D73E12753B459D8A68C759A";
"-=-=-mxyzptlk-=-=-";
.
#16:1
{r} = args;
return r[4][r[1]..r[2]];
return;
"{r} = args;";
"";
"return r[4][r[1]..r[2]];";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E7F4D3D33F824CB6370BA48753A1560F27B9BF7A";
"-=-=-mxyzptlk-=-=-";
.
#16:2
{r} = args;
return `r[5] ! E_RANGE => raise(E_INVARG, "Does not include the source")';
return;
"{r} = args;";
"";
"return `r[5] ! E_RANGE => raise(E_INVARG, \"Does not include the source\")';";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:88B478B1B7708B508B4690A7182D366A9BE3964D";
"-=-=-mxyzptlk-=-=-";
.
#16:3
{r} = args;
return this:at(r, {1, 2, 3, 4, 5, 6, 7, 8, 9});
return;
"{r} = args;";
"";
"return this:at(r, {1, 2, 3, 4, 5, 6, 7, 8, 9});";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:68779F16ACC76965966386EC6014D41D63AA38E7";
"-=-=-mxyzptlk-=-=-";
.
#16:4
{r, i} = args;
if (typeof(i) == LIST)
results = {};
for j in (i)
{b, e} = r[3][j];
results = {@results, (e >= b) ? r[4][b..e] | 0};
endfor
else
{b, e} = r[3][i];
results = (e >= b) ? r[4][b..e] | 0;
endif
return results;
return;
"{r, i} = args;";
"";
"if (typeof(i) == LIST)";
"  results = {};";
"  for j in (i)";
"    {b, e} = r[3][j];";
"    results = {@results, (e >= b) ? r[4][b..e] | 0};";
"  endfor";
"else";
"  {b, e} = r[3][i];";
"  results = (e >= b) ? r[4][b..e] | 0;";
"endif";
"";
"return results;";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4CC956ECA7BEF7AC86CB0AAC0A74B5C1F760A4CD";
"-=-=-mxyzptlk-=-=-";
.
#16:5
{r, ?i} = args;
if (length(args) > 1)
if (typeof(i) == LIST)
results = {};
for j in (i)
{b, e} = r[3][j];
results = {@results, (verb == "begin") ? b | e};
endfor
else
{b, e} = r[3][i];
results = (verb == "begin") ? b | e;
endif
else
return (verb == "begin") ? r[1] | r[2];
endif
return results;
return;
"{r, ?i} = args;";
"";
"if (length(args) > 1)";
"  if (typeof(i) == LIST)";
"    results = {};";
"    for j in (i)";
"      {b, e} = r[3][j];";
"      results = {@results, (verb == \"begin\") ? b | e};";
"    endfor";
"  else";
"    {b, e} = r[3][i];";
"    results = (verb == \"begin\") ? b | e;";
"  endif";
"else";
"  return (verb == \"begin\") ? r[1] | r[2];";
"endif";
"";
"return results;";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:05F1E47E6A99D4A28441B50A11995278DF6C208C";
"-=-=-mxyzptlk-=-=-";
.
#16:6
{r, ?i} = args;
if (length(args) > 1)
if (typeof(i) == LIST)
results = {};
for j in (i)
o = r[3][j];
results = {@results, o};
endfor
else
o = r[3][i];
results = o;
endif
else
return {r[1], r[2]};
endif
return results;
return;
"{r, ?i} = args;";
"";
"if (length(args) > 1)";
"  if (typeof(i) == LIST)";
"    results = {};";
"    for j in (i)";
"      o = r[3][j];";
"      results = {@results, o};";
"    endfor";
"  else";
"    o = r[3][i];";
"    results = o;";
"  endif";
"else";
"  return {r[1], r[2]};";
"endif";
"";
"return results;";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:63376020551180DC974E40634FEA71543B164776";
"-=-=-mxyzptlk-=-=-";
.
#16:7
{r} = args;
if (verb == "post_match")
return r[4][r[2] + 1..$];
else
return r[4][^..r[1] - 1];
endif
return;
"{r} = args;";
"";
"if (verb == \"post_match\")";
"  return r[4][r[2] + 1..$];";
"else";
"  return r[4][^..r[1] - 1];";
"endif";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:7D30EA3EBA0A6BE1E9639E7E77AF6632AEFDC435";
"-=-=-mxyzptlk-=-=-";
.
#16:8
{r} = args;
count = 0;
for c in (r[3])
{b, e} = c;
if (e >= b)
count = count + 1;
endif
endfor
return count;
return;
"{r} = args;";
"";
"count = 0;";
"";
"for c in (r[3])";
"  {b, e} = c;";
"  if (e >= b)";
"    count = count + 1;";
"  endif";
"endfor";
"";
"return count;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A7E792E91A6833BCD44F27BD3F8050504E8A5120";
"-=-=-mxyzptlk-=-=-";
.
#17:0
{year, month, day, hour, minute, second, zone} = args;
year = year + ((month - 1) / 12);
month = ((month - 1) % 12) + 1;
d = ({-1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334}[month] + day) + (year * 366);
d = ((((((d - ((d + 1038) / 1464)) - ((d + 672) / 1464)) - ((d + 306) / 1464)) - ((d + 109740) / 146400)) - ((d + 73140) / 146400)) - ((d + 36540) / 146400)) - 719528;
return ((((((d * 24) + hour) + zone) * 60) + minute) * 60) + second;
return;
"{year, month, day, hour, minute, second, zone} = args;";
"";
"year = year + (month - 1) / 12;";
"month = (month - 1) % 12 + 1;";
"";
"d = {-1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334}[month] + day + year * 366;";
"";
"d = d - ((d + 1038) / 1464) - ((d + 672) / 1464) - ((d + 306) / 1464) - ((d + 109740) / 146400) - ((d + 73140) / 146400) - ((d + 36540) / 146400) - 719528;";
"";
"return ((d * 24 + hour + zone) * 60 + minute) * 60 + second;";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2B61409B44530F884B0C396AA3C1D119ED7D03C4";
"-=-=-mxyzptlk-=-=-";
.
#17:1
{time} = args;
{_, month, day, hhmmss, year, zone} = time:split();
{hour, minute, second} = hhmmss:split(":");
month = month in this.months_short;
zone = this.time_zones[zone];
return this:make_time(toint(year), toint(month), toint(day), toint(hour), toint(minute), toint(second), toint(zone));
return;
"{time} = args;";
"";
"{_, month, day, hhmmss, year, zone} = time:split();";
"{hour, minute, second} = hhmmss:split(\":\");";
"month = month in this.months_short;";
"zone = this.time_zones[zone];";
"";
"return this:make_time(toint(year), toint(month), toint(day), toint(hour), toint(minute), toint(second), toint(zone));";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A62DDCF1222EF6356A78435947CF4E66C282F414";
"-=-=-mxyzptlk-=-=-";
.
#17:2
{time} = args;
{date, _, time} = time:partition("T");
if (date && (!time))
{year, ?month = 1, ?day = 1} = date:split("-");
return this:make_time(toint(year), toint(month), toint(day), 0, 0, 0, 0);
elseif (date && time)
{year, ?month = 1, ?day = 1} = date:split("-");
if (time[$] == "Z")
time = (c = rindex(time, ".")) ? time[1..c - 1] | time[1..$ - 1];
{hour, minute, ?second = 0} = time:split(":");
return this:make_time(toint(year), toint(month), toint(day), toint(hour), toint(minute), toint(second), 0);
elseif (i = rindex(time, "+") || rindex(time, "-"))
{hh, mm} = time[i + 1..$]:split(":");
time = (c = rindex(time, ".")) ? time[1..c - 1] | time[1..i - 1];
{hour, minute, ?second = 0} = time:split(":");
return this:make_time(toint(year), toint(month), toint(day), toint(hour) + toint(hh), toint(minute) + toint(mm), toint(second), 0);
endif
endif
raise(E_INVARG);
return;
"{time} = args;";
"";
"{date, _, time} = time:partition(\"T\");";
"";
"if (date && !time)";
"  {year, ?month = 1, ?day = 1} = date:split(\"-\");";
"  return this:make_time(toint(year), toint(month), toint(day), 0, 0, 0, 0);";
"elseif (date && time)";
"  {year, ?month = 1, ?day = 1} = date:split(\"-\");";
"  if (time[$] == \"Z\")";
"    time = (c = rindex(time, \".\")) ? time[1..c - 1] | time[1..$ - 1];";
"    {hour, minute, ?second = 0} = time:split(\":\");";
"    return this:make_time(toint(year), toint(month), toint(day), toint(hour), toint(minute), toint(second), 0);";
"  elseif ((i = (rindex(time, \"+\") || rindex(time, \"-\"))))";
"    {hh, mm} = time[i + 1..$]:split(\":\");";
"    time = (c = rindex(time, \".\")) ? time[1..c - 1] | time[1..i - 1];";
"    {hour, minute, ?second = 0} = time:split(\":\");";
"    return this:make_time(toint(year), toint(month), toint(day), toint(hour) + toint(hh), toint(minute) + toint(mm), toint(second), 0);";
"  endif";
"endif";
"";
"raise(E_INVARG);";
"";
"chunk_length:22";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:46174B176D1E847C1A39F25A59A6E46590DF05E4";
"-=-=-mxyzptlk-=-=-";
.
#17:3
{value, unit} = args;
phrase = tostr(value, " ", unit, ((value != 1) && "s") || "");
return phrase;
return;
"{value, unit} = args;";
"";
"phrase = tostr(value, \" \", unit, (value != 1) && \"s\" || \"\");";
"";
"return phrase;";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:21C8E8FAA538140B3A801C6D8A1F26A0BEF45EC4";
"-=-=-mxyzptlk-=-=-";
.
#17:4
{?time = time(), ?reference = 0} = args;
if (!(delta = time - reference))
return "0 seconds";
endif
parts = {};
r = ctime(reference);
y = toint(r[21..24]);
m = is_member(r[5..7], this.months_short);
years = 0;
while (delta > ((temp = (365 + ((!(y % 4)) && (!((y % 400) in {100, 200, 300})))) * 86400) - 1))
years = years + 1;
delta = delta - temp;
y = y + 1;
endwhile
if (years)
parts = {@parts, this:_pluralize(years, "year")};
endif
monthdays = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
leapdays = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
months = 0;
while (delta > ((temp = (((!(y % 4)) && (!((y % 400) in {100, 200, 300}))) ? leapdays[m] | monthdays[m]) * 86400) - 1))
months = months + 1;
delta = delta - temp;
m = (m < 12) ? m + 1 | 1;
y = y + (m == 1);
endwhile
if (months)
parts = {@parts, this:_pluralize(months, "month")};
endif
if (delta > 86399)
days = delta / 86400;
delta = delta % 86400;
parts = {@parts, this:_pluralize(days, "day")};
endif
if (delta > 3599)
hours = delta / 3600;
delta = delta % 3600;
parts = {@parts, this:_pluralize(hours, "hour")};
endif
if (delta > 59)
minutes = delta / 60;
delta = delta % 60;
parts = {@parts, this:_pluralize(minutes, "minute")};
endif
if (delta > 0)
seconds = delta;
parts = {@parts, this:_pluralize(seconds, "second")};
endif
if (length(parts) > 2)
return {parts[1..$ - 1]:join(", "), parts[$]}:join(" and ");
else
return parts:join(" and ");
endif
return;
"{?time = time(), ?reference = 0} = args;";
"";
"if (!(delta = time - reference))";
"  return \"0 seconds\";";
"endif";
"";
"parts = {};";
"";
"r = ctime(reference);";
"y = toint(r[21..24]);";
"m = is_member(r[5..7], this.months_short);";
"";
"years = 0;";
"while (delta > (temp = ((365 + (!(y % 4) && !(y % 400 in {100, 200, 300}))) * 86400)) - 1)";
"  years = years + 1;";
"  delta = delta - temp;";
"  y = y + 1;";
"endwhile";
"if (years)";
"  parts = {@parts, this:_pluralize(years, \"year\")};";
"endif";
"";
"monthdays = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};";
"leapdays = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};";
"";
"months = 0;";
"while (delta > (temp = (((!(y % 4) && !(y % 400 in {100, 200, 300})) ? leapdays[m] | monthdays[m]) * 86400)) - 1)";
"  months = months + 1;";
"  delta = delta - temp;";
"  m = (m < 12) ? m + 1 | 1;";
"  y = y + (m == 1);";
"endwhile";
"if (months)";
"  parts = {@parts, this:_pluralize(months, \"month\")};";
"endif";
"";
"if (delta > 86399)";
"  days = delta / 86400;";
"  delta = delta % 86400;";
"  parts = {@parts, this:_pluralize(days, \"day\")};";
"endif";
"";
"if (delta > 3599)";
"  hours = delta / 3600;";
"  delta = delta % 3600;";
"  parts = {@parts, this:_pluralize(hours, \"hour\")};";
"endif";
"";
"if (delta > 59)";
"  minutes = delta / 60;";
"  delta = delta % 60;";
"  parts = {@parts, this:_pluralize(minutes, \"minute\")};";
"endif";
"";
"if (delta > 0)";
"  seconds = delta;";
"  parts = {@parts, this:_pluralize(seconds, \"second\")};";
"endif";
"";
"if (length(parts) > 2)";
"  return {parts[1..$ - 1]:join(\", \"), parts[$]}:join(\" and \");";
"else";
"  return parts:join(\" and \");";
"endif";
"";
"chunk_length:64";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:7B18C9CE1FFE8CCFFFB1492A6060326FEA043F9A";
"-=-=-mxyzptlk-=-=-";
.
#17:5
return time();
return;
"return time();";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C651F0649B662C3427C380CA47C4FBE6CBF312EB";
"-=-=-mxyzptlk-=-=-";
.
#17:6
{?time = time()} = args;
month = ctime(time)[5..7] in this.months_short;
return this.months[month];
return;
"{?time = time()} = args;";
"";
"month = ctime(time)[5..7] in this.months_short;";
"";
"return this.months[month];";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0F8E992F8196BCE58F368B4904FEBDE8EFD3EC3A";
"-=-=-mxyzptlk-=-=-";
.
#17:7
{?time = time()} = args;
day = ctime(time)[1..3] in this.days_short;
return this.days[day];
return;
"{?time = time()} = args;";
"";
"day = ctime(time)[1..3] in this.days_short;";
"";
"return this.days[day];";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D5F2FFEA15B6472AB74EDD14E862941EDCD8B201";
"-=-=-mxyzptlk-=-=-";
.
#17:8
{?time = time()} = args;
if (verb == "year")
return toint(ctime(time)[21..24]);
elseif (verb == "month")
return is_member(ctime(time)[5..7], this.months_short);
elseif (verb == "day")
return toint(ctime(time)[9..10]);
elseif (verb == "hour")
return toint(ctime(time)[12..13]);
elseif (verb == "minute")
return toint(ctime(time)[15..16]);
elseif (verb == "second")
return toint(ctime(time)[18..19]);
endif
return;
"{?time = time()} = args;";
"";
"if (verb == \"year\")";
"  return toint(ctime(time)[21..24]);";
"elseif (verb == \"month\")";
"  return is_member(ctime(time)[5..7], this.months_short);";
"elseif (verb == \"day\")";
"  return toint(ctime(time)[9..10]);";
"elseif (verb == \"hour\")";
"  return toint(ctime(time)[12..13]);";
"elseif (verb == \"minute\")";
"  return toint(ctime(time)[15..16]);";
"elseif (verb == \"second\")";
"  return toint(ctime(time)[18..19]);";
"endif";
"";
"chunk_length:15";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:ADB4D59AF39F4F617C1D405786B0CED20466956C";
"-=-=-mxyzptlk-=-=-";
.
#17:9
{?time = time()} = args;
hour = toint(ctime(time)[12..13]);
if (verb == "is_am")
return hour < 12;
else
return hour > 11;
endif
return;
"{?time = time()} = args;";
"";
"hour = toint(ctime(time)[12..13]);";
"";
"if (verb == \"is_am\")";
"  return hour < 12;";
"else";
"  return hour > 11;";
"endif";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:EEC313FDCDB400C072269E3611931A932239DFE2";
"-=-=-mxyzptlk-=-=-";
.
#17:10
{?time = time()} = args;
return ctime(time)[26..28];
return;
"{?time = time()} = args;";
"";
"return ctime(time)[26..28];";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9527ABA4513B6A874478C2C9E4701AE7153EC58D";
"-=-=-mxyzptlk-=-=-";
.
#17:11
{?time = time()} = args;
return ctime(time)[26..28] in this.dst_zones;
return;
"{?time = time()} = args;";
"";
"return ctime(time)[26..28] in this.dst_zones;";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A3A42DEA9541742127F1E635A662784B9F169625";
"-=-=-mxyzptlk-=-=-";
.
#17:12
{?time = time()} = args;
return verb[4..6] == ctime(time)[1..3];
return;
"{?time = time()} = args;";
"";
"return verb[4..6] == ctime(time)[1..3];";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:166CD5D85023CE64C3E858D95B524F801ACEDEC4";
"-=-=-mxyzptlk-=-=-";
.
#17:13
{template, ?time = time(), ?gmt = 0} = args;
if (!template)
return "";
endif
ctime = ctime(time);
if (gmt)
zone = ctime[26..28];
time = time + (this.time_zones[zone] * 3600);
ctime = ctime(time);
endif
monthdays = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
leapdays = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
result = "";
while (template && (i = index(template, "$")))
value = "";
if (length(template) > i)
if ((c = template[i + 1]) == "$")
value = "$";
elseif (equal(c, "H"))
value = ctime[12..13];
elseif (equal(c, "h"))
value = tostr(toint(ctime[12..13]));
elseif (equal(c, "M"))
value = ctime[15..16];
elseif (equal(c, "m"))
value = tostr(toint(ctime[15..16]));
elseif (equal(c, "S"))
value = ctime[18..19];
elseif (equal(c, "s"))
value = tostr(toint(ctime[18..19]));
elseif (equal(c, "O"))
h = ((toint(ctime[12..13]) + 11) % 12) + 1;
value = (h < 10) ? tostr("0", h) | tostr(h);
elseif (equal(c, "o"))
h = ((toint(ctime[12..13]) + 11) % 12) + 1;
value = tostr(h);
elseif (equal(c, "Y"))
value = ctime[21..24];
elseif (equal(c, "y"))
value = ctime[23..24];
elseif (equal(c, "N"))
value = this.months[ctime[5..7] in this.months_short];
elseif (equal(c, "n"))
value = ctime[5..7];
elseif (equal(c, "B"))
m = ctime[5..7] in this.months_short;
value = (m < 10) ? tostr("0", m) | tostr(m);
elseif (equal(c, "b"))
m = ctime[5..7] in this.months_short;
value = tostr(m);
elseif (equal(c, "C"))
m = ctime[5..7] in this.months_short;
value = (m < 10) ? tostr(" ", m) | tostr(m);
elseif (equal(c, "c"))
m = ctime[5..7] in this.months_short;
value = tostr(m);
elseif (equal(c, "D"))
value = this.days[ctime[1..3] in this.days_short];
elseif (equal(c, "d"))
value = ctime[1..3];
elseif (equal(c, "T"))
d = toint(ctime[9..10]);
value = (d < 10) ? tostr("0", d) | tostr(d);
elseif (equal(c, "t"))
d = toint(ctime[9..10]);
value = tostr(d);
elseif (equal(c, "U"))
d = toint(ctime[9..10]);
value = (d < 10) ? tostr(" ", d) | tostr(d);
elseif (equal(c, "u"))
d = toint(ctime[9..10]);
value = tostr(d);
elseif (equal(c, "P"))
value = (toint(ctime(time)[12..13]) < 12) ? "AM" | "PM";
elseif (equal(c, "p"))
value = (toint(ctime(time)[12..13]) < 12) ? "am" | "pm";
elseif (equal(c, "Z"))
z = ctime[26..28];
z = this.time_zones[z];
z = (z < 10) ? tostr("0", z) | z;
value = gmt ? "+00:00" | tostr("+", z, ":00");
elseif (equal(c, "z"))
z = ctime[26..28];
value = gmt ? "GMT" | z;
elseif (equal(c, "w"))
y = toint(ctime[21..24]);
m = is_member(ctime[5..7], this.months_short);
d = toint(ctime[9..10]);
for x in [1..m - 1]
d = d + (((!(y % 4)) && (!((y % 400) in {100, 200, 300}))) ? leapdays[x] | monthdays[x]);
endfor
z = ctime[1..3] in this.days_short;
a = (d - z) / 7;
b = (d - z) % 7;
if (d >= z)
value = tostr((a + (!(!z))) + (!(!b)));
else
value = "1";
endif
elseif (equal(c, "j"))
y = toint(ctime[21..24]);
m = is_member(ctime[5..7], this.months_short);
d = toint(ctime[9..10]);
for x in [1..m - 1]
d = d + (((!(y % 4)) && (!((y % 400) in {100, 200, 300}))) ? leapdays[x] | monthdays[x]);
endfor
value = tostr(d);
endif
endif
result = (result + template[1..i - 1]) + value;
template = template[i + 2..$];
endwhile
result = result + template;
return result;
return;
"{template, ?time = time(), ?gmt = 0} = args;";
"";
"if (!template)";
"  return \"\";";
"endif";
"";
"ctime = ctime(time);";
"";
"if (gmt)";
"  zone = ctime[26..28];";
"  time = time + this.time_zones[zone] * 3600;";
"  ctime = ctime(time);";
"endif";
"";
"monthdays = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};";
"leapdays = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};";
"";
"result = \"\";";
"";
"while (template && (i = index(template, \"$\")))";
"  value = \"\";";
"  if (length(template) > i)";
"    if ((c = template[i + 1]) == \"$\")";
"      value = \"$\";";
"    elseif (equal(c, \"H\"))";
"      value = ctime[12..13];";
"    elseif (equal(c, \"h\"))";
"      value = tostr(toint(ctime[12..13]));";
"    elseif (equal(c, \"M\"))";
"      value = ctime[15..16];";
"    elseif (equal(c, \"m\"))";
"      value = tostr(toint(ctime[15..16]));";
"    elseif (equal(c, \"S\"))";
"      value = ctime[18..19];";
"    elseif (equal(c, \"s\"))";
"      value = tostr(toint(ctime[18..19]));";
"    elseif (equal(c, \"O\"))";
"      h = (toint(ctime[12..13]) + 11) % 12 + 1;";
"      value = h < 10 ? tostr(\"0\", h) | tostr(h);";
"    elseif (equal(c, \"o\"))";
"      h = (toint(ctime[12..13]) + 11) % 12 + 1;";
"      value = tostr(h);";
"    elseif (equal(c, \"Y\"))";
"      value = ctime[21..24];";
"    elseif (equal(c, \"y\"))";
"      value = ctime[23..24];";
"    elseif (equal(c, \"N\"))";
"      value = this.months[ctime[5..7] in this.months_short];";
"    elseif (equal(c, \"n\"))";
"      value = ctime[5..7];";
"    elseif (equal(c, \"B\"))";
"      m = ctime[5..7] in this.months_short;";
"      value = m < 10 ? tostr(\"0\", m) | tostr(m);";
"    elseif (equal(c, \"b\"))";
"      m = ctime[5..7] in this.months_short;";
"      value = tostr(m);";
"    elseif (equal(c, \"C\"))";
"      m = ctime[5..7] in this.months_short;";
"      value = m < 10 ? tostr(\" \", m) | tostr(m);";
"    elseif (equal(c, \"c\"))";
"      m = ctime[5..7] in this.months_short;";
"      value = tostr(m);";
"    elseif (equal(c, \"D\"))";
"      value = this.days[ctime[1..3] in this.days_short];";
"    elseif (equal(c, \"d\"))";
"      value = ctime[1..3];";
"    elseif (equal(c, \"T\"))";
"      d = toint(ctime[9..10]);";
"      value = d < 10 ? tostr(\"0\", d) | tostr(d);";
"    elseif (equal(c, \"t\"))";
"      d = toint(ctime[9..10]);";
"      value = tostr(d);";
"    elseif (equal(c, \"U\"))";
"      d = toint(ctime[9..10]);";
"      value = d < 10 ? tostr(\" \", d) | tostr(d);";
"    elseif (equal(c, \"u\"))";
"      d = toint(ctime[9..10]);";
"      value = tostr(d);";
"    elseif (equal(c, \"P\"))";
"      value = toint(ctime(time)[12..13]) < 12 ? \"AM\" | \"PM\";";
"    elseif (equal(c, \"p\"))";
"      value = toint(ctime(time)[12..13]) < 12 ? \"am\" | \"pm\";";
"    elseif (equal(c, \"Z\"))";
"      z = ctime[26..28];";
"      z = this.time_zones[z];";
"      z = z < 10 ? tostr(\"0\", z) | z;";
"      value = gmt ? \"+00:00\" | tostr(\"+\", z, \":00\");";
"    elseif (equal(c, \"z\"))";
"      z = ctime[26..28];";
"      value = gmt ? \"GMT\" | z;";
"    elseif (equal(c, \"w\"))";
"      y = toint(ctime[21..24]);";
"      m = is_member(ctime[5..7], this.months_short);";
"      d = toint(ctime[9..10]);";
"      for x in [1..m - 1]";
"        d = d + ((!(y % 4) && !(y % 400 in {100, 200, 300})) ? leapdays[x] | monthdays[x]);";
"      endfor";
"      z = ctime[1..3] in this.days_short;";
"      a = (d - z) / 7;";
"      b = (d - z) % 7;";
"      if (d >= z)";
"        value = tostr(a + !!z + !!b);";
"      else";
"        value = \"1\";";
"      endif";
"    elseif (equal(c, \"j\"))";
"      y = toint(ctime[21..24]);";
"      m = is_member(ctime[5..7], this.months_short);";
"      d = toint(ctime[9..10]);";
"      for x in [1..m - 1]";
"        d = d + ((!(y % 4) && !(y % 400 in {100, 200, 300})) ? leapdays[x] | monthdays[x]);";
"      endfor";
"      value = tostr(d);";
"    endif";
"  endif";
"  result = result + template[1..i - 1] + value;";
"  template = template[i + 2..$];";
"endwhile";
"";
"result = result + template;";
"";
"return result;";
"";
"chunk_length:122";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A7947B2C67D608737C02237DDBAD920FC6CC8F1C";
"-=-=-mxyzptlk-=-=-";
.
#17:14
{?time = time()} = args;
return this:format("$d, $T $n $Y $H:$M:$S $z", time, 1);
return;
"{?time = time()} = args;";
"";
"return this:format(\"$d, $T $n $Y $H:$M:$S $z\", time, 1);";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:BF44DAF235B197CE9B58D6366B4E19B8702449C5";
"-=-=-mxyzptlk-=-=-";
.
#17:15
{?time = time()} = args;
return this:format("$Y-$B-$TT$H:$M:$SZ", time, 1);
return;
"{?time = time()} = args;";
"";
"return this:format(\"$Y-$B-$TT$H:$M:$SZ\", time, 1);";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:04557F08F3F1E6301FE59A2D8D3F72D1D9AB6CC7";
"-=-=-mxyzptlk-=-=-";
.
#18:0
{mode} = args;
original = mode;
(r = index(mode, "r")) && (mode = tostr(mode[^..r - 1], mode[r + 1..$]));
(w = index(mode, "w")) && (mode = tostr(mode[^..w - 1], mode[w + 1..$]));
(a = index(mode, "a")) && (mode = tostr(mode[^..a - 1], mode[a + 1..$]));
(p = index(mode, "+")) && (mode = tostr(mode[^..p - 1], mode[p + 1..$]));
(m = index(mode, "-")) && (mode = tostr(mode[^..m - 1], mode[m + 1..$]));
(t = index(mode, "t")) && (mode = tostr(mode[^..t - 1], mode[t + 1..$]));
(b = index(mode, "b")) && (mode = tostr(mode[^..b - 1], mode[b + 1..$]));
(n = index(mode, "n")) && (mode = tostr(mode[^..n - 1], mode[n + 1..$]));
(f = index(mode, "f")) && (mode = tostr(mode[^..f - 1], mode[f + 1..$]));
mode && raise(E_INVARG, tostr("Invalid mode: ", original));
(((r && w) || (r && a)) || (w && a)) && raise(E_INVARG, tostr("Incompatible mode string: ", original));
(p && m) && raise(E_INVARG, tostr("Incompatible mode string: ", original));
(t && b) && raise(E_INVARG, tostr("Incompatible mode string: ", original));
(n && f) && raise(E_INVARG, tostr("Incompatible mode string: ", original));
return tostr((!a) ? (!w) ? "r" | "w" | "a", p ? "+" | "-", b ? "b" | "t", f ? "f" | "n");
return;
"{mode} = args;";
"";
"/* Simplify the setting of the mode string.  Allow common cases with";
" * minimal mode strings: \"r\", \"w\" etc.  Perform more detailed validity";
" * checks.";
" */";
"";
"original = mode;";
"";
"(r = index(mode, \"r\")) && (mode = tostr(mode[^..r - 1], mode[r + 1..$]));";
"(w = index(mode, \"w\")) && (mode = tostr(mode[^..w - 1], mode[w + 1..$]));";
"(a = index(mode, \"a\")) && (mode = tostr(mode[^..a - 1], mode[a + 1..$]));";
"(p = index(mode, \"+\")) && (mode = tostr(mode[^..p - 1], mode[p + 1..$]));";
"(m = index(mode, \"-\")) && (mode = tostr(mode[^..m - 1], mode[m + 1..$]));";
"(t = index(mode, \"t\")) && (mode = tostr(mode[^..t - 1], mode[t + 1..$]));";
"(b = index(mode, \"b\")) && (mode = tostr(mode[^..b - 1], mode[b + 1..$]));";
"(n = index(mode, \"n\")) && (mode = tostr(mode[^..n - 1], mode[n + 1..$]));";
"(f = index(mode, \"f\")) && (mode = tostr(mode[^..f - 1], mode[f + 1..$]));";
"";
"mode && raise(E_INVARG, tostr(\"Invalid mode: \", original));";
"((r && w) || (r && a) || (w && a)) && raise(E_INVARG, tostr(\"Incompatible mode string: \", original));";
"(p && m) && raise(E_INVARG, tostr(\"Incompatible mode string: \", original));";
"(t && b) && raise(E_INVARG, tostr(\"Incompatible mode string: \", original));";
"(n && f) && raise(E_INVARG, tostr(\"Incompatible mode string: \", original));";
"";
"return tostr(";
"  !a ? !w ? \"r\" | \"w\" | \"a\",";
"  p ? \"+\" | \"-\",";
"  b ? \"b\" | \"t\",";
"  f ? \"f\" | \"n\"";
");";
"";
"chunk_length:31";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:284363D6A4672F17547EE11F4398A087FB83F326";
"-=-=-mxyzptlk-=-=-";
.
#18:1
$permit("wizard");
{path, ?mode = ""} = args;
mode = this:_fix_mode(mode);
file = create(this.file_io_proto, 1);
file.file_handle = file_open(path, mode);
file.epoch = $epoch;
file.mode = mode;
file.name = tostr("<", file_name(file.file_handle), ", ", file.mode, ">");
return file;
return;
"$permit(\"wizard\");";
"";
"{path, ?mode = \"\"} = args;";
"";
"mode = this:_fix_mode(mode);";
"";
"file = create(this.file_io_proto, 1);";
"file.file_handle = file_open(path, mode);";
"file.epoch = $epoch;";
"file.mode = mode;";
"";
"file.name = tostr(\"<\", file_name(file.file_handle), \", \", file.mode, \">\");";
"";
"return file;";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:83502761BB45C2C2A123D389A6C3481CE2F63ABE";
"-=-=-mxyzptlk-=-=-";
.
#19:0
{object} = args;
if (object.owner != caller_perms())
set_task_perms(caller_perms());
endif
result = {};
for ancestor in (ancestors(object, 1))
result = {@result, @call_function(verb, ancestor)};
endfor
return result;
return;
"{object} = args;";
"";
"if (object.owner != caller_perms())";
"  set_task_perms(caller_perms());";
"endif";
"";
"result = {};";
"";
"for ancestor in (ancestors(object, 1))";
"  result = {@result, @call_function(verb, ancestor)};";
"endfor";
"";
"return result;";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D116BA1332A3DB14788FDAAA2AD38F5BD6A2D879";
"-=-=-mxyzptlk-=-=-";
.
#19:1
{object, owner} = args;
if ((verbs(object) || properties(object)) || children(object))
raise(E_INVARG, "Invalid object");
endif
caller_perms = caller_perms();
properties = this:properties(object);
if (((p = $match_permit(this.change_owner_permit_proto, owner)) == $failed_match) || (p == $ambiguous_match))
if (caller_perms.wizard)
elseif (owner == caller_perms)
return;
else
raise(E_PERM, "Cannot change owner");
endif
endif
if (object.owner != caller_perms)
raise(E_PERM, "Cannot change owner");
endif
for property in (properties)
pi = property_info(object, property);
if (index(pi[2], "c"))
if (pi[1] != caller_perms)
raise(E_PERM, "Cannot change owner");
endif
endif
endfor
object.owner = owner;
for property in (properties)
pi = property_info(object, property);
if (index(pi[2], "c"))
pi[1] = owner;
set_property_info(object, property, pi);
endif
endfor
return;
"/* Changes the owner of `object' to `owner' almost as if the object";
" * were created that way -- in particular, the ownership of `c'";
" * properties is changed, too.  This verb is _not_ a general purpose";
" * ownership changer.  There are many restrictions.  `object' may not";
" * have any verb or property definitions of its own, nor may it have";
" * children.  Both the object and all of its `c' properties must";
" * be owned be the caller.";
" */";
"";
"{object, owner} = args;";
"";
"/* someday, maybe */";
"if (verbs(object) || properties(object) || children(object))";
"  raise(E_INVARG, \"Invalid object\");";
"endif";
"";
"caller_perms = caller_perms();";
"properties = this:properties(object);";
"";
"if ((p = $match_permit(this.change_owner_permit_proto, owner)) == $failed_match || p == $ambiguous_match)";
"  /* The following exceptions are useful for testing.  Pragmatically";
"   * speaking, a wizard can already change ownership willy-nilly and a";
"   * non-wizard can already change ownership to itself... so everyone";
"   * retains their existing powers.";
"   */";
"  if (caller_perms.wizard)";
"    ;";
"  elseif (owner == caller_perms)";
"    return;";
"  else";
"    raise(E_PERM, \"Cannot change owner\");";
"  endif";
"endif";
"";
"/* check things out */";
"";
"if (object.owner != caller_perms)";
"  raise(E_PERM, \"Cannot change owner\");";
"endif";
"";
"for property in (properties)";
"  pi = property_info(object, property);";
"  if (index(pi[2], \"c\"))";
"    if (pi[1] != caller_perms)";
"      raise(E_PERM, \"Cannot change owner\");";
"    endif";
"  endif";
"endfor";
"";
"/* go to work */";
"";
"object.owner = owner;";
"";
"for property in (properties)";
"  pi = property_info(object, property);";
"  if (index(pi[2], \"c\"))";
"    pi[1] = owner;";
"    set_property_info(object, property, pi);";
"  endif";
"endfor";
"";
"chunk_length:60";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:749D0D8A6677455EBB381B0E38626B96BC71FFD1";
"-=-=-mxyzptlk-=-=-";
.
#20:0
(typeof(this) == OBJ) || raise(E_INVARG, "Callable on prototypes only");
{subject} = args;
valid(subject) || raise(E_INVARG);
set_task_perms(caller_perms());
instance = create(this, 1);
instance.subject = subject;
return instance;
return;
"typeof(this) == OBJ || raise(E_INVARG, \"Callable on prototypes only\");";
"";
"{subject} = args;";
"";
"valid(subject) || raise(E_INVARG);";
"";
"set_task_perms(caller_perms());";
"";
"instance = create(this, 1);";
"instance.subject = subject;";
"";
"return instance;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E0B35527482AB7F291100402E30E123D3397DD18";
"-=-=-mxyzptlk-=-=-";
.
#20:1
(typeof(this) == ANON) || raise(E_INVARG, "Callable on instances only");
{prototype, owner, subject} = args;
return (isa(this, prototype) && (this.owner == owner)) && (this.subject == subject);
return;
"typeof(this) == ANON || raise(E_INVARG, \"Callable on instances only\");";
"";
"{prototype, owner, subject} = args;";
"";
"return isa(this, prototype) && this.owner == owner && this.subject == subject;";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B83C6100FFDD5BA5CFE38F8F4B692C2E2C76DF0C";
"-=-=-mxyzptlk-=-=-";
.
#22:0
callers() && $restrict_to_builtin("create");
return;
"callers() && $restrict_to_builtin(\"create\");";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0E7D1317F0884312905D7B67686914095C7530B4";
"-=-=-mxyzptlk-=-=-";
.
#22:1
callers() && $restrict_to_builtin("recycle");
this:close();
return;
"callers() && $restrict_to_builtin(\"recycle\");";
"";
"this:close();";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:04B081C88AE7F2B31C186209F128D5217ACC7B7F";
"-=-=-mxyzptlk-=-=-";
.
#22:2
$private();
this:close();
return;
"$private();";
"";
"this:close();";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F0C74D96A24097A0EE1290F5C9F840B87E88DA05";
"-=-=-mxyzptlk-=-=-";
.
#22:3
((this.epoch == $epoch) && (this.file_handle > -1)) && `file_close(this.file_handle) ! E_FILE';
this.file_handle = -1;
return;
"this.epoch == $epoch && this.file_handle > -1 && `file_close(this.file_handle) ! E_FILE';";
"this.file_handle = -1;";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6A9710A55188A48EB31888749363188263092AF6";
"-=-=-mxyzptlk-=-=-";
.
#22:4
if (((verb == "is_open") && (this.epoch == $epoch)) && (this.file_handle > -1))
return 1;
elseif ((verb == "is_closed") && ((this.epoch != $epoch) || (this.file_handle < 0)))
return 1;
else
return 0;
endif
return;
"if (verb == \"is_open\" && this.epoch == $epoch && this.file_handle > -1)";
"  return 1;";
"elseif (verb == \"is_closed\" && (this.epoch != $epoch || this.file_handle < 0))";
"  return 1;";
"else";
"  return 0;";
"endif";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:80A45FDC4123CB05D694BC51CADFDAAB9D0214EB";
"-=-=-mxyzptlk-=-=-";
.
#22:5
if ((this.epoch == $epoch) && (this.file_handle > -1))
if ((verb == "is_text") && index(this.mode, "t"))
return 1;
elseif ((verb == "is_binary") && index(this.mode, "b"))
return 1;
endif
endif
return 0;
return;
"if (this.epoch == $epoch && this.file_handle > -1)";
"  if (verb == \"is_text\" && index(this.mode, \"t\"))";
"    return 1;";
"  elseif (verb == \"is_binary\" && index(this.mode, \"b\"))";
"    return 1;";
"  endif";
"endif";
"";
"return 0;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:930E4875C18F2F0C031884510CE9496D93878620";
"-=-=-mxyzptlk-=-=-";
.
#22:6
if ((this.epoch == $epoch) && (this.file_handle > -1))
if ((verb == "is_readable") && (index(this.mode, "r") || index(this.mode, "+")))
return 1;
elseif ((verb == "is_writeable") && ((index(this.mode, "w") || index(this.mode, "a")) || index(this.mode, "+")))
return 1;
endif
endif
return 0;
return;
"if (this.epoch == $epoch && this.file_handle > -1)";
"  if (verb == \"is_readable\" && (index(this.mode, \"r\") || index(this.mode, \"+\")))";
"    return 1;";
"  elseif (verb == \"is_writeable\" && (index(this.mode, \"w\") || index(this.mode, \"a\") || index(this.mode, \"+\")))";
"    return 1;";
"  endif";
"endif";
"";
"return 0;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D8B5CEEB873ED059862AE07B00D82917022C3E9F";
"-=-=-mxyzptlk-=-=-";
.
#22:7
((this.epoch == $epoch) || this:_invalidate()) || raise(E_FILE, "Invalid file");
return call_function("file_" + verb, this.file_handle, @args);
return;
"this.epoch == $epoch || this:_invalidate() || raise(E_FILE, \"Invalid file\");";
"return call_function(\"file_\" + verb, this.file_handle, @args);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3394F7D56169A0DBBE4A5C388BA926B2BE4B92AA";
"-=-=-mxyzptlk-=-=-";
.
#22:8
((this.epoch == $epoch) || this:_invalidate()) || raise(E_FILE, "Invalid file");
return call_function("file_" + verb, this.file_handle, @args);
return;
"this.epoch == $epoch || this:_invalidate() || raise(E_FILE, \"Invalid file\");";
"return call_function(\"file_\" + verb, this.file_handle, @args);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3394F7D56169A0DBBE4A5C388BA926B2BE4B92AA";
"-=-=-mxyzptlk-=-=-";
.
#22:9
((this.epoch == $epoch) || this:_invalidate()) || raise(E_FILE, "Invalid file");
return file_eof(this.file_handle);
return;
"this.epoch == $epoch || this:_invalidate() || raise(E_FILE, \"Invalid file\");";
"return file_eof(this.file_handle);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:BF978095542F8F12E621A3CC4A7DF02A6AE066FE";
"-=-=-mxyzptlk-=-=-";
.
#24:0
if (`args[$][1] ! E_TYPE, E_RANGE' == ";")
args[$] = tostr("return ", args[$][2..$], ";");
endif
return {$lambda_proto, @args};
return;
"if (`args[$][1] ! E_TYPE, E_RANGE' == \";\")";
"  args[$] = tostr(\"return \", args[$][2..$], \";\");";
"endif";
"return {$lambda_proto, @args};";
"";
"chunk_length:4";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0B180E96359BE26F6C6657852781421033A84241";
"-=-=-mxyzptlk-=-=-";
.
#26:0
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
return;
"(ticks_left() < 10000 || seconds_left() < 2) && suspend(0);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C7B9AA9D4FFB81B732A30FE8DFCCB25794BD2172";
"-=-=-mxyzptlk-=-=-";
.
#26:1
{?old_school = 0} = args;
return (!old_school) ? ([0 -> $int_proto, 2 -> $str_proto, 3 -> $err_proto, 4 -> $list_proto, 10 -> $map_proto, 9 -> $float_proto])[typeof(this)] | typeof(this);
return;
"{?old_school = 0} = args;";
"return !old_school ? [0 -> $int_proto, 2 -> $str_proto, 3 -> $err_proto, 4 -> $list_proto, 10 -> $map_proto, 9 -> $float_proto][typeof(this)] | typeof(this);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:067CFEF398A09967430E7285E89A27E09EE31E99";
"-=-=-mxyzptlk-=-=-";
.
#26:2
return generate_json(this, @args);
return;
"return generate_json(this, @args);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D9BCBC16608002F4DBDD530226BA55CD075E90A0";
"-=-=-mxyzptlk-=-=-";
.
#27:0
return abs(this);
return;
"return abs(this);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:BA3950CF359CA8E59B1D31D1847CCB147F031551";
"-=-=-mxyzptlk-=-=-";
.
#28:0
set_task_perms(caller_perms());
{limit, @args} = args;
if (limit < this)
return this;
endif
lambda = args:_lambdafy();
while (limit >= this)
this:_suspend_if_necessary();
args && lambda:call(this);
this = this + 1;
endwhile
return this - 1;
return;
"set_task_perms(caller_perms());";
"";
"{limit, @args} = args;";
"";
"if (limit < this)";
"  return this;";
"endif";
"";
"lambda = args:_lambdafy();";
"";
"while (limit >= this)";
"  this:_suspend_if_necessary();";
"  args && lambda:call(this);";
"  this = this + 1;";
"endwhile";
"";
"return this - 1;";
"";
"chunk_length:17";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3B57112B9C4DC27E648D2A04836553A174760726";
"-=-=-mxyzptlk-=-=-";
.
#28:1
set_task_perms(caller_perms());
{limit, @args} = args;
if (limit > this)
return this;
endif
lambda = args:_lambdafy();
while (limit <= this)
this:_suspend_if_necessary();
args && lambda:call(this);
this = this - 1;
endwhile
return this + 1;
return;
"set_task_perms(caller_perms());";
"";
"{limit, @args} = args;";
"";
"if (limit > this)";
"  return this;";
"endif";
"";
"lambda = args:_lambdafy();";
"";
"while (limit <= this)";
"  this:_suspend_if_necessary();";
"  args && lambda:call(this);";
"  this = this - 1;";
"endwhile";
"";
"return this + 1;";
"";
"chunk_length:17";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9597CAE84B6371AAC5AE3D90B93B801DE451B99D";
"-=-=-mxyzptlk-=-=-";
.
#28:2
return !(this % 2);
return;
"return !(this % 2);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0283EBF523DD6CEB71F5A3620DB943F557D03239";
"-=-=-mxyzptlk-=-=-";
.
#28:3
return !(!(this % 2));
return;
"return !!(this % 2);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:852665595ADC220922DA8097C1A0ABA9B9284F25";
"-=-=-mxyzptlk-=-=-";
.
#28:4
a = this;
{b} = args;
this:_suspend_if_necessary();
if (b)
return abs(b:gcd(a % b));
else
return abs(a);
endif
return;
"a = this;";
"{b} = args;";
"";
"this:_suspend_if_necessary();";
"";
"if (b)";
"  return abs(b:gcd(a % b));";
"else";
"  return abs(a);";
"endif";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D137BA35692DEB38813DECD7CD520E7F013CA370";
"-=-=-mxyzptlk-=-=-";
.
#28:5
a = this;
{b} = args;
return abs((a * b) / a:gcd(b));
return;
"a = this;";
"{b} = args;";
"";
"return abs((a * b) / a:gcd(b));";
"";
"chunk_length:4";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:BE32B29811C44B853DDFDD829B03FEC817433868";
"-=-=-mxyzptlk-=-=-";
.
#28:6
if (this <= 1)
return 0;
else
i = 2;
while ((i * i) <= this)
if ((this % i) == 0)
return 0;
endif
i = i + 1;
endwhile
return 1;
endif
return;
"if (this <= 1)";
"  return 0;";
"else";
"  i = 2;";
"  while (i * i <= this)";
"    if (this % i == 0)";
"      return 0;";
"    endif";
"    i = i + 1;";
"  endwhile";
"  return 1;";
"endif";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B914F5972A79C399106C9BFA5F6B46F6F4732004";
"-=-=-mxyzptlk-=-=-";
.
#30:0
args && raise(E_ARGS);
if (`this[1][1] ! E_TYPE, E_RANGE' == $lambda_proto)
return this[1];
elseif ((t = typeof(this)) == LIST)
return ((length(this) == 1) && (typeof(this[1]) == LIST)) ? $lambda(@this[1]) | $lambda(@this);
elseif (t == STR)
return $lambda(this);
else
raise(E_INVIND);
endif
return;
"args && raise(E_ARGS);";
"";
"if (`this[1][1] ! E_TYPE, E_RANGE' == $lambda_proto)";
"  return this[1];";
"";
"elseif ((t = typeof(this)) == LIST)";
"  return length(this) == 1 && typeof(this[1]) == LIST ? $lambda(@this[1]) | $lambda(@this);";
"";
"elseif (t == STR)";
"  return $lambda(this);";
"";
"else";
"  raise(E_INVIND);";
"";
"endif";
"";
"chunk_length:15";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:208CE21BC32D54C1950EF2D15004A5CF22046682";
"-=-=-mxyzptlk-=-=-";
.
#30:1
set_task_perms(caller_perms());
lambda = args:_lambdafy();
if ((((t = typeof(this)) == MAP) || (t == LIST)) || (t == STR))
for v, k in (this)
this:_suspend_if_necessary();
lambda:call(v, k, this);
endfor
else
raise(E_INVIND);
endif
return this;
return;
"set_task_perms(caller_perms());";
"";
"lambda = args:_lambdafy();";
"";
"if ((t = typeof(this)) == MAP || t == LIST || t == STR)";
"  for v, k in (this)";
"    this:_suspend_if_necessary();";
"    lambda:call(v, k, this);";
"  endfor";
"else";
"  raise(E_INVIND);";
"endif";
"";
"return this;";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D5C5A1294FA2C25DF4035A85EE57294E5625BB3D";
"-=-=-mxyzptlk-=-=-";
.
#30:2
set_task_perms(caller_perms());
lambda = args:_lambdafy();
if ((t = typeof(this)) == MAP)
result = [];
for v, k in (this)
this:_suspend_if_necessary();
result[k] = lambda:call(v, k, this);
endfor
elseif (t == LIST)
result = {};
for v, i in (this)
this:_suspend_if_necessary();
result = {@result, lambda:call(v, i, this)};
endfor
elseif (t == STR)
result = "";
for v, i in (this)
this:_suspend_if_necessary();
result = tostr(result, lambda:call(v, i, this));
endfor
else
raise(E_INVIND);
endif
return result;
return;
"set_task_perms(caller_perms());";
"";
"lambda = args:_lambdafy();";
"";
"if ((t = typeof(this)) == MAP)";
"  result = [];";
"  for v, k in (this)";
"    this:_suspend_if_necessary();";
"    result[k] = lambda:call(v, k, this);";
"  endfor";
"elseif (t == LIST)";
"  result = {};";
"  for v, i in (this)";
"    this:_suspend_if_necessary();";
"    result = {@result, lambda:call(v, i, this)};";
"  endfor";
"elseif (t == STR)";
"  result = \"\";";
"  for v, i in (this)";
"    this:_suspend_if_necessary();";
"    result = tostr(result, lambda:call(v, i, this));";
"  endfor";
"else";
"  raise(E_INVIND);";
"endif";
"";
"return result;";
"";
"chunk_length:27";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6A182A88549B599A020E61B8D363453F653125F0";
"-=-=-mxyzptlk-=-=-";
.
#30:3
set_task_perms(caller_perms());
{initial, @args} = args;
lambda = args:_lambdafy();
if ((((t = typeof(this)) == MAP) || (t == LIST)) || (t == STR))
for v, k in (this)
this:_suspend_if_necessary();
initial = lambda:call(initial, v, k, this);
endfor
else
raise(E_INVIND);
endif
return initial;
return;
"set_task_perms(caller_perms());";
"";
"{initial, @args} = args;";
"";
"lambda = args:_lambdafy();";
"";
"if ((t = typeof(this)) == MAP || t == LIST || t == STR)";
"  for v, k in (this)";
"    this:_suspend_if_necessary();";
"    initial = lambda:call(initial, v, k, this);";
"  endfor";
"else";
"  raise(E_INVIND);";
"endif";
"";
"return initial;";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:00B451193757129619DE758EB6865222F1113856";
"-=-=-mxyzptlk-=-=-";
.
#30:4
set_task_perms(caller_perms());
lambda = args:_lambdafy();
if ((t = typeof(this)) == MAP)
for v, k in (this)
this:_suspend_if_necessary();
if (lambda:call(v, k, this))
return [k -> v];
endif
endfor
elseif (t == LIST)
for v, i in (this)
this:_suspend_if_necessary();
if (lambda:call(v, i, this))
return v;
endif
endfor
elseif (t == STR)
for v, i in (this)
this:_suspend_if_necessary();
if (lambda:call(v, i, this))
return v;
endif
endfor
else
raise(E_INVIND);
endif
return E_RANGE;
return;
"set_task_perms(caller_perms());";
"";
"lambda = args:_lambdafy();";
"";
"if ((t = typeof(this)) == MAP)";
"  for v, k in (this)";
"    this:_suspend_if_necessary();";
"    if (lambda:call(v, k, this))";
"      return [k -> v];";
"    endif";
"  endfor";
"elseif (t == LIST)";
"  for v, i in (this)";
"    this:_suspend_if_necessary();";
"    if (lambda:call(v, i, this))";
"      return v;";
"    endif";
"  endfor";
"elseif (t == STR)";
"  for v, i in (this)";
"    this:_suspend_if_necessary();";
"    if (lambda:call(v, i, this))";
"      return v;";
"    endif";
"  endfor";
"else";
"  raise(E_INVIND);";
"endif";
"";
"return E_RANGE;";
"";
"chunk_length:30";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9B54C30F1C5AECD5AAE7E504FE961F3E1AA5C8B6";
"-=-=-mxyzptlk-=-=-";
.
#30:5
set_task_perms(caller_perms());
lambda = args:_lambdafy();
if ((t = typeof(this)) == MAP)
result = [];
for v, k in (this)
this:_suspend_if_necessary();
if (lambda:call(v, k, this))
result[k] = v;
endif
endfor
elseif (t == LIST)
result = {};
for v, i in (this)
this:_suspend_if_necessary();
if (lambda:call(v, i, this))
result = {@result, v};
endif
endfor
elseif (t == STR)
result = "";
for v, i in (this)
this:_suspend_if_necessary();
if (lambda:call(v, i, this))
result = tostr(result, v);
endif
endfor
else
raise(E_INVIND);
endif
return result;
return;
"set_task_perms(caller_perms());";
"";
"lambda = args:_lambdafy();";
"";
"if ((t = typeof(this)) == MAP)";
"  result = [];";
"  for v, k in (this)";
"    this:_suspend_if_necessary();";
"    if (lambda:call(v, k, this))";
"      result[k] = v;";
"    endif";
"  endfor";
"elseif (t == LIST)";
"  result = {};";
"  for v, i in (this)";
"    this:_suspend_if_necessary();";
"    if (lambda:call(v, i, this))";
"      result = {@result, v};";
"    endif";
"  endfor";
"elseif (t == STR)";
"  result = \"\";";
"  for v, i in (this)";
"    this:_suspend_if_necessary();";
"    if (lambda:call(v, i, this))";
"      result = tostr(result, v);";
"    endif";
"  endfor";
"else";
"  raise(E_INVIND);";
"endif";
"";
"return result;";
"";
"chunk_length:33";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2C699D18C9ECC48F84D6F35A40FC4BFBE19E76C6";
"-=-=-mxyzptlk-=-=-";
.
#30:6
set_task_perms(caller_perms());
lambda = args:_lambdafy();
if ((t = typeof(this)) == MAP)
result = [];
for v, k in (this)
this:_suspend_if_necessary();
if (!lambda:call(v, k, this))
result[k] = v;
endif
endfor
elseif (t == LIST)
result = {};
for v, i in (this)
this:_suspend_if_necessary();
if (!lambda:call(v, i, this))
result = {@result, v};
endif
endfor
elseif (t == STR)
result = "";
for v, i in (this)
this:_suspend_if_necessary();
if (!lambda:call(v, i, this))
result = tostr(result, v);
endif
endfor
else
raise(E_INVIND);
endif
return result;
return;
"set_task_perms(caller_perms());";
"";
"lambda = args:_lambdafy();";
"";
"if ((t = typeof(this)) == MAP)";
"  result = [];";
"  for v, k in (this)";
"    this:_suspend_if_necessary();";
"    if (!lambda:call(v, k, this))";
"      result[k] = v;";
"    endif";
"  endfor";
"elseif (t == LIST)";
"  result = {};";
"  for v, i in (this)";
"    this:_suspend_if_necessary();";
"    if (!lambda:call(v, i, this))";
"      result = {@result, v};";
"    endif";
"  endfor";
"elseif (t == STR)";
"  result = \"\";";
"  for v, i in (this)";
"    this:_suspend_if_necessary();";
"    if (!lambda:call(v, i, this))";
"      result = tostr(result, v);";
"    endif";
"  endfor";
"else";
"  raise(E_INVIND);";
"endif";
"";
"return result;";
"";
"chunk_length:33";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4CBB74CF7ADB7925F095CDB7017AD2D763FCBBBF";
"-=-=-mxyzptlk-=-=-";
.
#30:7
set_task_perms(caller_perms());
lambda = args:_lambdafy();
if ((((t = typeof(this)) == MAP) || (t == LIST)) || (t == STR))
for v, k in (this)
this:_suspend_if_necessary();
if (!lambda:call(v, k, this))
return 0;
endif
endfor
else
raise(E_INVIND);
endif
return 1;
return;
"set_task_perms(caller_perms());";
"";
"lambda = args:_lambdafy();";
"";
"if ((t = typeof(this)) == MAP || t == LIST || t == STR)";
"  for v, k in (this)";
"    this:_suspend_if_necessary();";
"    if (!lambda:call(v, k, this))";
"      return 0;";
"    endif";
"  endfor";
"else";
"  raise(E_INVIND);";
"endif";
"";
"return 1;";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E50637F2A7A735C039AAEC67663C8D5A8D6A6D5E";
"-=-=-mxyzptlk-=-=-";
.
#30:8
set_task_perms(caller_perms());
lambda = args:_lambdafy();
if ((((t = typeof(this)) == MAP) || (t == LIST)) || (t == STR))
for v, k in (this)
this:_suspend_if_necessary();
if (lambda:call(v, k, this))
return 1;
endif
endfor
else
raise(E_INVIND);
endif
return 0;
return;
"set_task_perms(caller_perms());";
"";
"lambda = args:_lambdafy();";
"";
"if ((t = typeof(this)) == MAP || t == LIST || t == STR)";
"  for v, k in (this)";
"    this:_suspend_if_necessary();";
"    if (lambda:call(v, k, this))";
"      return 1;";
"    endif";
"  endfor";
"else";
"  raise(E_INVIND);";
"endif";
"";
"return 0;";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B3B0A17C2B7F9E452F81810DD8379F97C9E44324";
"-=-=-mxyzptlk-=-=-";
.
#30:9
return length(this);
return;
"return length(this);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3BB4313C64CA72A108761536D323394348A38A34";
"-=-=-mxyzptlk-=-=-";
.
#31:0
return this:_lambdafy();
return;
"return this:_lambdafy();";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:959EB05A85FBF2BC337FC649BA3AC422156EFF93";
"-=-=-mxyzptlk-=-=-";
.
#31:1
set_task_perms(caller_perms());
return this:_lambdafy():call(@args);
return;
"set_task_perms(caller_perms());";
"";
"return this:_lambdafy():call(@args);";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3723F4F2B0BD8DA95790F583FDBFBBFC4E7A778E";
"-=-=-mxyzptlk-=-=-";
.
#31:2
return call_function(verb, this, @args);
return;
"return call_function(verb, this, @args);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:1847674C287E387BE51DA2F0E670E76BF5069349";
"-=-=-mxyzptlk-=-=-";
.
#31:3
result = call_function(verb, this, @args);
return result ? {@result, @args} | {};
return;
"result = call_function(verb, this, @args);";
"return result ? {@result, @args} | {};";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:FCAD1F12A022DB5977840517AF57F9899CF9EAA0";
"-=-=-mxyzptlk-=-=-";
.
#31:4
{?sep = " "} = args;
parts = {};
if ((l = length(sep)) > 0)
this = this + sep;
while (this)
this:_suspend_if_necessary();
if ((i = index(this, sep)) > 1)
parts = {@parts, this[1..i - 1]};
endif
this = this[i + l..$];
endwhile
else
for c in (this)
parts = {@parts, c};
endfor
endif
return parts;
return;
"{?sep = \" \"} = args;";
"";
"parts = {};";
"";
"if ((l = length(sep)) > 0)";
"  this = this + sep;";
"  while (this)";
"    this:_suspend_if_necessary();";
"    if ((i = index(this, sep)) > 1)";
"      parts = {@parts, this[1..i - 1]};";
"    endif";
"    this = this[i + l..$];";
"  endwhile";
"else";
"  for c in (this)";
"    parts = {@parts, c};";
"  endfor";
"endif";
"";
"return parts;";
"";
"chunk_length:20";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:DB37D8B9C9A0D84DB5613E1E66D8D5804DA71F73";
"-=-=-mxyzptlk-=-=-";
.
#31:5
{?pattern = " "} = args;
if ((verb == "trim") || (verb == "triml"))
if ((this && pattern) && (r = match(this, tostr("^%(", pattern, "%)*"))))
this = this[r[2] + 1..$];
endif
endif
if ((verb == "trim") || (verb == "trimr"))
if ((this && pattern) && (r = match(this, tostr("%(", pattern, "%)*$"))))
this = this[1..r[1] - 1];
endif
endif
return this;
return;
"{?pattern = \" \"} = args;";
"if (verb == \"trim\" || verb == \"triml\")";
"  if (this && pattern && (r = match(this, tostr(\"^%(\", pattern, \"%)*\"))))";
"    this = this[r[2] + 1..$];";
"  endif";
"endif";
"if (verb == \"trim\" || verb == \"trimr\")";
"  if (this && pattern && (r = match(this, tostr(\"%(\", pattern, \"%)*$\"))))";
"    this = this[1..r[1] - 1];";
"  endif";
"endif";
"return this;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:1A865BF364DA2D6028E2FF30599A9715958D5EAB";
"-=-=-mxyzptlk-=-=-";
.
#31:6
if (args && (typeof(args[1]) == MAP))
{subs, ?case = 0} = args;
for value, key in (subs)
this:_suspend_if_necessary();
this = strsub(this, key, value, case);
endfor
elseif (args && (typeof(args[1]) == LIST))
{subs, ?case = 0} = args;
for item in (subs)
this:_suspend_if_necessary();
this = strsub(this, item[1], item[2], case);
endfor
elseif (args && (typeof(args[1]) == STR))
{from, to, ?case = 0} = args;
this = strsub(this, from, to, case);
else
raise(E_INVARG);
endif
return this;
return;
"if (args && typeof(args[1]) == MAP)";
"  {subs, ?case = 0} = args;";
"  for value, key in (subs)";
"    this:_suspend_if_necessary();";
"    this = strsub(this, key, value, case);";
"  endfor";
"elseif (args && typeof(args[1]) == LIST)";
"  {subs, ?case = 0} = args;";
"  for item in (subs)";
"    this:_suspend_if_necessary();";
"    this = strsub(this, item[1], item[2], case);";
"  endfor";
"elseif (args && typeof(args[1]) == STR)";
"  {from, to, ?case = 0} = args;";
"  this = strsub(this, from, to, case);";
"else";
"  raise(E_INVARG);";
"endif";
"return this;";
"";
"chunk_length:19";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E1FB0C1CEF67E67A435D3C5411D98621BF820D47";
"-=-=-mxyzptlk-=-=-";
.
#31:7
{from, to, ?case = 0} = args;
((len = length(from)) == length(to)) || raise(E_INVARG);
for i in [1..len]
this:_suspend_if_necessary();
this = strsub(this, from[i], to[i], case);
endfor
return this;
return;
"{from, to, ?case = 0} = args;";
"(len = length(from)) == length(to) || raise(E_INVARG);";
"for i in [1..len]";
"  this:_suspend_if_necessary();";
"  this = strsub(this, from[i], to[i], case);";
"endfor";
"return this;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2DCB3342FC86401C64D103A6576BDF7B0B6633EA";
"-=-=-mxyzptlk-=-=-";
.
#31:8
{length} = args;
result = "";
for i in [1..length]
result = tostr(result, this);
endfor
return result;
return;
"{length} = args;";
"";
"result = \"\";";
"for i in [1..length]";
"  result = tostr(result, this);";
"endfor";
"";
"return result;";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4A867180729BFA2110824E793DCB39CFD4917F5A";
"-=-=-mxyzptlk-=-=-";
.
#31:9
{length} = args;
result = this;
for i in [1..(length - 1) / length(this)]
result = tostr(result, this);
endfor
return result[1..length];
return;
"{length} = args;";
"";
"result = this;";
"for i in [1..((length - 1) / length(this))]";
"  result = tostr(result, this);";
"endfor";
"";
"return result[1..length];";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:67FA0B0C8110043830F16489CF65EB87AB31DD82";
"-=-=-mxyzptlk-=-=-";
.
#31:10
{length, ?fill = " "} = args;
len = length - length(this);
if (len > 0)
return tostr(fill:fill(len), this);
else
return this[^ - len..$];
endif
return;
"{length, ?fill = \" \"} = args;";
"";
"len = length - length(this);";
"";
"if (len > 0)";
"  return tostr(fill:fill(len), this);";
"else";
"  return this[^ - len..$];";
"endif";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9F2F9C5AADC10B4C5DDABF739AFF6B2777F8C232";
"-=-=-mxyzptlk-=-=-";
.
#31:11
{length, ?fill = " "} = args;
len = length - length(this);
if (len > 0)
return tostr(this, fill:fill(len));
else
return this[^..len + $];
endif
return;
"{length, ?fill = \" \"} = args;";
"";
"len = length - length(this);";
"";
"if (len > 0)";
"  return tostr(this, fill:fill(len));";
"else";
"  return this[^..len + $];";
"endif";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:BEF88A7AEC2E4F6F4EC7E30A47B29043337DE31B";
"-=-=-mxyzptlk-=-=-";
.
#31:12
{length, ?fill = " "} = args;
len = length - length(this);
if (len > 0)
return tostr(fill:fill(len / 2), this, fill:fill((len + 1) / 2));
else
return this[^ - ((len - 1) / 2)..$ + (len / 2)];
endif
return;
"{length, ?fill = \" \"} = args;";
"";
"len = length - length(this);";
"";
"if (len > 0)";
"  return tostr(fill:fill(len / 2), this, fill:fill((len + 1) / 2));";
"else";
"  return this[^ - ((len - 1) / 2)..$ + (len / 2)];";
"endif";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6D33A0A53A02BDD42863279D706BA5AB1D28DE8E";
"-=-=-mxyzptlk-=-=-";
.
#31:13
return this:strtr("abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
return;
"return this:strtr(\"abcdefghijklmnopqrstuvwxyz\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9BB1469FAAA8E776A6C8AC2D32E31011CEC4C7B4";
"-=-=-mxyzptlk-=-=-";
.
#31:14
return this:strtr("ABCDEFGHIJKLMNOPQRSTUVWXYZ", "abcdefghijklmnopqrstuvwxyz");
return;
"return this:strtr(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"abcdefghijklmnopqrstuvwxyz\");";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:FAACF84749443A766183A15DBA559F417C82464D";
"-=-=-mxyzptlk-=-=-";
.
#31:15
this = this:to_lowercase();
if (i = index("abcdefghijklmnopqrstuvwxyz", this[1], 1))
this[1] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[i];
endif
return this;
return;
"this = this:to_lowercase();";
"";
"if ((i = index(\"abcdefghijklmnopqrstuvwxyz\", this[1], 1)))";
"  this[1] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"[i];";
"endif";
"";
"return this;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5B3959347A6CB7F70548B3A8C5AF0E65ADBAB83C";
"-=-=-mxyzptlk-=-=-";
.
#31:16
{chars} = args;
for c in (chars)
this = strsub(this, c, "");
endfor
return this;
return;
"{chars} = args;";
"";
"for c in (chars)";
"  this = strsub(this, c, \"\");";
"endfor";
"";
"return this;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2DBB1D306A54F2E88EFA99486EEBB2221D66B670";
"-=-=-mxyzptlk-=-=-";
.
#31:17
return !this;
return;
"return !this;";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4C0E259F2F9CF9F35B2B07B8BEB597C440B4051C";
"-=-=-mxyzptlk-=-=-";
.
#31:18
return !(!match(this, "^[ 	]*$"));
return;
"return !!match(this, \"^[ 	]*$\");";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9F420E37E30A61F87F62CADD5D011FEF2DE208A7";
"-=-=-mxyzptlk-=-=-";
.
#31:19
{sep} = args;
len = length(sep);
if (i = index(this, sep))
return {this[^..i - 1], sep, this[i + len..$]};
endif
return {this, "", ""};
return;
"{sep} = args;";
"";
"len = length(sep);";
"";
"if ((i = index(this, sep)))";
"  return {this[^..i - 1], sep, this[i + len..$]};";
"endif";
"";
"return {this, \"\", \"\"};";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:DC60508E8A9672AAC9CA865096292D54166E1CC4";
"-=-=-mxyzptlk-=-=-";
.
#31:20
{sep} = args;
len = length(sep);
if (i = rindex(this, sep))
return {this[^..i - 1], sep, this[i + len..$]};
endif
return {"", "", this};
return;
"{sep} = args;";
"";
"len = length(sep);";
"";
"if ((i = rindex(this, sep)))";
"  return {this[^..i - 1], sep, this[i + len..$]};";
"endif";
"";
"return {\"\", \"\", this};";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F8599119B8C3D4410E9C47FF5C8EA9F3F7C4BC80";
"-=-=-mxyzptlk-=-=-";
.
#31:21
result = "";
len = length(this);
while (len)
result = result + this[len];
len = len - 1;
endwhile
return result;
return;
"result = \"\";";
"len = length(this);";
"";
"while (len)";
"  result = result + this[len];";
"  len = len - 1;";
"endwhile";
"";
"return result;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:00F1352F4CB73C7585455CEDD0CAD83B64A85CEA";
"-=-=-mxyzptlk-=-=-";
.
#31:22
{?chars = 0} = args;
result = "";
len = length(this);
last = "";
for i in [1..len]
if ((c = this[i]) == last)
continue;
endif
result = result + c;
if (chars)
if (index(chars, c))
last = c;
else
last = "";
endif
else
last = c;
endif
endfor
return result;
return;
"{?chars = 0} = args;";
"";
"result = \"\";";
"len = length(this);";
"last = \"\";";
"";
"for i in [1..len]";
"  if ((c = this[i]) == last)";
"    continue;";
"  endif";
"  result = result + c;";
"  if (chars)";
"    if (index(chars, c))";
"      last = c;";
"    else";
"      last = \"\";";
"    endif";
"  else";
"    last = c;";
"  endif";
"endfor";
"";
"return result;";
"";
"chunk_length:23";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B3481038CAE2690A1B889F4514705D53B7695CF4";
"-=-=-mxyzptlk-=-=-";
.
#31:23
len = length(this);
ret = decode_binary(this, 1);
while (len)
r = ret[len];
if ((r > 47) && (r < 57))
ret[len] = r + 1;
break;
elseif (r == 57)
ret[len] = 65;
break;
elseif ((r > 64) && (r < 90))
ret[len] = r + 1;
break;
elseif (r == 90)
ret[len] = 97;
break;
elseif ((r > 96) && (r < 122))
ret[len] = r + 1;
break;
elseif ((r == 122) && (len > 1))
ret[len] = 48;
len = len - 1;
elseif (r == 122)
raise(E_INVARG, "Overflow");
else
len = len - 1;
endif
endwhile
return encode_binary(ret);
return;
"len = length(this);";
"ret = decode_binary(this, 1);";
"";
"while (len)";
"  r = ret[len];";
"  if (r > 47 && r < 57)";
"    ret[len] = r + 1;";
"    break;";
"  elseif (r == 57)";
"    ret[len] = 65;";
"    break;";
"  elseif (r > 64 && r < 90)";
"    ret[len] = r + 1;";
"    break;";
"  elseif (r == 90)";
"    ret[len] = 97;";
"    break;";
"  elseif (r > 96 && r < 122)";
"    ret[len] = r + 1;";
"    break;";
"  elseif (r == 122 && len > 1)";
"    ret[len] = 48;";
"    len = len - 1;";
"  elseif (r == 122)";
"    raise(E_INVARG, \"Overflow\");";
"  else";
"    len = len - 1;";
"  endif";
"endwhile";
"";
"return encode_binary(ret);";
"";
"chunk_length:31";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:8A3D41B8028C48941659E9087689792D1FE3FAAE";
"-=-=-mxyzptlk-=-=-";
.
#31:24
len = length(this);
ret = decode_binary(this, 1);
while (len)
r = ret[len];
if ((r > 97) && (r < 123))
ret[len] = r - 1;
break;
elseif (r == 97)
ret[len] = 90;
break;
elseif ((r > 65) && (r < 91))
ret[len] = r - 1;
break;
elseif (r == 65)
ret[len] = 57;
break;
elseif ((r > 48) && (r < 58))
ret[len] = r - 1;
break;
elseif ((r == 48) && (len > 1))
ret[len] = 122;
len = len - 1;
elseif ((r == 48) && (len == 1))
raise(E_INVARG, "Underflow");
else
len = len - 1;
endif
endwhile
return encode_binary(ret);
return;
"len = length(this);";
"ret = decode_binary(this, 1);";
"";
"while (len)";
"  r = ret[len];";
"  if (r > 97 && r < 123)";
"    ret[len] = r - 1;";
"    break;";
"  elseif (r == 97)";
"    ret[len] = 90;";
"    break;";
"  elseif (r > 65 && r < 91)";
"    ret[len] = r - 1;";
"    break;";
"  elseif (r == 65)";
"    ret[len] = 57;";
"    break;";
"  elseif (r > 48 && r < 58)";
"    ret[len] = r - 1;";
"    break;";
"  elseif (r == 48 && len > 1)";
"    ret[len] = 122;";
"    len = len - 1;";
"  elseif (r == 48 && len == 1)";
"    raise(E_INVARG, \"Underflow\");";
"  else";
"    len = len - 1;";
"  endif";
"endwhile";
"";
"return encode_binary(ret);";
"";
"chunk_length:31";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F03034D0022F5AB0E04A0AE64F1360E066259BD8";
"-=-=-mxyzptlk-=-=-";
.
#31:25
return string_hash(this, @args);
return;
"return string_hash(this, @args);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:1324D17460EAA1CD90E466F6F52C367D7A309F6B";
"-=-=-mxyzptlk-=-=-";
.
#33:0
return this:_lambdafy();
return;
"return this:_lambdafy();";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:959EB05A85FBF2BC337FC649BA3AC422156EFF93";
"-=-=-mxyzptlk-=-=-";
.
#33:1
set_task_perms(caller_perms());
return this:_lambdafy():call(@args);
return;
"set_task_perms(caller_perms());";
"";
"return this:_lambdafy():call(@args);";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3723F4F2B0BD8DA95790F583FDBFBBFC4E7A778E";
"-=-=-mxyzptlk-=-=-";
.
#33:2
return setadd(this, @args);
return;
"return setadd(this, @args);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:CE7621ACACF94FCC88B65B17F7158B58DE71DA91";
"-=-=-mxyzptlk-=-=-";
.
#33:3
return setremove(this, @args);
return;
"return setremove(this, @args);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D11EF59399D367FDF9581B5F3F840CD0525D6740";
"-=-=-mxyzptlk-=-=-";
.
#33:4
{LIST} = args;
for i in (LIST)
this:_suspend_if_necessary();
this = setadd(this, i);
endfor
return this;
return;
"{list} = args;";
"";
"for i in (list)";
"  this:_suspend_if_necessary();";
"  this = setadd(this, i);";
"endfor";
"";
"return this;";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:8093E1F1B5AE3659A8640604A77593E00B6B0B0B";
"-=-=-mxyzptlk-=-=-";
.
#33:5
{LIST} = args;
result = {};
for i in (LIST)
this:_suspend_if_necessary();
if (i in this)
result = setadd(result, i);
endif
endfor
return result;
return;
"{list} = args;";
"";
"result = {};";
"";
"for i in (list)";
"  this:_suspend_if_necessary();";
"  if (i in this)";
"    result = setadd(result, i);";
"  endif";
"endfor";
"";
"return result;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:03B3C8BB2D0698F44CF4653FB5EFA39DAE32B648";
"-=-=-mxyzptlk-=-=-";
.
#33:6
{LIST} = args;
for i in (LIST)
this:_suspend_if_necessary();
this = setremove(this, i);
endfor
return this;
return;
"{list} = args;";
"";
"for i in (list)";
"  this:_suspend_if_necessary();";
"  this = setremove(this, i);";
"endfor";
"";
"return this;";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:488B8E756A8AFEB64308138FC3C8DE99BF9540D1";
"-=-=-mxyzptlk-=-=-";
.
#33:7
{?sep = " "} = args;
res = "";
for i in (this)
this:_suspend_if_necessary();
i = tostr(i);
res = res + (res ? sep + i | i);
endfor
return res;
return;
"{?sep = \" \"} = args;";
"";
"res = \"\";";
"";
"for i in (this)";
"  this:_suspend_if_necessary();";
"  i = tostr(i);";
"  res = res + (res ? sep + i | i);";
"endfor";
"";
"return res;";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D4406C542915510EDFBD3BFEEAFDD7C1B9079ED4";
"-=-=-mxyzptlk-=-=-";
.
#33:8
args && raise(E_ARGS);
l = length(this);
i = 1;
while (i <= l)
v = this[i];
j = i - 1;
while (j > 0)
this:_suspend_if_necessary();
if (this[j] <= v)
break;
endif
this[j + 1] = this[j];
j = j - 1;
endwhile
this[j + 1] = v;
i = i + 1;
endwhile
return this;
return;
"args && raise(E_ARGS);";
"";
"l = length(this);";
"i = 1;";
"while (i <= l)";
"  v = this[i];";
"  j = i - 1;";
"  while (j > 0)";
"    this:_suspend_if_necessary();";
"    if (this[j] <= v)";
"      break;";
"    endif";
"    this[j + 1] = this[j];";
"    j = j - 1;";
"  endwhile";
"  this[j + 1] = v;";
"  i = i + 1;";
"endwhile";
"";
"return this;";
"";
"chunk_length:20";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B81C52D295D77B5B6F3277DADF44FEFFAFBFFA0D";
"-=-=-mxyzptlk-=-=-";
.
#33:9
args && raise(E_ARGS);
l = length(this);
i = 1;
while (i <= (l / 2))
this:_suspend_if_necessary();
t = this[i];
this[i] = this[($ - i) + 1];
this[($ - i) + 1] = t;
i = i + 1;
endwhile
return this;
return;
"args && raise(E_ARGS);";
"";
"l = length(this);";
"i = 1;";
"while (i <= l / 2)";
"  this:_suspend_if_necessary();";
"  t = this[i];";
"  this[i] = this[$ - i + 1];";
"  this[$ - i + 1] = t;";
"  i = i + 1;";
"endwhile";
"";
"return this;";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:138A432FDF55E23108C799F02D3A15516F48B2B1";
"-=-=-mxyzptlk-=-=-";
.
#33:10
nth = args ? (length(args) > 1) ? args | args[1] | 1;
res = {};
if (typeof(nth) == LIST)
for i in (this)
out = {};
for n in (nth)
this:_suspend_if_necessary();
out = {@out, i[n]};
endfor
res = {@res, out};
endfor
else
for i in (this)
this:_suspend_if_necessary();
res = {@res, i[nth]};
endfor
endif
return res;
return;
"nth = args ? length(args) > 1 ? args | args[1] | 1;";
"";
"res = {};";
"";
"if (typeof(nth) == LIST)";
"  for i in (this)";
"    out = {};";
"    for n in (nth)";
"      this:_suspend_if_necessary();";
"      out = {@out, i[n]};";
"    endfor";
"    res = {@res, out};";
"  endfor";
"else";
"  for i in (this)";
"    this:_suspend_if_necessary();";
"    res = {@res, i[nth]};";
"  endfor";
"endif";
"";
"return res;";
"";
"chunk_length:21";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C332694FE2E63092AEAC24BD016B449B87054AAA";
"-=-=-mxyzptlk-=-=-";
.
#33:11
{?depth = 2147483647} = args;
new = {};
for item in (this)
this:_suspend_if_necessary();
if ((typeof(item) == LIST) && depth)
new = {@new, @item:flatten(depth - 1)};
else
new = {@new, item};
endif
endfor
return new;
return;
"{?depth = 2147483647} = args;";
"";
"new = {};";
"";
"for item in (this)";
"  this:_suspend_if_necessary();";
"  if (typeof(item) == LIST && depth)";
"    new = {@new, @item:flatten(depth - 1)};";
"  else";
"    new = {@new, item};";
"  endif";
"endfor";
"";
"return new;";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:EC6B518FEDA2CFC6C8057D094A5AB143573A2310";
"-=-=-mxyzptlk-=-=-";
.
#33:12
result = {};
for e in (this)
result = setadd(result, e);
endfor
return result;
return;
"result = {};";
"";
"for e in (this)";
"  result = setadd(result, e);";
"endfor";
"";
"return result;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F92B516AA7EE3D141BE2F543E1BBF28A2C54B64E";
"-=-=-mxyzptlk-=-=-";
.
#33:13
result = {};
for e in (this)
if (`e == last ! E_VARNF => 0')
continue;
endif
result = {@result, e};
last = e;
endfor
return result;
return;
"result = {};";
"";
"for e in (this)";
"  if (`e == last ! E_VARNF => 0')";
"    continue;";
"  endif";
"  result = {@result, e};";
"  last = e;";
"endfor";
"";
"return result;";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C9CADB95BFDEE0C8E957A890AA53408CEE3008F0";
"-=-=-mxyzptlk-=-=-";
.
#33:14
{el} = args;
while (i = el in this)
this = listdelete(this, i);
endwhile
return this;
return;
"{el} = args;";
"";
"while (i = (el in this))";
"  this = listdelete(this, i);";
"endwhile";
"";
"return this;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6EA8F8BFCBB606959B60224F53F4DB14E75ED9A9";
"-=-=-mxyzptlk-=-=-";
.
#33:15
{length} = args;
result = {};
for i in [1..length]
result = {@result, @this};
endfor
return result;
return;
"{length} = args;";
"";
"result = {};";
"for i in [1..length]";
"  result = {@result, @this};";
"endfor";
"";
"return result;";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9737EB1FF7CF6F7474771F3F440ABE614298FAED";
"-=-=-mxyzptlk-=-=-";
.
#33:16
{el} = args;
count = 0;
while (i = el in this)
count = count + 1;
this = this[i + 1..$];
endwhile
return count;
return;
"{el} = args;";
"";
"count = 0;";
"";
"while (i = (el in this))";
"  count = count + 1;";
"  this = this[i + 1..$];";
"endwhile";
"";
"return count;";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E6CEBBF3C5FE9698B7A7456838C8932D107499FB";
"-=-=-mxyzptlk-=-=-";
.
#33:17
return !this;
return;
"return !this;";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4C0E259F2F9CF9F35B2B07B8BEB597C440B4051C";
"-=-=-mxyzptlk-=-=-";
.
#33:18
{length} = args;
this:_suspend_if_necessary();
if (length > length(this))
return {};
elseif (length == 0)
return {{}};
elseif (length == 1)
result = {};
for e in (this)
result = {@result, {e}};
endfor
return result;
else
result = {};
{e, @rest} = this;
for r in (rest:combinations(length - 1))
result = {@result, {e, @r}};
endfor
return {@result, @rest:combinations(length)};
endif
return;
"{length} = args;";
"";
"this:_suspend_if_necessary();";
"";
"if (length > length(this))";
"  return {};";
"elseif (length == 0)";
"  return {{}};";
"elseif (length == 1)";
"  result = {};";
"  for e in (this)";
"    result = {@result, {e}};";
"  endfor";
"  return result;";
"else";
"  result = {};";
"  {e, @rest} = this;";
"  for r in (rest:combinations(length - 1))";
"    result = {@result, {e, @r}};";
"  endfor";
"  return {@result, @rest:combinations(length)};";
"endif";
"";
"chunk_length:22";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:992F306D251624E202D17BDB5BC7CFDE3D8BA266";
"-=-=-mxyzptlk-=-=-";
.
#33:19
{length} = args;
this:_suspend_if_necessary();
if (length > length(this))
return {};
elseif (length == 0)
return {{}};
elseif (length == 1)
result = {};
for e in (this)
result = {@result, {e}};
endfor
return result;
else
result = {};
for i in [1..length(this)]
e = this[i];
rest = listdelete(this, i);
for r in (rest:permutations(length - 1))
result = {@result, {e, @r}};
endfor
endfor
return result;
endif
return;
"{length} = args;";
"";
"this:_suspend_if_necessary();";
"";
"if (length > length(this))";
"  return {};";
"elseif (length == 0)";
"  return {{}};";
"elseif (length == 1)";
"  result = {};";
"  for e in (this)";
"    result = {@result, {e}};";
"  endfor";
"  return result;";
"else";
"  result = {};";
"  for i in [1..length(this)]";
"    e = this[i];";
"    rest = listdelete(this, i);";
"    for r in (rest:permutations(length - 1))";
"      result = {@result, {e, @r}};";
"    endfor";
"  endfor";
"  return result;";
"endif";
"";
"chunk_length:25";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3D2EED80CA17D9C00F29C48ECE44EE30154AE9F4";
"-=-=-mxyzptlk-=-=-";
.
#33:20
{other} = args;
result = {};
for i in (this)
for j in (other)
this:_suspend_if_necessary();
result = {@result, {i, j}};
endfor
endfor
return result;
return;
"{other} = args;";
"";
"result = {};";
"";
"for i in (this)";
"  for j in (other)";
"    this:_suspend_if_necessary();";
"    result = {@result, {i, j}};";
"  endfor";
"endfor";
"";
"return result;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:352238C906053AF2346862E8C758A2B9A6F5C504";
"-=-=-mxyzptlk-=-=-";
.
#33:21
{?count = 1} = args;
count = count % length(this);
if (count > 0)
return {@this[count + 1..$], @this[^..count]};
elseif (count < 0)
return {@this[($ + count) + 1..$], @this[^..$ + count]};
else
return this;
endif
return;
"{?count = 1} = args;";
"";
"count = count % length(this);";
"";
"if (count > 0)";
"  return {@this[count + 1..$], @this[^..count]};";
"elseif (count < 0)";
"  return {@this[$ + count + 1..$], @this[^..$ + count]};";
"else";
"  return this;";
"endif";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:EABCD5EA5CBECD80475F30B97794A5CB04BFD936";
"-=-=-mxyzptlk-=-=-";
.
#33:22
result = {};
while (this)
l = length(this);
i = random(l);
result = {@result, this[i]};
this = listdelete(this, i);
endwhile
return result;
return;
"result = {};";
"";
"while (this)";
"  l = length(this);";
"  i = random(l);";
"  result = {@result, this[i]};";
"  this = listdelete(this, i);";
"endwhile";
"";
"return result;";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B8DB876B98F2948711D6C5B2CCF39271973180BE";
"-=-=-mxyzptlk-=-=-";
.
#33:23
{?length = 1} = args;
return this:shuffle()[1..length];
return;
"{?length = 1} = args;";
"";
"return this:shuffle()[1..length];";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A3288483A92BF630845BDAA5A49DF0E190D86A22";
"-=-=-mxyzptlk-=-=-";
.
#33:24
result = [];
for pair in (this)
result[pair[1]] = pair[2];
endfor
return result;
return;
"result = [];";
"";
"for pair in (this)";
"  result[pair[1]] = pair[2];";
"endfor";
"";
"return result;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4ABFD312B6D48D9A2205DD94798EA17E127BE8ED";
"-=-=-mxyzptlk-=-=-";
.
#33:25
if (args)
{n} = args;
return this[^..(^ + n) - 1];
else
return this[^];
endif
return;
"if (args)";
"  {n} = args;";
"  return this[^ .. (^ + n - 1)];";
"else";
"  return this[^];";
"endif";
"";
"chunk_length:6";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A55D75A8BEB44138FFF361AACC31163F4B445514";
"-=-=-mxyzptlk-=-=-";
.
#33:26
if (args)
{n} = args;
return this[($ - n) + 1..$];
else
return this[$];
endif
return;
"if (args)";
"  {n} = args;";
"  return this[($ - n + 1) .. $];";
"else";
"  return this[$];";
"endif";
"";
"chunk_length:6";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:65A81226F4611739AE2F087089F0C81DD4BFE54A";
"-=-=-mxyzptlk-=-=-";
.
#34:0
return mapkeys(this);
return;
"return mapkeys(this);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9354D8C0778D6BDE7497E321636C58BEDF4AEFD2";
"-=-=-mxyzptlk-=-=-";
.
#34:1
return mapvalues(this);
return;
"return mapvalues(this);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:86EC57648206C350FB011EA997EB935E8FB8875C";
"-=-=-mxyzptlk-=-=-";
.
#34:2
for arg in (args)
this:_suspend_if_necessary();
this = mapdelete(this, arg);
endfor
return this;
return;
"for arg in (args)";
"  this:_suspend_if_necessary();";
"  this = mapdelete(this, arg);";
"endfor";
"";
"return this;";
"";
"chunk_length:6";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:369BE6E36CD5566ACD55F3FF34AED7DF99FA8052";
"-=-=-mxyzptlk-=-=-";
.
#34:3
{p, ?d = E_RANGE} = args;
{f, @r} = p;
v = `r ? (typeof(this[f]) == MAP) ? this[f]:value_by_path(r) | E_RANGE | this[f] ! E_RANGE => d';
return v;
return;
"{p, ?d = E_RANGE} = args;";
"";
"{f, @r} = p;";
"";
"v = `r ? typeof(this[f]) == MAP ? this[f]:value_by_path(r) | E_RANGE | this[f] ! E_RANGE => d';";
"";
"return v;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A2DABC4108AE2E5D73D8C3E7A55F42778DBEF074";
"-=-=-mxyzptlk-=-=-";
.
#34:4
{p, v} = args;
{f, @r} = p;
this[f] = r ? `(typeof(this[f]) == MAP) ? this[f] | ([]) ! E_RANGE => []':set_value_by_path(r, v) | v;
return this;
return;
"{p, v} = args;";
"";
"{f, @r} = p;";
"";
"this[f] = r ? `typeof(this[f]) == MAP ? this[f] | [] ! E_RANGE => []':set_value_by_path(r, v) | v;";
"";
"return this;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5381C2F8F679EE2FEA399FE9FC24331EA02468A7";
"-=-=-mxyzptlk-=-=-";
.
#34:5
{MAP} = args;
for value, key in (MAP)
this:_suspend_if_necessary();
this[key] = value;
endfor
return this;
return;
"{map} = args;";
"for value, key in (map)";
"  this:_suspend_if_necessary();";
"  this[key] = value;";
"endfor";
"return this;";
"";
"chunk_length:6";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:7AE99586C027B648096509215D1DBDB6D3009054";
"-=-=-mxyzptlk-=-=-";
.
#34:6
return !this;
return;
"return !this;";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4C0E259F2F9CF9F35B2B07B8BEB597C440B4051C";
"-=-=-mxyzptlk-=-=-";
.
#34:7
{key} = args;
return `(!(!this[key])) || 1 ! E_RANGE => 0';
return;
"{key} = args;";
"";
"return `!!this[key] || 1 ! E_RANGE => 0';";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9101D22DD497F48848F98FC706704A041E95126B";
"-=-=-mxyzptlk-=-=-";
.
#34:8
{value} = args;
return !(!(value in this));
return;
"{value} = args;";
"";
"return !!(value in this);";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E1F1C80AE4C5FE78B47D4953F5EB2BB91421EE5B";
"-=-=-mxyzptlk-=-=-";
.
#34:9
result = [];
for v, k in (this)
result[v] = k;
endfor
return result;
return;
"result = [];";
"";
"for v, k in (this)";
"  result[v] = k;";
"endfor";
"";
"return result;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:FAEC89998AEB147CDBA3D84A4ECF6B56398741C0";
"-=-=-mxyzptlk-=-=-";
.
#34:10
keys = args;
result = [];
for key in (keys)
result[key] = this[key];
endfor
return result;
return;
"keys = args;";
"";
"result = [];";
"";
"for key in (keys)";
"  result[key] = this[key];";
"endfor";
"";
"return result;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C3F8ACAF794C287802C40372FC82D10112E92EED";
"-=-=-mxyzptlk-=-=-";
.
#34:11
result = {};
for value, key in (this)
result = {@result, {key, value}};
endfor
return result;
return;
"result = {};";
"";
"for value, key in (this)";
"  result = {@result, {key, value}};";
"endfor";
"";
"return result;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:EE280278088C02E59BE7A70BF96E163377A0CD9C";
"-=-=-mxyzptlk-=-=-";
.
#35:0
(this == $lambda_proto) || raise(E_VERBNF);
return $lambda(@args);
return;
"this == $lambda_proto || raise(E_VERBNF);";
"return $lambda(@args);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:77F339663AA8C1DF0EBDBBC1BC629559F6FC15BA";
"-=-=-mxyzptlk-=-=-";
.
#35:1
return this;
return;
"return this;";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:58CFE4977A49A7695FEE4D2F29BB87606D70E92F";
"-=-=-mxyzptlk-=-=-";
.
#35:2
return caller;
return;
"return caller;";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:ABE6F07484C492170E9B7C2F68E0552B0D80DCCE";
"-=-=-mxyzptlk-=-=-";
.
#35:3
{args} = args;
if ((l = length(args)) > 1)
return {args[2..l - 1], args[$]};
else
return {{}, ""};
endif
return;
"{args} = args;";
"";
"if ((l = length(args)) > 1)";
"  return {args[2..l - 1], args[$]};";
"else";
"  return {{}, \"\"};";
"endif";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:995FD2218B9314F5C19EFC6D82D8018EF9AF398D";
"-=-=-mxyzptlk-=-=-";
.
#35:4
{MAP, params, body} = args;
for value, key in (MAP)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (key in params)
params = setremove(params, key);
else
raise(E_INVARG, tostr("Not a formal parameter:  ", key));
endif
body = tostr(key, " = ", toliteral(value), "; ", body);
endfor
return {params, body};
return;
"{map, params, body} = args;";
"";
"for value, key in (map)";
"  (ticks_left() < 10000 || seconds_left() < 2) && suspend(0);";
"  if (key in params)";
"    params = setremove(params, key);";
"  else";
"    raise(E_INVARG, tostr(\"Not a formal parameter:  \", key));";
"  endif";
"  body = tostr(key, \" = \", toliteral(value), \"; \", body);";
"endfor";
"";
"return {params, body};";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:71D73EBA75C8973EC7663FC1EF7AC1A7BF2ED075";
"-=-=-mxyzptlk-=-=-";
.
#35:5
{?MAP = []} = args;
{params, body} = this:_params_and_body(caller);
{params, body} = this:_prepend_assignments(MAP, params, body);
return $lambda(@params, body);
return;
"{?map = []} = args;";
"";
"{params, body} = this:_params_and_body(caller);";
"";
"{params, body} = this:_prepend_assignments(map, params, body);";
"";
"return $lambda(@params, body);";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B261DE92E9B55AFED2085388539CAF1B038EF98F";
"-=-=-mxyzptlk-=-=-";
.
#35:6
{object, ?MAP = []} = args;
{params, body} = this:_params_and_body(caller);
{params, body} = this:_prepend_assignments(MAP, params, body);
body = tostr("this = ", toliteral(object), "; ", body);
return $lambda(@params, body);
return;
"{object, ?map = []} = args;";
"";
"{params, body} = this:_params_and_body(caller);";
"";
"{params, body} = this:_prepend_assignments(map, params, body);";
"";
"body = tostr(\"this = \", toliteral(object), \"; \", body);";
"";
"return $lambda(@params, body);";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:EA2B3A9B04DF3AD881675E728160DFD504406DEB";
"-=-=-mxyzptlk-=-=-";
.
#35:7
set_task_perms(caller_perms());
{params, body} = this:_params_and_body(caller);
if (length(args) < (l = length(params)))
raise(E_ARGS, tostr("Too few arguments:  ", params:join(", "), " required"));
endif
for i in [1..l]
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
body = tostr(params[i], " = ", toliteral(args[i]), "; ", body);
endfor
result = eval(body);
result[1] || raise("E_SYNTAX", "Syntax error", result[2]);
return result[2];
return;
"set_task_perms(caller_perms());";
"";
"{params, body} = this:_params_and_body(caller);";
"";
"if (length(args) < (l = length(params)))";
"  raise(E_ARGS, tostr(\"Too few arguments:  \", params:join(\", \"), \" required\"));";
"endif";
"";
"for i in [1..l]";
"  (ticks_left() < 10000 || seconds_left() < 2) && suspend(0);";
"  body = tostr(params[i], \" = \", toliteral(args[i]), \"; \", body);";
"endfor";
"";
"result = eval(body);";
"";
"result[1] || raise(\"E_SYNTAX\", \"Syntax error\", result[2]);";
"";
"return result[2];";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:36A490B9D5E231CB51F4D5EE750D79D80FB39E0D";
"-=-=-mxyzptlk-=-=-";
.
#36:0
set_task_perms(caller_perms());
(typeof(this) == LIST) || raise(E_INVIND, "Only type list");
{_, name, programmer, location, _} = callers()[1];
if ((name && (programmer == $nothing)) && (location == $nothing))
return;
endif
if (this && ((prototype = this[1]) in $frobs))
return prototype:(verb)(@args);
endif
return pass(@args);
return;
"set_task_perms(caller_perms());";
"";
"/* only lists */";
"typeof(this) == LIST || raise(E_INVIND, \"Only type list\");";
"";
"/* don't respond to calls from built-ins */";
"{_, name, programmer, location, _} = callers()[1];";
"if (name && programmer == $nothing && location == $nothing)";
"  return;";
"endif";
"";
"if (this && (prototype = this[1]) in $frobs)";
"  return prototype:(verb)(@args);";
"endif";
"";
"return pass(@args);";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0E68D8B527E7823629D3B988205F34F46FF127B4";
"-=-=-mxyzptlk-=-=-";
.
#37:0
set_task_perms(caller_perms());
(typeof(this) == MAP) || raise(E_INVIND, "Only type map");
{_, name, programmer, location, _} = callers()[1];
if ((name && (programmer == $nothing)) && (location == $nothing))
return;
endif
if (this && (`prototype = this["prototype"] ! E_RANGE' in $frobs))
return prototype:(verb)(@args);
endif
return pass(@args);
return;
"set_task_perms(caller_perms());";
"";
"/* only maps */";
"typeof(this) == MAP || raise(E_INVIND, \"Only type map\");";
"";
"/* don't respond to calls from built-ins */";
"{_, name, programmer, location, _} = callers()[1];";
"if (name && programmer == $nothing && location == $nothing)";
"  return;";
"endif";
"";
"if (this && `prototype = this[\"prototype\"] ! E_RANGE' in $frobs)";
"  return prototype:(verb)(@args);";
"endif";
"";
"return pass(@args);";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:8487D577477B3464C8E36F9AA0C8926B0A61EDB4";
"-=-=-mxyzptlk-=-=-";
.
#38:0
$restrict_to_caller($composed);
$external_compilers["application/x-moocode;version=0.0.*"] = $plastic.compiler;
return;
"$restrict_to_caller($composed);";
"$external_compilers[\"application/x-moocode;version=0.0.*\"] = $plastic.compiler;";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:1141F27A197F9CE525E186033DEDD522B36E6B52";
"-=-=-mxyzptlk-=-=-";
.
#38:1
$restrict_to_caller($composed);
$external_compilers = $external_compilers:delete("application/x-moocode;version=0.0.*");
return;
"$restrict_to_caller($composed);";
"$external_compilers = $external_compilers:delete(\"application/x-moocode;version=0.0.*\");";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B25D68C0ADFC8A4804A5442731A130616F451C0E";
"-=-=-mxyzptlk-=-=-";
.
#41:0
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
return;
"(ticks_left() < 10000 || seconds_left() < 2) && suspend(0);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C7B9AA9D4FFB81B732A30FE8DFCCB25794BD2172";
"-=-=-mxyzptlk-=-=-";
.
#41:1
{parser, separator, infix, terminator, ?symbols = {}} = args;
ids = {};
for symbol in (symbols)
ids = {@ids, parser:push(@symbol)};
endfor
if (terminator && (parser:token().id == terminator))
return {};
endif
key = parser:expression(0);
parser:advance(infix);
value = parser:expression(0);
MAP = {{key, value}};
while (parser:token().id == separator)
this:suspend_if_necessary();
MAP && parser:advance(separator);
key = parser:expression(0);
parser:advance(infix);
value = parser:expression(0);
MAP = {@MAP, {key, value}};
endwhile
for id in (ids)
parser:pop(id);
endfor
return MAP;
return;
"{parser, separator, infix, terminator, ?symbols = {}} = args;";
"";
"ids = {};";
"for symbol in (symbols)";
"  ids = {@ids, parser:push(@symbol)};";
"endfor";
"";
"if (terminator && parser:token().id == terminator)";
"  return {};";
"endif";
"";
"key = parser:expression(0);";
"parser:advance(infix);";
"value = parser:expression(0);";
"map = {{key, value}};";
"";
"while (parser:token().id == separator)";
"  this:suspend_if_necessary();";
"  map && parser:advance(separator);";
"  key = parser:expression(0);";
"  parser:advance(infix);";
"  value = parser:expression(0);";
"  map = {@map, {key, value}};";
"endwhile";
"";
"for id in (ids)";
"  parser:pop(id);";
"endfor";
"";
"return map;";
"";
"chunk_length:30";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:474311B60CEBDC2D767B8DBD4CD2945317515F00";
"-=-=-mxyzptlk-=-=-";
.
#41:2
{parser, separator, terminator, ?symbols = "defaults"} = args;
if (symbols && (symbols == "defaults"))
symbols = {{"@", 0, this.plastic.prefix_operator_proto}};
endif
ids = {};
for symbol in (symbols)
ids = {@ids, parser:push(@symbol)};
endfor
if (terminator && (parser:token().id == terminator))
return {};
endif
expression = parser:expression(0);
LIST = {expression};
while (parser:token().id == separator)
this:suspend_if_necessary();
parser:advance(separator);
expression = parser:expression(0);
LIST = {@LIST, expression};
endwhile
for id in (ids)
parser:pop(id);
endfor
return LIST;
return;
"{parser, separator, terminator, ?symbols = \"defaults\"} = args;";
"";
"/* enable defaults */";
"if (symbols && symbols == \"defaults\")";
"  symbols = {{\"@\", 0, this.plastic.prefix_operator_proto}};";
"endif";
"";
"ids = {};";
"for symbol in (symbols)";
"  ids = {@ids, parser:push(@symbol)};";
"endfor";
"";
"if (terminator && parser:token().id == terminator)";
"  return {};";
"endif";
"";
"expression = parser:expression(0);";
"list = {expression};";
"";
"while (parser:token().id == separator)";
"  this:suspend_if_necessary();";
"  parser:advance(separator);";
"  expression = parser:expression(0);";
"  list = {@list, expression};";
"endwhile";
"";
"for id in (ids)";
"  parser:pop(id);";
"endfor";
"";
"return list;";
"";
"chunk_length:31";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6FEB895CC428DF005B46D141E6ABC5D9BDA89B83";
"-=-=-mxyzptlk-=-=-";
.
#41:3
{parser, pattern} = args;
state = 1;
for element in (pattern)
if ((state == 1) && (element.type == "variable"))
continue;
elseif ((((state == 1) || (state == 2)) && (element.type == "binary")) && (element.id == "="))
if (element.first.type == "variable")
state = 2;
continue;
endif
elseif ((((state == 1) || (state == 2)) && (element.type == "unary")) && (element.id == "@"))
if (element.first.type == "variable")
state = 3;
continue;
endif
endif
raise("Syntax error", "Illegal scattering pattern", parser);
endfor
return;
"{parser, pattern} = args;";
"";
"state = 1;";
"";
"for element in (pattern)";
"  if (state == 1 && element.type == \"variable\")";
"    continue;";
"  elseif ((state == 1 || state == 2) && element.type == \"binary\" && element.id == \"=\")";
"    if (element.first.type == \"variable\")";
"      state = 2;";
"      continue;";
"    endif";
"  elseif ((state == 1 || state == 2) && element.type == \"unary\" && element.id == \"@\")";
"    if (element.first.type == \"variable\")";
"      state = 3;";
"      continue;";
"    endif";
"  endif";
"";
"  raise(\"Syntax error\", \"Illegal scattering pattern\", parser);";
"endfor";
"";
"chunk_length:21";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6DC3B53967446EAB01EE576267459D8598505807";
"-=-=-mxyzptlk-=-=-";
.
#41:4
{node} = args;
if (typeof(node) == LIST)
return node;
elseif (`typeof(value = node.value) == LIST ! ANY')
return value;
else
children = {};
for prop in ({"first", "second", "third"})
if (`value = node.(prop) ! E_PROPNF => 0' != 0)
children = {@children, value};
endif
endfor
return children;
endif
return;
"{node} = args;";
"";
"/* Intelligently gather children from various places.";
" */";
"";
"if (typeof(node) == LIST)";
"  return node;";
"elseif (`typeof(value = node.value) == LIST ! ANY')";
"  return value;";
"else";
"  children = {};";
"  for prop in ({\"first\", \"second\", \"third\"})";
"    if (`value = node.(prop) ! E_PROPNF => 0' != 0)";
"      children = {@children, value};";
"    endif";
"  endfor";
"  return children;";
"endif";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F9D17E1580E0ABE09BCBB3C38E32B585B4A9FC58";
"-=-=-mxyzptlk-=-=-";
.
#41:5
{root, pattern} = args;
keys = pattern:keys();
matches = {};
stack = {root};
while next (stack)
this:suspend_if_necessary();
{top, @stack} = stack;
stack = {@stack, @this:children(top)};
if ((typeof(top) == ANON) && isa(top, this.plastic.symbol_proto))
for key in (keys)
if (top.(key) != pattern[key])
continue next;
endif
endfor
matches = {@matches, top};
endif
endwhile
return matches;
return;
"{root, pattern} = args;";
"";
"/* Pattern is a map.  The keys specify the properties (`id', `type',";
" * etc.) to match on.  The values specify the property values for the";
" * match comparison.  Conducts a depth first search for pattern.";
" */";
"";
"keys = pattern:keys();";
"matches = {};";
"stack = {root};";
"";
"while next (stack)";
"  this:suspend_if_necessary();";
"  {top, @stack} = stack;";
"  stack = {@stack, @this:children(top)};";
"  if (typeof(top) == ANON && isa(top, this.plastic.symbol_proto))";
"    for key in (keys)";
"      if (top.(key) != pattern[key])";
"        continue next;";
"      endif";
"    endfor";
"    matches = {@matches, top};";
"  endif";
"endwhile";
"";
"return matches;";
"";
"chunk_length:26";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E2FB22B3F5AED1A4B4755CC5BDBE7536492A30EE";
"-=-=-mxyzptlk-=-=-";
.
#42:0
(typeof(this) == OBJ) || raise(E_INVARG, "Callable on prototypes only");
return;
"(typeof(this) == OBJ) || raise(E_INVARG, \"Callable on prototypes only\");";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:BE6D82ABBC07073E4B29626E4EC88552C6CA9B06";
"-=-=-mxyzptlk-=-=-";
.
#42:1
(typeof(this) == ANON) || raise(E_INVARG, "Callable on instances only");
return;
"(typeof(this) == ANON) || raise(E_INVARG, \"Callable on instances only\");";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2494F4E5D91036073E30C4AB6E329F50AFF52891";
"-=-=-mxyzptlk-=-=-";
.
#43:0
$private();
this:_ensure_instance();
{name} = args;
if (`value = this.variable_map[name] ! E_RANGE')
return value;
elseif ((name in this.variable_map) || (name in this.reserved_names))
value = name;
while ((value in this.variable_map) || (value in this.reserved_names))
value = tostr("_", value);
endwhile
this.variable_map[name] = value;
return value;
else
value = name;
this.variable_map[name] = value;
return value;
endif
return;
"$private();";
"";
"this:_ensure_instance();";
"";
"{name} = args;";
"";
"if (`value = this.variable_map[name] ! E_RANGE')";
"  return value;";
"elseif (name in this.variable_map || name in this.reserved_names)";
"  value = name;";
"  while (value in this.variable_map || value in this.reserved_names)";
"    value = tostr(\"_\", value);";
"  endwhile";
"  this.variable_map[name] = value;";
"  return value;";
"else";
"  value = name;";
"  this.variable_map[name] = value;";
"  return value;";
"endif";
"";
"chunk_length:20";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:8301AF25003B5DDDCAE06066BFEACAB8796887A5";
"-=-=-mxyzptlk-=-=-";
.
#43:1
$private();
this:_ensure_instance();
{name} = args;
if (`value = this.variable_map[name] ! E_RANGE')
return value;
else
value = tostr("_", random());
while ((value in this.variable_map) || (value in this.reserved_names))
value = tostr("_", random());
endwhile
this.variable_map[name] = value;
return value;
endif
return;
"$private();";
"";
"this:_ensure_instance();";
"";
"{name} = args;";
"";
"if (`value = this.variable_map[name] ! E_RANGE')";
"  return value;";
"else";
"  value = tostr(\"_\", random());";
"  while (value in this.variable_map || value in this.reserved_names)";
"    value = tostr(\"_\", random());";
"  endwhile";
"  this.variable_map[name] = value;";
"  return value;";
"endif";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:02D253B3D9562CB07EB8FDD81363E5CBEF6F5C62";
"-=-=-mxyzptlk-=-=-";
.
#43:2
this:_ensure_prototype();
{source, ?options = []} = args;
tokenizer = this.plastic.tokenizer_proto:create(source);
parser = this.plastic.parser_proto:create(tokenizer);
compiler = create(this, 1);
try
statements = parser:statements();
except ex (ANY)
return {0, {tostr("Line ", ex[3].tokenizer.row, ":  ", ex[2])}};
endtry
source = {};
for statement in (statements)
if (statement.type != "statement")
source = {@source, tostr(compiler:p(statement), ";")};
else
source = {@source, @compiler:p(statement)};
endif
endfor
return {1, source};
return;
"this:_ensure_prototype();";
"";
"{source, ?options = []} = args;";
"";
"tokenizer = this.plastic.tokenizer_proto:create(source);";
"parser = this.plastic.parser_proto:create(tokenizer);";
"compiler = create(this, 1);";
"";
"try";
"  statements = parser:statements();";
"except ex (ANY)";
"  return {0, {tostr(\"Line \", ex[3].tokenizer.row, \":  \", ex[2])}};";
"endtry";
"";
"source = {};";
"";
"for statement in (statements)";
"  if (statement.type != \"statement\")";
"    source = {@source, tostr(compiler:p(statement), \";\")};";
"  else";
"    source = {@source, @compiler:p(statement)};";
"  endif";
"endfor";
"";
"return {1, source};";
"";
"chunk_length:25";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0AC290B9993C10FB1DCA7BBA94C7CB2C7C6C9665";
"-=-=-mxyzptlk-=-=-";
.
#43:3
this:_ensure_instance();
{statement} = args;
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (statement.type == "variable")
return this:_lookup(statement.value);
elseif (statement.type == "unique")
return this:_generate(statement.value);
elseif (isa(statement, this.plastic.sign_operator_proto))
if (statement.type == "unary")
return tostr((statement.value == "-") ? "-" | "", this:p(statement.first));
else
return tostr("(", this:p(statement.first), " ", statement.value, " ", this:p(statement.second), ")");
endif
elseif (isa(statement, this.plastic.control_flow_statement_proto))
if ((first = statement.first) != 0)
return {tostr(statement.id, " ", this:p(first), ";")};
else
return {tostr(statement.id, ";")};
endif
elseif (isa(statement, this.plastic.if_statement_proto))
value = statement.value;
code = {tostr("if (", this:p(value[1]), ")")};
for s in (value[2])
if (respond_to(s, "std"))
code = {@code, @this:p(s)};
else
code = {@code, this:p(s) + ";"};
endif
endfor
i = 3;
while ((length(value) >= i) && (typeof(value[i]) != LIST))
code = {@code, tostr("elseif (", this:p(value[i]), ")")};
i = i + 1;
for s in (value[i])
if (respond_to(s, "std"))
code = {@code, @this:p(s)};
else
code = {@code, this:p(s) + ";"};
endif
endfor
i = i + 1;
endwhile
if (length(value) == i)
code = {@code, "else"};
for s in (value[i])
if (respond_to(s, "std"))
code = {@code, @this:p(s)};
else
code = {@code, this:p(s) + ";"};
endif
endfor
endif
code = {@code, "endif"};
return code;
elseif (isa(statement, this.plastic.for_statement_proto))
value = statement.value;
if (statement.subtype == "range")
code = {tostr("for ", this:p(value[1]), " in [", this:p(value[2]), "..", this:p(value[3]), "]")};
statements = value[4];
elseif (length(value) == 4)
code = {tostr("for ", this:p(value[1]), ", ", this:p(value[2]), " in (", this:p(value[3]), ")")};
statements = value[4];
else
code = {tostr("for ", this:p(value[1]), " in (", this:p(value[2]), ")")};
statements = value[3];
endif
for s in (statements)
if (respond_to(s, "std"))
code = {@code, @this:p(s)};
else
code = {@code, this:p(s) + ";"};
endif
endfor
code = {@code, "endfor"};
return code;
elseif (isa(statement, this.plastic.loop_statement_proto))
value = statement.value;
i = 0;
if (length(value) > 2)
prefix = tostr("while ", this:p(value[i = i + 1]));
else
prefix = tostr("while");
endif
if (statement.id == "while")
code = {tostr(prefix, " (", this:p(value[i = i + 1]), ")")};
else
code = {tostr(prefix, " (!(", this:p(value[i = i + 1]), "))")};
endif
for s in (value[i = i + 1])
if (respond_to(s, "std"))
code = {@code, @this:p(s)};
else
code = {@code, this:p(s) + ";"};
endif
endfor
code = {@code, "endwhile"};
return code;
elseif (isa(statement, this.plastic.fork_statement_proto))
value = statement.value;
i = 0;
if (length(value) > 2)
code = {tostr("fork ", this:p(value[i = i + 1]), " (", this:p(value[i = i + 1]), ")")};
else
code = {tostr("fork", " (", this:p(value[i = i + 1]), ")")};
endif
for s in (value[i = i + 1])
if (respond_to(s, "std"))
code = {@code, @this:p(s)};
else
code = {@code, this:p(s) + ";"};
endif
endfor
code = {@code, "endfork"};
return code;
elseif (isa(statement, this.plastic.try_statement_proto))
value = statement.value;
code = {"try"};
for s in (value[1])
if (respond_to(s, "std"))
code = {@code, @this:p(s)};
else
code = {@code, this:p(s) + ";"};
endif
endfor
if (statement.subtype == "finally")
code = {@code, "finally"};
for s in (value[2])
if (respond_to(s, "std"))
code = {@code, @this:p(s)};
else
code = {@code, this:p(s) + ";"};
endif
endfor
else
for value in (value[2..$])
if (length(value) == 3)
x = {};
for s in (value[2])
x = {@x, this:p(s)};
endfor
code = {@code, tostr("except ", this:p(value[1]), " (", x:join(", "), ")")};
statements = value[3];
else
x = {};
for s in (value[1])
x = {@x, this:p(s)};
endfor
code = {@code, tostr("except (", x:join(", "), ")")};
statements = value[2];
endif
for s in (statements)
if (respond_to(s, "std"))
code = {@code, @this:p(s)};
else
code = {@code, this:p(s) + ";"};
endif
endfor
endfor
endif
code = {@code, "endtry"};
return code;
elseif (isa(statement, this.plastic.assignment_operator_proto))
if (statement.first.type == "pattern")
res = "{";
rest = 0;
for v in (statement.first.value)
if (v.type == "unary")
v = tostr("@", this:p(v.first));
elseif (v.type == "binary")
v = tostr("?", this:p(v.first), " = ", this:p(v.second));
else
v = this:p(v);
endif
res = tostr(res, rest ? ", " | "", v);
rest = 1;
endfor
res = tostr(res, "}");
return tostr("(", res, " ", statement.value, " ", this:p(statement.second), ")");
else
return tostr("(", this:p(statement.first), " ", statement.value, " ", this:p(statement.second), ")");
endif
elseif (isa(statement, this.plastic.bracket_operator_proto))
if (statement.type == "ternary")
return tostr("(", this:p(statement.first), "[", this:p(statement.second), "..", this:p(statement.third), "])");
elseif (statement.type == "binary")
return tostr("(", this:p(statement.first), "[", this:p(statement.second), "])");
else
res = "[";
first = 1;
for v in (statement.value)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
res = tostr(res, first ? "" | ", ", this:p(v[1]), " -> ", this:p(v[2]));
first = 0;
endfor
res = tostr(res, "]");
return res;
return {res};
endif
elseif (isa(statement, this.plastic.brace_operator_proto))
res = "{";
first = 1;
for v in (statement.value)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
res = tostr(res, first ? "" | ", ", this:p(v));
first = 0;
endfor
res = tostr(res, "}");
return res;
elseif (isa(statement, this.plastic.invocation_operator_proto))
if (statement.type == "ternary")
a = {};
for v in (statement.third)
a = {@a, this:p(v)};
endfor
if (statement.second.type == "identifier")
return tostr(this:p(statement.first), ":", this:p(statement.second), "(", a:join(", "), ")");
else
return tostr(this:p(statement.first), ":(", this:p(statement.second), ")(", a:join(", "), ")");
endif
elseif (statement.type == "binary")
a = {};
for v in (statement.second)
a = {@a, this:p(v)};
endfor
return tostr(this:p(statement.first), "(", a:join(", "), ")");
else
return tostr(this:p(statement.first));
endif
elseif (isa(statement, this.plastic.property_selector_operator_proto))
if (statement.second.type == "identifier")
return tostr(this:p(statement.first), ".", this:p(statement.second));
else
return tostr(this:p(statement.first), ".(", this:p(statement.second) + ")");
endif
elseif (isa(statement, this.plastic.error_catching_operator_proto))
if (statement.type == "unary")
return tostr(statement.value, this:p(statement.first));
endif
x = {};
for s in (statement.second)
x = {@x, this:p(s)};
endfor
second = x:join(", ");
if (statement.type == "ternary")
return tostr("`", this:p(statement.first), " ! ", second, " => ", this:p(statement.third), "'");
else
return tostr("`", this:p(statement.first), " ! ", second, "'");
endif
elseif (isa(statement, this.plastic.literal_proto))
return toliteral(statement.value);
elseif (isa(statement, this.plastic.positional_symbol_proto))
return statement.value;
elseif (isa(statement, this.plastic.prefix_operator_proto))
return tostr(statement.value, this:p(statement.first));
elseif (isa(statement, this.plastic.infix_operator_proto))
value = statement.value;
value = (value != "**") ? value | "^";
return tostr("(", this:p(statement.first), " ", value, " ", this:p(statement.second), ")");
elseif (isa(statement, this.plastic.traditional_ternary_operator_proto))
return tostr("(", this:p(statement.first), " ? ", this:p(statement.second), " | ", this:p(statement.third), ")");
elseif (isa(statement, this.plastic.name_proto))
return statement.value;
else
raise(E_INVARG);
endif
return;
"this:_ensure_instance();";
"";
"{statement} = args;";
"";
"ticks_left() < 10000 || seconds_left() < 2 && suspend(0);";
"";
"if (statement.type == \"variable\")";
"  return this:_lookup(statement.value);";
"elseif (statement.type == \"unique\")";
"  return this:_generate(statement.value);";
"elseif (isa(statement, this.plastic.sign_operator_proto))";
"  if (statement.type == \"unary\")";
"    return tostr(statement.value == \"-\" ? \"-\" | \"\", this:p(statement.first));";
"  else";
"    return tostr(\"(\", this:p(statement.first), \" \", statement.value, \" \", this:p(statement.second), \")\");";
"  endif";
"";
"elseif (isa(statement, this.plastic.control_flow_statement_proto))";
"  if ((first = statement.first) != 0)";
"    return {tostr(statement.id, \" \" , this:p(first), \";\")};";
"  else";
"    return {tostr(statement.id, \";\")};";
"  endif";
"";
"elseif (isa(statement, this.plastic.if_statement_proto))";
"  value =  statement.value;";
"";
"  code = {tostr(\"if (\", this:p(value[1]), \")\")};";
"";
"  for s in (value[2])";
"    if (respond_to(s, \"std\"))";
"      code = {@code, @this:p(s)};";
"    else";
"      code = {@code, this:p(s) + \";\"};";
"    endif";
"  endfor";
"";
"  i = 3;";
"  while (length(value) >= i && typeof(value[i]) != LIST)";
"    code = {@code, tostr(\"elseif (\", this:p(value[i]), \")\")};";
"";
"    i = i + 1;";
"";
"    for s in (value[i])";
"      if (respond_to(s, \"std\"))";
"        code = {@code, @this:p(s)};";
"      else";
"        code = {@code, this:p(s) + \";\"};";
"      endif";
"    endfor";
"";
"    i = i + 1;";
"  endwhile";
"";
"  if (length(value) == i)";
"    code = {@code, \"else\"};";
"";
"    for s in (value[i])";
"      if (respond_to(s, \"std\"))";
"        code = {@code, @this:p(s)};";
"      else";
"        code = {@code, this:p(s) + \";\"};";
"      endif";
"    endfor";
"  endif";
"";
"  code = {@code, \"endif\"};";
"";
"  return code;";
"";
"elseif (isa(statement, this.plastic.for_statement_proto))";
"  value =  statement.value;";
"";
"  if (statement.subtype == \"range\")";
"    code = {tostr(\"for \", this:p(value[1]), \" in [\", this:p(value[2]), \"..\", this:p(value[3]), \"]\")};";
"    statements = value[4];";
"  elseif (length(value) == 4)";
"    code = {tostr(\"for \", this:p(value[1]), \", \", this:p(value[2]), \" in (\", this:p(value[3]), \")\")};";
"    statements = value[4];";
"  else";
"    code = {tostr(\"for \", this:p(value[1]), \" in (\", this:p(value[2]), \")\")};";
"    statements = value[3];";
"  endif";
"";
"  for s in (statements)";
"    if (respond_to(s, \"std\"))";
"      code = {@code, @this:p(s)};";
"    else";
"      code = {@code, this:p(s) + \";\"};";
"    endif";
"  endfor";
"";
"  code = {@code, \"endfor\"};";
"";
"  return code;";
"";
"elseif (isa(statement, this.plastic.loop_statement_proto))";
"  value =  statement.value;";
"";
"  i = 0;";
"";
"  if (length(value) > 2)";
"    prefix = tostr(\"while \", this:p(value[i = i + 1]));";
"  else";
"    prefix = tostr(\"while\");";
"  endif";
"";
"  if (statement.id == \"while\")";
"    code = {tostr(prefix, \" (\", this:p(value[i = i + 1]), \")\")};";
"  else";
"    code = {tostr(prefix, \" (!(\", this:p(value[i = i + 1]), \"))\")};";
"  endif";
"";
"  for s in (value[i = i + 1])";
"    if (respond_to(s, \"std\"))";
"      code = {@code, @this:p(s)};";
"    else";
"      code = {@code, this:p(s) + \";\"};";
"    endif";
"  endfor";
"";
"  code = {@code, \"endwhile\"};";
"";
"  return code;";
"";
"elseif (isa(statement, this.plastic.fork_statement_proto))";
"  value =  statement.value;";
"";
"  i = 0;";
"";
"  if (length(value) > 2)";
"    code = {tostr(\"fork \", this:p(value[i = i + 1]), \" (\", this:p(value[i = i + 1]), \")\")};";
"  else";
"    code = {tostr(\"fork\", \" (\", this:p(value[i = i + 1]), \")\")};";
"  endif";
"";
"  for s in (value[i = i + 1])";
"    if (respond_to(s, \"std\"))";
"      code = {@code, @this:p(s)};";
"    else";
"      code = {@code, this:p(s) + \";\"};";
"    endif";
"  endfor";
"";
"  code = {@code, \"endfork\"};";
"";
"  return code;";
"";
"elseif (isa(statement, this.plastic.try_statement_proto))";
"  value =  statement.value;";
"";
"  code = {\"try\"};";
"";
"  for s in (value[1])";
"    if (respond_to(s, \"std\"))";
"      code = {@code, @this:p(s)};";
"    else";
"      code = {@code, this:p(s) + \";\"};";
"    endif";
"  endfor";
"";
"  if (statement.subtype == \"finally\")";
"    code = {@code, \"finally\"};";
"";
"    for s in (value[2])";
"      if (respond_to(s, \"std\"))";
"        code = {@code, @this:p(s)};";
"      else";
"        code = {@code, this:p(s) + \";\"};";
"      endif";
"    endfor";
"";
"  else";
"    for value in (value[2..$])";
"      if (length(value) == 3)";
"        x = {};";
"        for s in (value[2])";
"          x = {@x, this:p(s)};";
"        endfor";
"";
"        code = {@code, tostr(\"except \", this:p(value[1]), \" (\", x:join(\", \"), \")\")};";
"        statements = value[3];";
"";
"      else";
"        x = {};";
"        for s in (value[1])";
"          x = {@x, this:p(s)};";
"        endfor";
"";
"        code = {@code, tostr(\"except (\", x:join(\", \"), \")\")};";
"        statements = value[2];";
"";
"      endif";
"";
"      for s in (statements)";
"        if (respond_to(s, \"std\"))";
"          code = {@code, @this:p(s)};";
"        else";
"          code = {@code, this:p(s) + \";\"};";
"        endif";
"      endfor";
"";
"    endfor";
"  endif";
"";
"  code = {@code, \"endtry\"};";
"";
"  return code;";
"";
"elseif (isa(statement, this.plastic.assignment_operator_proto))";
"  if (statement.first.type == \"pattern\")";
"    res = \"{\";";
"    rest = 0;";
"    for v in (statement.first.value)";
"      if (v.type == \"unary\")";
"        v = tostr(\"@\", this:p(v.first));";
"      elseif (v.type == \"binary\")";
"        v = tostr(\"?\", this:p(v.first), \" = \", this:p(v.second));";
"      else";
"        v = this:p(v);";
"      endif";
"      res = tostr(res, (rest ? \", \" | \"\"), v);";
"      rest = 1;";
"    endfor";
"    res = tostr(res, \"}\");";
"    return tostr(\"(\", res, \" \", statement.value, \" \", this:p(statement.second), \")\");";
"  else";
"    return tostr(\"(\", this:p(statement.first), \" \", statement.value, \" \", this:p(statement.second), \")\");";
"  endif";
"";
"elseif (isa(statement, this.plastic.bracket_operator_proto))";
"  if (statement.type == \"ternary\")";
"    return tostr(\"(\", this:p(statement.first), \"[\", this:p(statement.second), \"..\", this:p(statement.third), \"])\");";
"  elseif (statement.type == \"binary\")";
"    return tostr(\"(\", this:p(statement.first), \"[\", this:p(statement.second), \"])\");";
"  else";
"    res = \"[\";";
"    first = 1;";
"    for v in (statement.value)";
"      ticks_left() < 10000 || seconds_left() < 2 && suspend(0);";
"      res = tostr(res, (first ? \"\" | \", \"), this:p(v[1]), \" -> \", this:p(v[2]));";
"      first = 0;";
"    endfor";
"    res = tostr(res, \"]\");";
"    return res;";
"    return {res};";
"  endif";
"";
"elseif (isa(statement, this.plastic.brace_operator_proto))";
"  res = \"{\";";
"  first = 1;";
"  for v in (statement.value)";
"    ticks_left() < 10000 || seconds_left() < 2 && suspend(0);";
"    res = tostr(res, (first ? \"\" | \", \"), this:p(v));";
"    first = 0;";
"  endfor";
"  res = tostr(res, \"}\");";
"  return res;";
"";
"elseif (isa(statement, this.plastic.invocation_operator_proto))";
"  if (statement.type == \"ternary\")";
"    a = {};";
"    for v in (statement.third)";
"      a = {@a, this:p(v)};";
"    endfor";
"    if (statement.second.type == \"identifier\")";
"      return tostr(this:p(statement.first), \":\", this:p(statement.second), \"(\", a:join(\", \"), \")\");";
"    else";
"      return tostr(this:p(statement.first), \":(\", this:p(statement.second), \")(\", a:join(\", \"), \")\");";
"    endif";
"  elseif (statement.type == \"binary\")";
"    a = {};";
"    for v in (statement.second)";
"      a = {@a, this:p(v)};";
"    endfor";
"    return tostr(this:p(statement.first), \"(\", a:join(\", \"), \")\");";
"  else";
"    return tostr(this:p(statement.first));";
"  endif";
"";
"elseif (isa(statement, this.plastic.property_selector_operator_proto))";
"  if (statement.second.type == \"identifier\")";
"    return tostr(this:p(statement.first), \".\", this:p(statement.second));";
"  else";
"    return tostr(this:p(statement.first), \".(\", this:p(statement.second) + \")\");";
"  endif";
"";
"elseif (isa(statement, this.plastic.error_catching_operator_proto))";
"  if (statement.type == \"unary\")";
"    return tostr(statement.value, this:p(statement.first));";
"  endif";
"";
"  x = {};";
"  for s in (statement.second)";
"    x = {@x, this:p(s)};";
"  endfor";
"";
"  second = x:join(\", \");";
"";
"  if (statement.type == \"ternary\")";
"    return tostr(\"`\", this:p(statement.first), \" ! \", second, \" => \", this:p(statement.third), \"'\");";
"  else";
"    return tostr(\"`\", this:p(statement.first), \" ! \", second, \"'\");";
"  endif";
"";
"elseif (isa(statement, this.plastic.literal_proto))";
"  return toliteral(statement.value);";
"elseif (isa(statement, this.plastic.positional_symbol_proto))";
"  return statement.value;";
"elseif (isa(statement, this.plastic.prefix_operator_proto))";
"  return tostr(statement.value, this:p(statement.first));";
"elseif (isa(statement, this.plastic.infix_operator_proto))";
"  value = statement.value;";
"  value = (value != \"**\") ? value | \"^\";";
"  return tostr(\"(\", this:p(statement.first), \" \", value, \" \", this:p(statement.second), \")\");";
"elseif (isa(statement, this.plastic.traditional_ternary_operator_proto))";
"  return tostr(\"(\", this:p(statement.first), \" ? \", this:p(statement.second), \" | \", this:p(statement.third), \")\");";
"elseif (isa(statement, this.plastic.name_proto))";
"  return statement.value;";
"else";
"  raise(E_INVARG);";
"endif";
"";
"chunk_length:322";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:67D036011B33B8DE5FF6C910693AA9CC4E945B98";
"-=-=-mxyzptlk-=-=-";
.
#44:0
{statement, ?indent = ""} = args;
if (typeof(statement) == LIST)
result = {tostr(indent, "-")};
for item in (statement)
result = {@result, @this:_print(item, indent + "  ")};
endfor
return result;
endif
if (`typeof(statement.value) == LIST ! ANY')
result = {tostr(indent, statement.id, " : ", statement.type)};
for value in (statement.value)
result = {@result, @this:_print(value, indent + "  ")};
endfor
else
result = {tostr(indent, (typeof(statement.value) == ERR) ? toliteral(statement.value) | statement.value, " : ", statement.type)};
for prop in ({"first", "second", "third"})
if ((`value = statement.(prop) ! E_PROPNF' != E_PROPNF) && (value != 0))
result = {@result, @this:_print(value, indent + "  ")};
endif
endfor
endif
return result;
return;
"{statement, ?indent = \"\"} = args;";
"";
"if (typeof(statement) == LIST)";
"  result = {tostr(indent, \"-\")};";
"";
"  for item in (statement)";
"    result = {@result, @this:_print(item, indent + \"  \")};";
"  endfor";
"";
"  return result;";
"endif";
"";
"if (`typeof(statement.value) == LIST ! ANY')";
"  result = {tostr(indent, statement.id, \" : \", statement.type)};";
"";
"  for value in (statement.value)";
"    result = {@result, @this:_print(value, indent + \"  \")};";
"  endfor";
"else";
"  result = {tostr(indent, typeof(statement.value) == ERR ? toliteral(statement.value) | statement.value, \" : \", statement.type)};";
"";
"  for prop in ({\"first\", \"second\", \"third\"})";
"    if (`value = statement.(prop) ! E_PROPNF' != E_PROPNF && value != 0)";
"      result = {@result, @this:_print(value, indent + \"  \")};";
"    endif";
"  endfor";
"endif";
"";
"return result;";
"";
"chunk_length:29";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:67068C3DEAFED07576F5AE9A4A94AE664A9EF238";
"-=-=-mxyzptlk-=-=-";
.
#44:1
{source, ?options = []} = args;
tokenizer = this.plastic.tokenizer_proto:create(source);
parser = this.plastic.parser_proto:create(tokenizer);
statements = parser:statements();
source = {};
for statement in (statements)
source = {@source, @this:_print(statement)};
endfor
return source;
return;
"{source, ?options = []} = args;";
"";
"tokenizer = this.plastic.tokenizer_proto:create(source);";
"parser = this.plastic.parser_proto:create(tokenizer);";
"";
"statements = parser:statements();";
"";
"source = {};";
"";
"for statement in (statements)";
"  source = {@source, @this:_print(statement)};";
"endfor";
"";
"return source;";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2A38FC7355668CD5D2C874FC93127BF0A0B9F786";
"-=-=-mxyzptlk-=-=-";
.
#45:0
this:_ensure_prototype();
instance = create(this, 1);
instance.row = 1;
instance.column = 1;
instance.source = ((length(args) == 1) && (typeof(args[1]) == LIST)) ? args[1] | args;
return instance;
return;
"this:_ensure_prototype();";
"";
"instance = create(this, 1);";
"";
"instance.row = 1;";
"instance.column = 1;";
"instance.source = (length(args) == 1 && typeof(args[1]) == LIST) ? args[1] | args;";
"";
"return instance;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:FF59BCA3B71DAD9EAE30F0144CEA202F76B8B97C";
"-=-=-mxyzptlk-=-=-";
.
#45:1
this:_ensure_instance();
this.token = 0;
if (!this.source)
return this;
endif
row = this.row;
column = this.column;
source = this.source;
eol = 0;
block_comment = 0;
inline_comment = 0;
while loop (length(source) >= row)
if (column > (len = length(source[row])))
eol = 1;
inline_comment = 0;
row = row + 1;
column = 1;
continue loop;
endif
next_two = (len > column) ? source[row][column..column + 1] | "";
if (block_comment && (next_two == "*/"))
block_comment = 0;
column = column + 2;
continue loop;
elseif (next_two == "/*")
block_comment = 1;
column = column + 2;
continue loop;
elseif (next_two == "//")
inline_comment = 1;
column = column + 2;
continue loop;
endif
if (block_comment || inline_comment)
column = column + 1;
continue loop;
endif
if ((len >= column) && (((c = source[row][column]) == "      ") || (c == " ")))
column = column + 1;
continue loop;
endif
if (this.token)
this.token["eol"] = eol;
eol = 0;
break loop;
endif
if (`c = source[row][column] ! E_RANGE')
if ((((c >= "a") && (c <= "z")) || (c == "_")) || (c == "$"))
col1 = column;
column = column + 1;
while (`c = source[row][column] ! E_RANGE')
if ((((c >= "a") && (c <= "z")) || ((c >= "0") && (c <= "9"))) || (c == "_"))
column = column + 1;
else
break;
endif
endwhile
col2 = column - 1;
chars = source[row][col1..col2];
if (index(chars, "E_") == 1)
try
this.token = ["type" -> "error", "value" -> this.errors[chars]];
except ex (E_RANGE)
this.token = ["type" -> "error", "value" -> chars, "error" -> tostr("Invalid error: ", chars)];
endtry
else
this.token = ["type" -> "name", "value" -> chars];
endif
continue loop;
elseif (c == "#")
col1 = column;
column = column + 1;
if (`c = source[row][column] ! E_RANGE')
if ((c == "+") || (c == "-"))
column = column + 1;
endif
endif
while (`c = source[row][column] ! E_RANGE')
if ((c >= "0") && (c <= "9"))
column = column + 1;
else
break;
endif
endwhile
col2 = column - 1;
chars = source[row][col1..col2];
if ((chars[$] < "0") || (chars[$] > "9"))
this.token = ["type" -> "object", "value" -> chars, "error" -> "Bad object number"];
elseif ((c >= "a") && (c <= "z"))
this.token = ["type" -> "object", "value" -> chars + c, "error" -> "Bad object number"];
else
this.token = ["type" -> "object", "value" -> toobj(chars)];
endif
continue loop;
elseif ((c >= "0") && (c <= "9"))
FLOAT = 0;
col1 = column;
column = column + 1;
while (`c = source[row][column] ! E_RANGE')
if ((c >= "0") && (c <= "9"))
column = column + 1;
else
break;
endif
endwhile
if ((c == ".") && ((cc = `source[row][column + 1] ! E_RANGE') != "."))
FLOAT = 1;
column = column + 1;
while (`c = source[row][column] ! E_RANGE')
if ((c >= "0") && (c <= "9"))
column = column + 1;
else
break;
endif
endwhile
endif
if (c == "e")
FLOAT = 1;
column = column + 1;
if (`c = source[row][column] ! E_RANGE' && (c in {"-", "+"}))
column = column + 1;
endif
while (`c = source[row][column] ! E_RANGE')
if ((c >= "0") && (c <= "9"))
column = column + 1;
else
break;
endif
endwhile
endif
col2 = column - 1;
chars = source[row][col1..col2];
if (((chars[$] < "0") || (chars[$] > "9")) && (chars[$] != "."))
this.token = ["type" -> "number", "value" -> chars, "error" -> "Bad number"];
elseif ((c >= "a") && (c <= "z"))
this.token = ["type" -> "number", "value" -> chars + c, "error" -> "Bad number"];
else
this.token = ["type" -> "number", "value" -> FLOAT ? tofloat(chars) | toint(chars)];
endif
continue loop;
elseif ((c == "\"") || (c == "'"))
esc = 0;
chars = "";
q = c;
col1 = column;
column = column + 1;
while (`c = source[row][column] ! E_RANGE' && ((c != q) || esc))
column = column + 1;
if ((c != "\\") || esc)
chars = tostr(chars, c);
esc = 0;
else
esc = 1;
endif
endwhile
column = column + 1;
col2 = column - 1;
if (c != q)
this.token = ["type" -> "string", "value" -> source[row][col1..col2 - 1], "error" -> "Unterminated string"];
continue loop;
else
this.token = ["type" -> "string", "value" -> chars];
continue loop;
endif
elseif (index("-+<>=*/%!|&.", c))
col1 = column;
column = column + 1;
if (`c = source[row][column] ! E_RANGE' && index(">=*!|&.", c))
column = column + 1;
this.token = ["type" -> "operator", "value" -> source[row][col1..column - 1]];
continue loop;
else
this.token = ["type" -> "operator", "value" -> source[row][col1]];
continue loop;
endif
else
column = column + 1;
this.token = ["type" -> "operator", "value" -> c];
continue loop;
endif
column = column + 1;
endif
endwhile
this.row = row;
this.column = column;
this.source = source;
if (block_comment)
this.token = ["type" -> "comment", "value" -> "", "error" -> "Unterminated comment"];
endif
if ((this.token && (this.token["type"] == "name")) && (this.token["value"] == "$"))
this.token["type"] = "operator";
endif
if ((row > length(source)) && this.token)
this.token["eol"] = 1;
endif
return this;
return;
"this:_ensure_instance();";
"";
"this.token = 0;";
"";
"if (!this.source)";
"  return this;";
"endif";
"";
"row = this.row;";
"column = this.column;";
"source = this.source;";
"";
"eol = 0;";
"block_comment = 0;";
"inline_comment = 0;";
"";
"while loop (length(source) >= row)";
"";
"  if (column > (len = length(source[row])))";
"    eol = 1;";
"    inline_comment = 0;";
"    row = row + 1;";
"    column = 1;";
"    continue loop;";
"  endif";
"";
"  next_two = len > column ? source[row][column..column + 1] | \"\";";
"";
"  if (block_comment && next_two == \"*/\")";
"    block_comment = 0;";
"    column = column + 2;";
"    continue loop;";
"  elseif (next_two == \"/*\")";
"    block_comment = 1;";
"    column = column + 2;";
"    continue loop;";
"  elseif (next_two == \"//\")";
"    inline_comment = 1;";
"    column = column + 2;";
"    continue loop;";
"  endif";
"";
"  if (block_comment || inline_comment)";
"    column = column + 1;";
"    continue loop;";
"  endif";
"";
"  if (len >= column && ((c = source[row][column]) == \"      \" || c == \" \"))";
"    column = column + 1;";
"    continue loop;";
"  endif";
"";
"  if (this.token)";
"    this.token[\"eol\"] = eol;";
"    eol = 0;";
"    break loop;";
"  endif";
"";
"  if (`c = source[row][column] ! E_RANGE')";
"";
"    /* name and error */";
"    /* MOO error literals look like names but they're not.  Worse, a";
"     * valid error like E_PERM is treated like a literal, while an";
"     * invalid error like E_FOO is treated like a variable.  Any name";
"     * that starts with the characters \"E_\" is *now* an error literal,";
"     * but invalid errors are errors.";
"     */";
"    if ((c >= \"a\" && c <= \"z\") || c == \"_\" || c == \"$\")";
"      col1 = column; /* mark the start */";
"      column = column + 1;";
"      while (`c = source[row][column] ! E_RANGE')";
"        if ((c >= \"a\" && c <= \"z\") || (c >= \"0\" && c <= \"9\") || c == \"_\")";
"          column = column + 1;";
"        else";
"          break;";
"        endif";
"      endwhile";
"      col2 = column - 1;";
"      chars = source[row][col1..col2];";
"      if (index(chars, \"E_\") == 1)";
"        try";
"          this.token = [\"type\" -> \"error\", \"value\" -> this.errors[chars]];";
"        except ex (E_RANGE)";
"          this.token = [\"type\" -> \"error\", \"value\" -> chars, \"error\" -> tostr(\"Invalid error: \", chars)];";
"        endtry";
"      else";
"        this.token = [\"type\" -> \"name\", \"value\" -> chars];";
"      endif";
"      continue loop;";
"";
"    /* object number */";
"    elseif (c == \"#\")";
"      col1 = column; /* mark the start */";
"      column = column + 1;";
"      if (`c = source[row][column] ! E_RANGE')";
"        if (c == \"+\" || c == \"-\")";
"          column = column + 1;";
"        endif";
"      endif";
"      while (`c = source[row][column] ! E_RANGE')";
"        if (c >= \"0\" && c <= \"9\")";
"          column = column + 1;";
"        else";
"          break;";
"        endif";
"      endwhile";
"      col2 = column - 1;";
"      chars = source[row][col1..col2];";
"      if (chars[$] < \"0\" || chars[$] > \"9\")";
"        this.token = [\"type\" -> \"object\", \"value\" -> chars, \"error\" -> \"Bad object number\"];";
"      elseif (c >= \"a\" && c <= \"z\")";
"        this.token = [\"type\" -> \"object\", \"value\" -> chars + c, \"error\" -> \"Bad object number\"];";
"      else";
"        this.token = [\"type\" -> \"object\", \"value\" -> toobj(chars)];";
"      endif";
"      continue loop;";
"";
"    /* number */";
"    elseif (c >= \"0\" && c <= \"9\")";
"      float = 0;";
"      col1 = column; /* mark the start */";
"      column = column + 1;";
"      while (`c = source[row][column] ! E_RANGE')";
"        if (c >= \"0\" && c <= \"9\")";
"          column = column + 1;";
"        else";
"          break;";
"        endif";
"      endwhile";
"      if (c == \".\" && ((cc = `source[row][column + 1] ! E_RANGE') != \".\")) /* not `..' */";
"        float = 1;";
"        column = column + 1;";
"        while (`c = source[row][column] ! E_RANGE')";
"          if (c >= \"0\" && c <= \"9\")";
"            column = column + 1;";
"          else";
"            break;";
"          endif";
"        endwhile";
"      endif";
"      if (c == \"e\")";
"        float = 1;";
"        column = column + 1;";
"        if (`c = source[row][column] ! E_RANGE' && c in {\"-\", \"+\"})";
"          column = column + 1;";
"        endif";
"        while (`c = source[row][column] ! E_RANGE')";
"          if (c >= \"0\" && c <= \"9\")";
"            column = column + 1;";
"          else";
"            break;";
"          endif";
"        endwhile";
"      endif";
"      col2 = column - 1;";
"      chars = source[row][col1..col2];";
"      if ((chars[$] < \"0\" || chars[$] > \"9\") && chars[$] != \".\")";
"        this.token = [\"type\" -> \"number\", \"value\" -> chars, \"error\" -> \"Bad number\"];";
"      elseif (c >= \"a\" && c <= \"z\")";
"        this.token = [\"type\" -> \"number\", \"value\" -> chars + c, \"error\" -> \"Bad number\"];";
"      else";
"        this.token = [\"type\" -> \"number\", \"value\" -> float ? tofloat(chars) | toint(chars)];";
"      endif";
"      continue loop;";
"";
"    /* string */";
"    elseif (c == \"\\\"\" || c == \"'\")";
"      esc = 0;";
"      chars = \"\";";
"      q = c;";
"      col1 = column; /* mark the start */";
"      column = column + 1;";
"      while (`c = source[row][column] ! E_RANGE' && (c != q || esc))";
"        column = column + 1;";
"        if (c != \"\\\\\" || esc)";
"          chars = tostr(chars, c);";
"          esc = 0;";
"        else";
"          esc = 1;";
"        endif";
"      endwhile";
"      column = column + 1;";
"      col2 = column - 1;";
"      if (c != q)";
"        this.token = [\"type\" -> \"string\", \"value\" -> source[row][col1..col2 - 1], \"error\" -> \"Unterminated string\"];";
"        continue loop;";
"      else";
"        this.token = [\"type\" -> \"string\", \"value\" -> chars];";
"        continue loop;";
"      endif";
"";
"    /* possible multi-character operator */";
"    elseif (index(\"-+<>=*/%!|&.\", c))";
"      col1 = column; /* mark the start */";
"      column = column + 1;";
"      if (`c = source[row][column] ! E_RANGE' && index(\">=*!|&.\", c))";
"        column = column + 1;";
"        this.token = [\"type\" -> \"operator\", \"value\" -> source[row][col1..column - 1]];";
"        continue loop;";
"      else";
"        this.token = [\"type\" -> \"operator\", \"value\" -> source[row][col1]];";
"        continue loop;";
"      endif";
"";
"    /* operator */";
"    else";
"      column = column + 1;";
"      this.token = [\"type\" -> \"operator\", \"value\" -> c];";
"      continue loop;";
"";
"    endif";
"";
"    column = column + 1;";
"  endif";
"endwhile";
"";
"this.row = row;";
"this.column = column;";
"this.source = source;";
"";
"/* check for unterminated comment */";
"if (block_comment)";
"  this.token = [\"type\" -> \"comment\", \"value\" -> \"\", \"error\" -> \"Unterminated comment\"];";
"endif";
"";
"/* dollar sign by itself is not a name */";
"if (this.token && this.token[\"type\"] == \"name\" && this.token[\"value\"] == \"$\")";
"  this.token[\"type\"] = \"operator\";";
"endif";
"";
"/* catch the last token */";
"if (row > length(source) && this.token)";
"  this.token[\"eol\"] = 1;";
"endif";
"";
"return this;";
"";
"chunk_length:236";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:510F327D20CC014A6882610B4CA21A71A2C7192E";
"-=-=-mxyzptlk-=-=-";
.
#45:2
this:_ensure_instance();
return this.token;
return;
"this:_ensure_instance();";
"";
"return this.token;";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:88791DF01E1D0711F700234B78C3BA4184A82F47";
"-=-=-mxyzptlk-=-=-";
.
#46:0
this:_ensure_prototype();
{tokenizer, @options} = args;
instance = create(this, 1);
instance.tokenizer = tokenizer;
instance.symbols = [];
plastic = this.plastic;
instance:symbol("(end)");
instance:symbol("(name)", 0, plastic.name_proto);
instance:symbol("(literal)", 0, plastic.literal_proto);
instance:symbol(";", 0, plastic.operator_proto);
instance:symbol(",", 0, plastic.operator_proto);
instance:symbol("]", 0, plastic.operator_proto);
instance:symbol("}", 0, plastic.operator_proto);
instance:symbol("->", 0, plastic.operator_proto);
instance:symbol("=>", 0, plastic.operator_proto);
instance:symbol("..", 0, plastic.operator_proto);
instance:symbol("|", 0, plastic.operator_proto);
instance:symbol("`", 0, plastic.operator_proto);
instance:symbol("!", 0, plastic.prefix_operator_proto);
instance:symbol("!!", 50, plastic.error_catching_operator_proto);
instance:symbol("=", 100, plastic.assignment_operator_proto);
instance:symbol("+=", 100, plastic.compound_assignment_operator_proto);
instance:symbol("-=", 100, plastic.compound_assignment_operator_proto);
instance:symbol("*=", 100, plastic.compound_assignment_operator_proto);
instance:symbol("/=", 100, plastic.compound_assignment_operator_proto);
instance:symbol("%=", 100, plastic.compound_assignment_operator_proto);
instance:symbol("?", 200, plastic.traditional_ternary_operator_proto);
instance:symbol("&&", 300, plastic.infix_operator_proto);
instance:symbol("||", 300, plastic.infix_operator_proto);
instance:symbol("!=", 400, plastic.infix_operator_proto);
instance:symbol("==", 400, plastic.infix_operator_proto);
instance:symbol("<", 400, plastic.infix_operator_proto);
instance:symbol("<=", 400, plastic.infix_operator_proto);
instance:symbol(">", 400, plastic.infix_operator_proto);
instance:symbol(">=", 400, plastic.infix_operator_proto);
instance:symbol("in", 400, plastic.infix_operator_proto);
instance:symbol("+", 500, plastic.sign_operator_proto);
instance:symbol("-", 500, plastic.sign_operator_proto);
instance:symbol("*", 600, plastic.infix_operator_proto);
instance:symbol("/", 600, plastic.infix_operator_proto);
instance:symbol("%", 600, plastic.infix_operator_proto);
instance:symbol("**", 650, plastic.infix_operator_proto, ["right" -> 1]);
instance:symbol("[", 800, plastic.bracket_operator_proto);
instance:symbol("{", 0, plastic.brace_operator_proto);
instance:symbol("return", 0, plastic.control_flow_statement_proto);
instance:symbol("break", 0, plastic.control_flow_statement_proto);
instance:symbol("continue", 0, plastic.control_flow_statement_proto);
instance:symbol("if", 0, plastic.if_statement_proto);
instance:symbol("for", 0, plastic.for_statement_proto);
instance:symbol("while", 0, plastic.loop_statement_proto);
instance:symbol("until", 0, plastic.loop_statement_proto);
instance:symbol("fork", 0, plastic.fork_statement_proto);
instance:symbol("try", 0, plastic.try_statement_proto);
instance:symbol("from", 0, plastic.from_statement_proto);
instance:symbol(":", 800, plastic.verb_selector_operator_proto);
instance:symbol(".", 800, plastic.property_selector_operator_proto);
instance:symbol("(", 800, plastic.invocation_operator_proto);
instance:symbol(")", 0, plastic.operator_proto);
return instance;
return;
"this:_ensure_prototype();";
"";
"{tokenizer, @options} = args;";
"";
"instance = create(this, 1);";
"instance.tokenizer = tokenizer;";
"instance.symbols = [];";
"";
"plastic = this.plastic;";
"";
"/* `(end)' is required */";
"instance:symbol(\"(end)\");";
"instance:symbol(\"(name)\", 0, plastic.name_proto);";
"instance:symbol(\"(literal)\", 0, plastic.literal_proto);";
"instance:symbol(\";\", 0, plastic.operator_proto);";
"instance:symbol(\",\", 0, plastic.operator_proto);";
"instance:symbol(\"]\", 0, plastic.operator_proto);";
"instance:symbol(\"}\", 0, plastic.operator_proto);";
"instance:symbol(\"->\", 0, plastic.operator_proto);";
"instance:symbol(\"=>\", 0, plastic.operator_proto);";
"instance:symbol(\"..\", 0, plastic.operator_proto);";
"instance:symbol(\"|\", 0, plastic.operator_proto);";
"instance:symbol(\"`\", 0, plastic.operator_proto);";
"instance:symbol(\"!\", 0, plastic.prefix_operator_proto);";
"instance:symbol(\"!!\", 50, plastic.error_catching_operator_proto);";
"instance:symbol(\"=\", 100, plastic.assignment_operator_proto);";
"instance:symbol(\"+=\", 100, plastic.compound_assignment_operator_proto);";
"instance:symbol(\"-=\", 100, plastic.compound_assignment_operator_proto);";
"instance:symbol(\"*=\", 100, plastic.compound_assignment_operator_proto);";
"instance:symbol(\"/=\", 100, plastic.compound_assignment_operator_proto);";
"instance:symbol(\"%=\", 100, plastic.compound_assignment_operator_proto);";
"instance:symbol(\"?\", 200, plastic.traditional_ternary_operator_proto);";
"instance:symbol(\"&&\", 300, plastic.infix_operator_proto);";
"instance:symbol(\"||\", 300, plastic.infix_operator_proto);";
"instance:symbol(\"!=\", 400, plastic.infix_operator_proto);";
"instance:symbol(\"==\", 400, plastic.infix_operator_proto);";
"instance:symbol(\"<\", 400, plastic.infix_operator_proto);";
"instance:symbol(\"<=\", 400, plastic.infix_operator_proto);";
"instance:symbol(\">\", 400, plastic.infix_operator_proto);";
"instance:symbol(\">=\", 400, plastic.infix_operator_proto);";
"instance:symbol(\"in\", 400, plastic.infix_operator_proto);";
"instance:symbol(\"+\", 500, plastic.sign_operator_proto);";
"instance:symbol(\"-\", 500, plastic.sign_operator_proto);";
"instance:symbol(\"*\", 600, plastic.infix_operator_proto);";
"instance:symbol(\"/\", 600, plastic.infix_operator_proto);";
"instance:symbol(\"%\", 600, plastic.infix_operator_proto);";
"instance:symbol(\"**\", 650, plastic.infix_operator_proto, [\"right\" -> 1]);";
"instance:symbol(\"[\", 800, plastic.bracket_operator_proto);";
"instance:symbol(\"{\", 0, plastic.brace_operator_proto); /* never bind left */";
"instance:symbol(\"return\", 0, plastic.control_flow_statement_proto);";
"instance:symbol(\"break\", 0, plastic.control_flow_statement_proto);";
"instance:symbol(\"continue\", 0, plastic.control_flow_statement_proto);";
"instance:symbol(\"if\", 0, plastic.if_statement_proto);";
"instance:symbol(\"for\", 0, plastic.for_statement_proto);";
"instance:symbol(\"while\", 0, plastic.loop_statement_proto);";
"instance:symbol(\"until\", 0, plastic.loop_statement_proto);";
"instance:symbol(\"fork\", 0, plastic.fork_statement_proto);";
"instance:symbol(\"try\", 0, plastic.try_statement_proto);";
"instance:symbol(\"from\", 0, plastic.from_statement_proto);";
"instance:symbol(\":\", 800, plastic.verb_selector_operator_proto);";
"instance:symbol(\".\", 800, plastic.property_selector_operator_proto);";
"/* the infix form is function/verb invocation */";
"instance:symbol(\"(\", 800, plastic.invocation_operator_proto);";
"instance:symbol(\")\", 0, plastic.operator_proto);";
"";
"return instance;";
"";
"chunk_length:66";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0DC5BBEAED46FE7265CB9811C49D5EB46BD6A041";
"-=-=-mxyzptlk-=-=-";
.
#46:1
this:_ensure_instance();
{id, ?bp = 0, ?proto = $nothing, ?options = []} = args;
proto = valid(proto) ? proto | this.plastic.symbol_proto;
if ((symbol = `this.symbols[id] ! E_RANGE') == E_RANGE)
symbol = proto:create(id, bp, options);
endif
this.symbols[id] = symbol;
return symbol;
return;
"this:_ensure_instance();";
"";
"{id, ?bp = 0, ?proto = $nothing, ?options = []} = args;";
"";
"proto = valid(proto) ? proto | this.plastic.symbol_proto;";
"";
"if ((symbol = `this.symbols[id] ! E_RANGE') == E_RANGE)";
"  symbol = proto:create(id, bp, options);";
"endif";
"";
"this.symbols[id] = symbol;";
"";
"return symbol;";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0B2A68461D7DF243F67813AB414CB1AE94A08562";
"-=-=-mxyzptlk-=-=-";
.
#46:2
this:_ensure_instance();
{symbol} = args;
id = symbol.id;
if ((((type = this.symbols[id].type) != "name") && (type != "statement")) && (type != "keyword"))
an_or_a = index("aeiou", type[1]) ? "an" | "a";
raise("Syntax error", tostr("`", id, "' is ", an_or_a, " ", type), this);
endif
symbol.reserved = 1;
symbol.type = verb[9..$];
this.symbols[id] = symbol;
return;
"this:_ensure_instance();";
"";
"{symbol} = args;";
"";
"id = symbol.id;";
"";
"/* raise error if this symbol is not a name, statement or keyword */";
"if ((type = this.symbols[id].type) != \"name\" && type != \"statement\" && type != \"keyword\")";
"  an_or_a = index(\"aeiou\", type[1]) ? \"an\" | \"a\";";
"  raise(\"Syntax error\", tostr(\"`\", id, \"' is \", an_or_a, \" \", type), this);";
"endif";
"";
"symbol.reserved = 1;";
"symbol.type = verb[9..$];";
"";
"this.symbols[id] = symbol;";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:30FF331C48ABA887B3E4EA3C3F504A11766557C7";
"-=-=-mxyzptlk-=-=-";
.
#46:3
this:_ensure_instance();
{symbol} = args;
id = symbol.id;
if (this.symbols[id].reserved)
raise("Syntax error", tostr("`", id, "' is reserved"), this);
endif
symbol.reserved = 0;
symbol.type = verb[6..$];
this.symbols[id] = symbol;
return;
"this:_ensure_instance();";
"";
"{symbol} = args;";
"";
"id = symbol.id;";
"";
"/* raise error if this symbol is reserved */";
"if (this.symbols[id].reserved)";
"  raise(\"Syntax error\", tostr(\"`\", id, \"' is reserved\"), this);";
"endif";
"";
"symbol.reserved = 0;";
"symbol.type = verb[6..$];";
"";
"this.symbols[id] = symbol;";
"";
"chunk_length:15";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:042DC6E0D3EBAFDB0EF12619B3D637CF3713DDB9";
"-=-=-mxyzptlk-=-=-";
.
#46:4
this:_ensure_instance();
{?ttid = 0} = args;
if (this.token == 0)
this.tokenizer:advance();
token = this.tokenizer.token;
if (token)
type = token["type"];
value = token["value"];
eol = token["eol"];
if (`token["error"] ! E_RANGE')
raise("Syntax error", token["error"], this);
elseif ((((type == "number") || (type == "string")) || (type == "object")) || (type == "error"))
symbol = this:symbol("(literal)");
this.token = symbol:clone();
this.token.type = type;
this.token.value = value;
this.token.eol = eol;
elseif (type == "operator")
if ((symbol = `this.symbols[value] ! E_RANGE') == E_RANGE)
raise("Syntax error", tostr("Unknown operator:  `", value, "'"), this);
endif
this.token = symbol:clone();
this.token.type = "operator";
this.token.value = value;
this.token.eol = eol;
elseif (type == "name")
id = value;
if ((symbol = `this.symbols[id] ! E_RANGE') != E_RANGE)
this.token = symbol:clone();
this.symbols[id] = this.token;
this.token.type = symbol.type || "name";
this.token.id = id;
this.token.value = value;
this.token.eol = eol;
else
symbol = this:symbol("(name)");
this.token = symbol:clone();
this.symbols[id] = this.token;
this.token.type = "name";
this.token.id = id;
this.token.value = value;
this.token.eol = eol;
endif
else
raise("Syntax error", "Unexpected token", this);
endif
else
symbol = this:symbol("(end)");
this.token = symbol:clone();
endif
endif
if (ttid)
this:advance(ttid);
endif
return this.token;
return;
"this:_ensure_instance();";
"";
"{?ttid = 0} = args;";
"";
"if (this.token == 0)";
"  this.tokenizer:advance();";
"  token = this.tokenizer.token;";
"  if (token)";
"    type = token[\"type\"];";
"    value = token[\"value\"];";
"    eol = token[\"eol\"];";
"    if (`token[\"error\"] ! E_RANGE')";
"      raise(\"Syntax error\", token[\"error\"], this);";
"    elseif (type == \"number\" || type == \"string\" || type == \"object\" || type == \"error\")";
"      symbol = this:symbol(\"(literal)\");";
"      this.token = symbol:clone();";
"      this.token.type = type;";
"      this.token.value = value;";
"      this.token.eol = eol;";
"    elseif (type == \"operator\")";
"      /* Update the symbol table itself and give the operator the";
"       * initial type \"operator\" (the type will change to \"unary\",";
"       * \"binary\" or \"ternary\" when we learn how this symbol is used in";
"       * the program).";
"       */";
"      /* check the symbol table */";
"      if ((symbol = `this.symbols[value] ! E_RANGE') == E_RANGE)";
"        raise(\"Syntax error\", tostr(\"Unknown operator:  `\", value, \"'\"), this);";
"      endif";
"      this.token = symbol:clone();";
"      this.token.type = \"operator\";";
"      this.token.value = value;";
"      this.token.eol = eol;";
"    elseif (type == \"name\")";
"      /* Update the symbol table itself and give the name the initial";
"       * type \"name\" (the type will change to \"variable\", \"identifier\",";
"       * \"statement\" or \"keyword\" when we learn how this symbol is used";
"       * in the program).";
"       */";
"      id = value;";
"      /* peek into the symbol table */";
"      if ((symbol = `this.symbols[id] ! E_RANGE') != E_RANGE)";
"        this.token = symbol:clone();";
"        this.symbols[id] = this.token;";
"        this.token.type = symbol.type || \"name\";";
"        this.token.id = id;";
"        this.token.value = value;";
"        this.token.eol = eol;";
"      else";
"        symbol = this:symbol(\"(name)\");";
"        this.token = symbol:clone();";
"        this.symbols[id] = this.token;";
"        this.token.type = \"name\";";
"        this.token.id = id;";
"        this.token.value = value;";
"        this.token.eol = eol;";
"      endif";
"    else";
"      raise(\"Syntax error\", \"Unexpected token\", this);";
"    endif";
"  else";
"    symbol = this:symbol(\"(end)\");";
"    this.token = symbol:clone();";
"  endif";
"endif";
"";
"if (ttid)";
"  this:advance(ttid);";
"endif";
"";
"return this.token;";
"";
"chunk_length:71";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:8990F10DAF5DAA9809246B0C80A84CB33D4B8A9C";
"-=-=-mxyzptlk-=-=-";
.
#46:5
this:_ensure_instance();
{?id = 0} = args;
if ((id && (this.token != 0)) && (this.token.id != id))
raise("Syntax error", tostr("Expected `", id, "'"), this);
endif
this.token = 0;
return this;
return;
"this:_ensure_instance();";
"";
"{?id = 0} = args;";
"";
"/* raise error if token doesn't match expectation */";
"if (id && this.token != 0 && this.token.id != id)";
"  raise(\"Syntax error\", tostr(\"Expected `\", id, \"'\"), this);";
"endif";
"";
"this.token = 0;";
"";
"return this;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B578DF8B4CC8A8272EE8533436189DC247950745";
"-=-=-mxyzptlk-=-=-";
.
#46:6
this:_ensure_instance();
{?bp = 0} = args;
token = this:token();
this:advance();
if (token.id == "(end)")
return token;
endif
left = token:nud(this);
while (bp < this:token().bp)
this.plastic.utilities:suspend_if_necessary();
token = this:token();
this:advance();
left = token:led(this, left);
endwhile
return left;
return;
"this:_ensure_instance();";
"";
"{?bp = 0} = args;";
"";
"token = this:token();";
"this:advance();";
"";
"/* don't call `nud()' and/or `led()' on `(end)' */";
"if (token.id == \"(end)\")";
"  return token;";
"endif";
"";
"left = token:nud(this);";
"";
"while (bp < this:token().bp)";
"  this.plastic.utilities:suspend_if_necessary();";
"";
"  token = this:token();";
"  this:advance();";
"  left = token:led(this, left);";
"endwhile";
"";
"return left;";
"";
"chunk_length:23";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:50EEF6A277064F206681138B15FEBE5B7F61AB17";
"-=-=-mxyzptlk-=-=-";
.
#46:7
this:_ensure_instance();
token = this:token();
while (token.id == ";")
this:advance();
token = this:token();
endwhile
if (respond_to(token, "std"))
this:advance();
return token:std(this);
else
expression = this:expression();
if (this:token().id == ";")
this:advance();
endif
return expression;
endif
return;
"this:_ensure_instance();";
"";
"token = this:token();";
"";
"/* disregarded naked semicolons */";
"while (token.id == \";\")";
"  this:advance();";
"  token = this:token();";
"endwhile";
"";
"/* either the beginning of a statement */";
"/* or an expression with an optional semicolon */";
"if (respond_to(token, \"std\"))";
"  this:advance();";
"  return token:std(this);";
"else";
"  expression = this:expression();";
"  if (this:token().id == \";\")";
"    this:advance();";
"  endif";
"  return expression;";
"endif";
"";
"chunk_length:22";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A633F2B8764F84393F61203601572D48B1D56CCE";
"-=-=-mxyzptlk-=-=-";
.
#46:8
this:_ensure_instance();
terminals = args;
statements = {};
while (1)
this.plastic.utilities:suspend_if_necessary();
token = this:token();
if ((token.id == "(end)") || ((token.type in {"name", "statement", "keyword"}) && (token.value in terminals)))
break;
endif
statement = this:statement();
if (statement.id == "(end)")
break;
endif
statements = {@statements, statement};
endwhile
return statements;
return;
"this:_ensure_instance();";
"";
"terminals = args;";
"";
"statements = {};";
"";
"while (1)";
"  this.plastic.utilities:suspend_if_necessary();";
"";
"  token = this:token();";
"  if (token.id == \"(end)\" || ((token.type in {\"name\", \"statement\", \"keyword\"}) && token.value in terminals))";
"    break;";
"  endif";
"  statement = this:statement();";
"  if (statement.id == \"(end)\")";
"    break;";
"  endif";
"  statements = {@statements, statement};";
"endwhile";
"";
"return statements;";
"";
"chunk_length:21";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:26B5EBBBA34EA6F965B265987266BE54CF1A5383";
"-=-=-mxyzptlk-=-=-";
.
#46:9
this:_ensure_instance();
stack = statements = this:statements();
while (stack)
this.plastic.utilities:suspend_if_necessary();
{top, @stack} = stack;
stack = {@stack, @this.plastic.utilities:children(top)};
if (((typeof(top) == ANON) && isa(top, this.plastic.symbol_proto)) && (top.owner == this.owner))
this.object_utilities:change_owner(top, caller_perms());
endif
endwhile
return statements;
return;
"this:_ensure_instance();";
"";
"/* This is the API entry-point for clients that want to turn a";
" * stream of tokens into a syntax tree and to return it for further";
" * modification, changing ownership to the client in the process.";
" * Assumes \"change owner\" permission has been granted by the";
" * caller.";
" */";
"";
"stack = statements = this:statements();";
"";
"while (stack)";
"  this.plastic.utilities:suspend_if_necessary();";
"  {top, @stack} = stack;";
"  stack = {@stack, @this.plastic.utilities:children(top)};";
"  /* There is no requirement to clone nodes when rewriting a syntax";
"   * tree, therefore nodes may appear multiple times in different";
"   * parts of the tree.  Check ownership to ensure the node in";
"   * question has not already had its ownership changed.";
"   */";
"  if (typeof(top) == ANON && isa(top, this.plastic.symbol_proto) && top.owner == this.owner)";
"    this.object_utilities:change_owner(top, caller_perms());";
"  endif";
"endwhile";
"";
"return statements;";
"";
"chunk_length:26";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F0E5DB6DFD9B6859E94B2EAEC8C73B6C48774ED3";
"-=-=-mxyzptlk-=-=-";
.
#46:10
this:_ensure_instance();
definition = args;
{id, @rest} = definition;
new = 0;
if (`this.symbols[id] ! E_RANGE' == E_RANGE)
this:symbol(@definition);
new = 1;
endif
return {new, id};
return;
"this:_ensure_instance();";
"";
"definition = args;";
"{id, @rest} = definition;";
"";
"new = 0;";
"";
"if (`this.symbols[id] ! E_RANGE' == E_RANGE)";
"  this:symbol(@definition);";
"  new = 1;";
"endif";
"";
"return {new, id};";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4781098C110B4FFF668FD2A18CBD3BD8AFB62823";
"-=-=-mxyzptlk-=-=-";
.
#46:11
this:_ensure_instance();
{args} = args;
{new, id} = args;
if (new)
this.symbols = this.symbols:delete(id);
endif
return;
"this:_ensure_instance();";
"";
"{args} = args;";
"{new, id} = args;";
"";
"if (new)";
"  this.symbols = this.symbols:delete(id);";
"endif";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0694833C1581AAE25EFCBB39D68E09A5C5EECD56";
"-=-=-mxyzptlk-=-=-";
.
#47:0
{id, ?bp = 0, ?opts = []} = args;
(typeof(this) == OBJ) || raise(E_PERM, "Call not allowed on anonymous object");
instance = create(this, 1);
instance.id = id;
instance.value = id;
instance.bp = bp;
for v, k in (opts)
if (k in {"id", "type", "bp", "right"})
instance.(k) = v;
endif
endfor
return instance;
return;
"{id, ?bp = 0, ?opts = []} = args;";
"(typeof(this) == OBJ) || raise(E_PERM, \"Call not allowed on anonymous object\");";
"instance = create(this, 1);";
"instance.id = id;";
"instance.value = id;";
"instance.bp = bp;";
"for v, k in (opts)";
"  if (k in {\"id\", \"type\", \"bp\", \"right\"})";
"    instance.(k) = v;";
"  endif";
"endfor";
"return instance;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F6C542CA943DD579B0D958AB7497DBF9C43CE647";
"-=-=-mxyzptlk-=-=-";
.
#47:1
(typeof(this) == OBJ) && raise(E_PERM, "Call not allowed on permanent object");
parents = parents(this);
instance = create(parents, 1);
for ancestor in (ancestors(this))
for property in (`properties(ancestor) ! E_PERM => {}')
instance.(property) = this.(property);
endfor
endfor
return instance;
return;
"(typeof(this) == OBJ) && raise(E_PERM, \"Call not allowed on permanent object\");";
"parents = parents(this);";
"instance = create(parents, 1);";
"for ancestor in (ancestors(this))";
"  for property in (`properties(ancestor) ! E_PERM => {}')";
"    instance.(property) = this.(property);";
"  endfor";
"endfor";
"return instance;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4D2593BDDD8F59910175EAE7CB5A6545EF0EAFAD";
"-=-=-mxyzptlk-=-=-";
.
#47:2
{parser} = args;
raise("Syntax error", tostr("Undefined: ", this.id), parser);
return;
"{parser} = args;";
"raise(\"Syntax error\", tostr(\"Undefined: \", this.id), parser);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:68DC710F510F0E7CC805B4B86840E071693713E8";
"-=-=-mxyzptlk-=-=-";
.
#47:3
{parser, _} = args;
raise("Syntax error", tostr("Missing operator: ", this.id), parser);
return;
"{parser, _} = args;";
"raise(\"Syntax error\", tostr(\"Missing operator: \", this.id), parser);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:18A6698FEADF4FF80C0F7CAFE90F2DB32EC68A5F";
"-=-=-mxyzptlk-=-=-";
.
#48:0
return this;
return;
"return this;";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:58CFE4977A49A7695FEE4D2F29BB87606D70E92F";
"-=-=-mxyzptlk-=-=-";
.
#49:0
{parser} = args;
parser:make_variable(this);
return this;
return;
"{parser} = args;";
"";
"/* Assume the name is a variable.  Subsequent usage may modify this";
" * assumption.";
" */";
"parser:make_variable(this);";
"";
"return this;";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F8A8CBE63AC0F570B02EEC72ABA071DFFC348D70";
"-=-=-mxyzptlk-=-=-";
.
#50:0
{parser} = args;
raise("Syntax error", "Undefined", parser);
return;
"{parser} = args;";
"raise(\"Syntax error\", \"Undefined\", parser);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F2A4DE7467B49F34B0185D83E9DB7CC26D24EBDE";
"-=-=-mxyzptlk-=-=-";
.
#52:0
{parser} = args;
if ((this.id != "return") && (parser.loop_depth < 1))
raise("Syntax error", tostr("No enclosing loop for ", this.id), parser);
endif
parser:reserve_statement(this);
if ((!this.eol) && (parser:token().id != ";"))
expression = parser:expression(0);
this.first = expression;
endif
if ((this.id != "return") && (this.first != 0))
if (this.first.type != "variable")
raise("Syntax error", "Loop name must be a name", parser);
endif
if (!(this.first.value in parser.loop_variables))
raise("Syntax error", tostr("Invalid loop name for ", this.id), parser);
endif
endif
if (parser:token().id == ";")
parser:advance(";");
endif
return this;
return;
"{parser} = args;";
"";
"if (this.id != \"return\" && parser.loop_depth < 1)";
"  raise(\"Syntax error\", tostr(\"No enclosing loop for \", this.id), parser);";
"endif";
"";
"/* update the symbol table */";
"parser:reserve_statement(this);";
"";
"if (!this.eol && parser:token().id != \";\")";
"  expression = parser:expression(0);";
"  this.first = expression;";
"endif";
"";
"if (this.id != \"return\" && this.first != 0)";
"  if (this.first.type != \"variable\")";
"    raise(\"Syntax error\", \"Loop name must be a name\", parser);";
"  endif";
"  if (!(this.first.value in parser.loop_variables))";
"    raise(\"Syntax error\", tostr(\"Invalid loop name for \", this.id), parser);";
"  endif";
"endif";
"";
"if (parser:token().id == \";\")";
"  parser:advance(\";\");";
"endif";
"";
"return this;";
"";
"chunk_length:28";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:418293156AC1D9BE243C39A3EC9F3B7FFBE4CDD5";
"-=-=-mxyzptlk-=-=-";
.
#53:0
{parser, first} = args;
right = this.right && 1;
second = parser:expression(this.bp - right);
if (second.id == "(end)")
raise("Syntax error", "Expected an expression", parser);
endif
this.type = "binary";
this.first = first;
this.second = second;
return this;
return;
"{parser, first} = args;";
"";
"right = this.right && 1; /* does this operator associate to the right? */";
"";
"second = parser:expression(this.bp - right);";
"";
"if (second.id == \"(end)\")";
"  raise(\"Syntax error\", \"Expected an expression\", parser);";
"endif";
"";
"this.type = \"binary\";";
"this.first = first;";
"this.second = second;";
"";
"return this;";
"";
"chunk_length:15";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5A90918D1650451B6F3F14F2AC74F67C25F382B2";
"-=-=-mxyzptlk-=-=-";
.
#54:0
{parser, first} = args;
if ((first.type == "unary") && (first.id == "{"))
this.plastic.utilities:validate_scattering_pattern(parser, first.value);
first.type = "pattern";
endif
if ((((first.type != "variable") && (first.type != "pattern")) && (first.id != ".")) && (first.id != "["))
raise("Syntax error", "Illegal expression on left side of assignment", parser);
endif
second = parser:expression(this.bp - 1);
if (second.id == "(end)")
raise("Syntax error", "Expected an expression", parser);
endif
this.type = "binary";
this.first = first;
this.second = second;
return this;
return;
"{parser, first} = args;";
"";
"if (first.type == \"unary\" && first.id == \"{\") /* scattering syntax */";
"  this.plastic.utilities:validate_scattering_pattern(parser, first.value);";
"  first.type = \"pattern\";";
"endif";
"";
"if (first.type != \"variable\" && first.type != \"pattern\" && first.id != \".\" && first.id != \"[\")";
"  raise(\"Syntax error\", \"Illegal expression on left side of assignment\", parser);";
"endif";
"";
"second = parser:expression(this.bp - 1);";
"";
"if (second.id == \"(end)\")";
"  raise(\"Syntax error\", \"Expected an expression\", parser);";
"endif";
"";
"this.type = \"binary\";";
"this.first = first;";
"this.second = second;";
"";
"return this;";
"";
"chunk_length:22";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F0969021843EDF73519565F7131A329F32CD2DF5";
"-=-=-mxyzptlk-=-=-";
.
#55:0
{parser, first} = args;
if (((first.type != "variable") && (first.id != ".")) && (first.id != "["))
raise("Syntax error", "Illegal expression on left side of assignment", parser);
endif
second = parser:expression(this.bp - 1);
if (second.id == "(end)")
raise("Syntax error", "Expected an expression", parser);
endif
op = this.id[1];
bp = parser.symbols[op].bp;
inner = parser.plastic.infix_operator_proto:create(op, bp);
inner.type = "binary";
inner.first = first;
inner.second = second;
outer = parser.plastic.assignment_operator_proto:create("=", this.bp);
outer.type = "binary";
outer.first = first;
outer.second = inner;
return outer;
return;
"{parser, first} = args;";
"";
"if (first.type != \"variable\" && first.id != \".\" && first.id != \"[\")";
"  raise(\"Syntax error\", \"Illegal expression on left side of assignment\", parser);";
"endif";
"";
"second = parser:expression(this.bp - 1);";
"";
"if (second.id == \"(end)\")";
"  raise(\"Syntax error\", \"Expected an expression\", parser);";
"endif";
"";
"op = this.id[1];";
"bp = parser.symbols[op].bp;";
"";
"inner = parser.plastic.infix_operator_proto:create(op, bp);";
"inner.type = \"binary\";";
"inner.first = first;";
"inner.second = second;";
"";
"outer = parser.plastic.assignment_operator_proto:create(\"=\", this.bp);";
"outer.type = \"binary\";";
"outer.first = first;";
"outer.second = inner;";
"";
"return outer;";
"";
"chunk_length:26";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D668478D97D225907C9506876AB858AEEE19F2EE";
"-=-=-mxyzptlk-=-=-";
.
#56:0
{parser} = args;
first = parser:expression(700);
if (first.id == "(end)")
raise("Syntax error", "Expected an expression", parser);
endif
this.type = "unary";
this.first = first;
return this;
return;
"{parser} = args;";
"";
"first = parser:expression(700);";
"";
"if (first.id == \"(end)\")";
"  raise(\"Syntax error\", \"Expected an expression\", parser);";
"endif";
"";
"this.type = \"unary\";";
"this.first = first;";
"";
"return this;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:71052EB9A64F517E3CBE29438E498136C830D190";
"-=-=-mxyzptlk-=-=-";
.
#57:0
{parser} = args;
sequence = this.plastic.utilities:parse_map_sequence(parser, ",", "->", "]");
parser:token("]");
this.type = "unary";
this.value = sequence;
this.first = this;
return this;
return;
"{parser} = args;";
"";
"sequence = this.plastic.utilities:parse_map_sequence(parser, \",\", \"->\", \"]\");";
"parser:token(\"]\");";
"";
"this.type = \"unary\";";
"this.value = sequence;";
"this.first = this;";
"";
"return this;";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C58ADA1565060D3143B279910446F0D8F39D58CA";
"-=-=-mxyzptlk-=-=-";
.
#57:1
{parser, first} = args;
caret = parser:push("^", 0, this.plastic.positional_symbol_proto);
dollar = parser:push("$", 0, this.plastic.positional_symbol_proto);
second = parser:expression(0);
if (parser:token().id == "..")
parser:advance("..");
third = parser:expression(0);
parser:advance("]");
this.type = "ternary";
this.first = first;
this.second = second;
this.third = third;
else
parser:advance("]");
this.type = "binary";
this.first = first;
this.second = second;
endif
parser:pop(caret);
parser:pop(dollar);
return this;
return;
"{parser, first} = args;";
"";
"caret = parser:push(\"^\", 0, this.plastic.positional_symbol_proto);";
"dollar = parser:push(\"$\", 0, this.plastic.positional_symbol_proto);";
"";
"second = parser:expression(0);";
"";
"if (parser:token().id == \"..\")";
"  parser:advance(\"..\");";
"  third = parser:expression(0);";
"  parser:advance(\"]\");";
"  this.type = \"ternary\";";
"  this.first = first;";
"  this.second = second;";
"  this.third = third;";
"else";
"  parser:advance(\"]\");";
"  this.type = \"binary\";";
"  this.first = first;";
"  this.second = second;";
"endif";
"";
"parser:pop(caret);";
"parser:pop(dollar);";
"";
"return this;";
"";
"chunk_length:26";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E3672ECDB8F1E70C3B53C5793417BE0E54E98468";
"-=-=-mxyzptlk-=-=-";
.
#58:0
{parser} = args;
sequence = this.plastic.utilities:parse_list_sequence(parser, ",", "}");
parser:token("}");
this.type = "unary";
this.value = sequence;
this.first = this;
return this;
return;
"{parser} = args;";
"";
"sequence = this.plastic.utilities:parse_list_sequence(parser, \",\", \"}\");";
"parser:token(\"}\");";
"";
"this.type = \"unary\";";
"this.value = sequence;";
"this.first = this;";
"";
"return this;";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:687E36A53B89521FDC319DA7581CD449862A2BBF";
"-=-=-mxyzptlk-=-=-";
.
#59:0
{parser} = args;
parser:reserve_statement(this);
a = {};
parser:token("(");
expression = parser:expression(0);
a = {@a, expression};
parser:token(")");
statements = parser:statements("elseif", "else", "endif", "end");
a = {@a, statements};
while (parser:token().id == "elseif")
parser:advance("elseif");
parser:token("(");
expression = parser:expression(0);
a = {@a, expression};
parser:token(")");
statements = parser:statements("elseif", "else", "endif", "end");
a = {@a, statements};
symbol = parser.symbols["elseif"];
parser:reserve_keyword(symbol);
endwhile
if (parser:token().id == "else")
parser:advance("else");
statements = parser:statements("endif", "end");
a = {@a, statements};
symbol = parser.symbols["else"];
parser:reserve_keyword(symbol);
endif
if ((id = parser:token().id) == "endif")
parser:advance("endif");
else
parser:advance("end");
endif
symbol = parser.symbols[id];
parser:reserve_keyword(symbol);
this.value = a;
return this;
return;
"{parser} = args;";
"";
"/* update the symbol table */";
"parser:reserve_statement(this);";
"";
"a = {};";
"";
"/* the predicate */";
"parser:token(\"(\");";
"expression = parser:expression(0);";
"a = {@a, expression};";
"parser:token(\")\");";
"";
"/* the consequent */";
"statements = parser:statements(\"elseif\", \"else\", \"endif\", \"end\");";
"a = {@a, statements};";
"";
"/* the alternatives */";
"while (parser:token().id == \"elseif\")";
"  parser:advance(\"elseif\");";
"";
"  /* predicate */";
"  parser:token(\"(\");";
"  expression = parser:expression(0);";
"  a = {@a, expression};";
"  parser:token(\")\");";
"";
"  /* consequent */";
"  statements = parser:statements(\"elseif\", \"else\", \"endif\", \"end\");";
"  a = {@a, statements};";
"";
"  /* update the symbol table */";
"  symbol = parser.symbols[\"elseif\"];";
"  parser:reserve_keyword(symbol);";
"endwhile";
"";
"/* the final alternative */";
"if (parser:token().id == \"else\")";
"  parser:advance(\"else\");";
"";
"  statements = parser:statements(\"endif\", \"end\");";
"  a = {@a, statements};";
"";
"  /* update the symbol table */";
"  symbol = parser.symbols[\"else\"];";
"  parser:reserve_keyword(symbol);";
"endif";
"";
"/* the last token must be \"endif\" or \"end\" */";
"if ((id = parser:token().id) == \"endif\")";
"  parser:advance(\"endif\");";
"else";
"  parser:advance(\"end\");";
"endif";
"";
"/* update the symbol table */";
"symbol = parser.symbols[id];";
"parser:reserve_keyword(symbol);";
"";
"/* store the parts in this token's `value' */";
"this.value = a;";
"";
"return this;";
"";
"chunk_length:63";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:46F2D54F58E6B9C969243EEFCECA239D22FF4A45";
"-=-=-mxyzptlk-=-=-";
.
#60:0
{parser} = args;
expression = parser:expression(0);
parser:token(")");
this.type = "unary";
this.first = expression;
return this;
return;
"{parser} = args;";
"";
"expression = parser:expression(0);";
"parser:token(\")\");";
"";
"this.type = \"unary\";";
"this.first = expression;";
"";
"return this;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:1DDA7B523803C381657DBFCD1FEFBFBAD9085984";
"-=-=-mxyzptlk-=-=-";
.
#60:1
{parser, left} = args;
sequence = this.plastic.utilities:parse_list_sequence(parser, ",", ")");
parser:token(")");
if (left.id == ".")
raise("Syntax error", "Invalid application of invocation", parser);
elseif (left.id == ":")
first = left.first;
second = left.second;
this.type = "ternary";
this.first = first;
this.second = second;
this.third = sequence;
else
if (left.type != "variable")
raise("Syntax error", "Expected an identifier", parser);
endif
parser:make_identifier(left);
if (`import = parser.imports[left.value] ! E_RANGE' != E_RANGE)
this.type = "ternary";
this.first = import;
this.second = left;
this.third = sequence;
else
this.type = "binary";
this.first = left;
this.second = sequence;
endif
endif
return this;
return;
"{parser, left} = args;";
"";
"sequence = this.plastic.utilities:parse_list_sequence(parser, \",\", \")\");";
"parser:token(\")\");";
"";
"/* The invocation operator handles function and verb invocation, and";
" * guards against use on properties.";
" */";
"if (left.id == \".\")";
"  raise(\"Syntax error\", \"Invalid application of invocation\", parser);";
"elseif (left.id == \":\")";
"  first = left.first;";
"  second = left.second;";
"";
"  /* the verb selector operator has our back */";
"";
"  this.type = \"ternary\";";
"  this.first = first;";
"  this.second = second;";
"  this.third = sequence;";
"else";
"  if (left.type != \"variable\")";
"    raise(\"Syntax error\", \"Expected an identifier\", parser);";
"  endif";
"";
"  parser:make_identifier(left);";
"";
"  if (`import = parser.imports[left.value] ! E_RANGE' != E_RANGE)";
"    this.type = \"ternary\";";
"    this.first = import;";
"    this.second = left;";
"    this.third = sequence;";
"  else";
"    this.type = \"binary\";";
"    this.first = left;";
"    this.second = sequence;";
"  endif";
"endif";
"";
"return this;";
"";
"chunk_length:40";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A9ABE8B8945FE0CB838E789178BBC5A58B841398";
"-=-=-mxyzptlk-=-=-";
.
#61:0
{parser, first} = args;
if (parser:token().id == "(")
parser:advance("(");
second = parser:expression(0);
parser:advance(")");
else
second = parser:expression(this.bp);
if (second.type != "variable")
raise("Syntax error", "Expected an identifier", parser);
endif
parser:make_identifier(second);
endif
if (parser:token().id != "(")
raise("Syntax error", "Expected `('", parser);
endif
this.type = "binary";
this.first = first;
this.second = second;
return this;
return;
"{parser, first} = args;";
"";
"if (parser:token().id == \"(\")";
"  parser:advance(\"(\");";
"  second = parser:expression(0);";
"  parser:advance(\")\");";
"else";
"  second = parser:expression(this.bp);";
"  if (second.type != \"variable\")";
"    raise(\"Syntax error\", \"Expected an identifier\", parser);";
"  endif";
"  parser:make_identifier(second);";
"endif";
"";
"if (parser:token().id != \"(\")";
"  raise(\"Syntax error\", \"Expected `('\", parser);";
"endif";
"";
"this.type = \"binary\";";
"this.first = first;";
"this.second = second;";
"";
"return this;";
"";
"chunk_length:23";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B9DFBD0CCD5EEDED7AC95EC7FAD47D65829DDBEE";
"-=-=-mxyzptlk-=-=-";
.
#62:0
{parser, first} = args;
if (parser:token().id == "(")
parser:advance("(");
second = parser:expression(0);
parser:advance(")");
else
second = parser:expression(this.bp);
if (second.type != "variable")
raise("Syntax error", "Expected an identifier", parser);
endif
parser:make_identifier(second);
endif
this.type = "binary";
this.first = first;
this.second = second;
return this;
return;
"{parser, first} = args;";
"";
"if (parser:token().id == \"(\")";
"  parser:advance(\"(\");";
"  second = parser:expression(0);";
"  parser:advance(\")\");";
"else";
"  second = parser:expression(this.bp);";
"  if (second.type != \"variable\")";
"    raise(\"Syntax error\", \"Expected an identifier\", parser);";
"  endif";
"  parser:make_identifier(second);";
"endif";
"";
"this.type = \"binary\";";
"this.first = first;";
"this.second = second;";
"";
"return this;";
"";
"chunk_length:19";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C3E0624F254D64CFCB9D8CE99CBFEA6B40E2E6B1";
"-=-=-mxyzptlk-=-=-";
.
#63:0
{parser} = args;
first = parser:expression(700);
if (first.id == "(end)")
raise("Syntax error", "Expected an expression", parser);
endif
this.type = "unary";
this.first = first;
return this;
return;
"{parser} = args;";
"";
"first = parser:expression(700);";
"";
"if (first.id == \"(end)\")";
"  raise(\"Syntax error\", \"Expected an expression\", parser);";
"endif";
"";
"this.type = \"unary\";";
"this.first = first;";
"";
"return this;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:71052EB9A64F517E3CBE29438E498136C830D190";
"-=-=-mxyzptlk-=-=-";
.
#63:1
{parser, first} = args;
id = parser:push("@", 0, this.plastic.prefix_operator_proto);
if ((token = parser:token()).id == "ANY")
parser:advance("ANY");
symbol = parser.symbols["ANY"];
parser:reserve_keyword(symbol);
second = {token};
else
second = this.plastic.utilities:parse_list_sequence(parser, ",", "");
if (second[$].id == "(end)")
raise("Syntax error", "Expected `ANY' or a list of expressions", parser);
endif
endif
parser:pop(id);
if ((token = parser:token()).id == "=>")
parser:advance("=>");
third = parser:expression(0);
if (third.id == "(end)")
raise("Syntax error", "Expected an expression", parser);
endif
this.type = "ternary";
this.first = first;
this.second = second;
this.third = third;
else
this.type = "binary";
this.first = first;
this.second = second;
endif
return this;
return;
"{parser, first} = args;";
"";
"/* Error codes are either the keyword `ANY' or a list of expressions";
" * (see 4.1.12 Catching Errors in Expressions).";
" */";
"id = parser:push(\"@\", 0, this.plastic.prefix_operator_proto);";
"";
"if ((token = parser:token()).id == \"ANY\")";
"  parser:advance(\"ANY\");";
"  symbol = parser.symbols[\"ANY\"];";
"  parser:reserve_keyword(symbol);";
"  second = {token};";
"else";
"  second = this.plastic.utilities:parse_list_sequence(parser, \",\", \"\");";
"";
"  if (second[$].id == \"(end)\")";
"    raise(\"Syntax error\", \"Expected `ANY' or a list of expressions\", parser);";
"  endif";
"endif";
"";
"parser:pop(id);";
"";
"if ((token = parser:token()).id == \"=>\")";
"  parser:advance(\"=>\");";
"  third = parser:expression(0);";
"";
"  if (third.id == \"(end)\")";
"    raise(\"Syntax error\", \"Expected an expression\", parser);";
"  endif";
"";
"  this.type = \"ternary\";";
"  this.first = first;";
"  this.second = second;";
"  this.third = third;";
"else";
"  this.type = \"binary\";";
"  this.first = first;";
"  this.second = second;";
"endif";
"";
"return this;";
"";
"chunk_length:41";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3F74393AE60842B8E06B0DEB07E005C4B0350E3B";
"-=-=-mxyzptlk-=-=-";
.
#64:0
{parser, first} = args;
second = parser:expression(0);
parser:token("|");
third = parser:expression(0);
if ((second.id == "(end)") || (third.id == "(end)"))
raise("Syntax error", "Expected an expression", parser);
endif
this.type = "ternary";
this.first = first;
this.second = second;
this.third = third;
return this;
return;
"{parser, first} = args;";
"";
"second = parser:expression(0);";
"parser:token(\"|\");";
"third = parser:expression(0);";
"";
"if (second.id == \"(end)\" || third.id == \"(end)\")";
"  raise(\"Syntax error\", \"Expected an expression\", parser);";
"endif";
"";
"this.type = \"ternary\";";
"this.first = first;";
"this.second = second;";
"this.third = third;";
"";
"return this;";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5437C1BBEF59856CD0E8FF421B0C741D0AA42CE2";
"-=-=-mxyzptlk-=-=-";
.
#65:0
{parser} = args;
parser:reserve_statement(this);
a = {};
variables = {};
variable = parser:token();
parser:make_variable(variable);
parser:advance();
variables = {@variables, variable};
if (parser:token().id == ",")
while (parser:token().id == ",")
parser:advance(",");
variable = parser:token();
parser:make_variable(variable);
parser:advance();
variables = {@variables, variable};
endwhile
elseif (parser:token().id == "->")
while (parser:token().id == "->")
parser:advance("->");
variable = parser:token();
parser:make_variable(variable);
parser:advance();
variables = {variable, @variables};
endwhile
endif
a = {@a, @variables};
for _, i in (variables)
variables[i] = variables[i].id;
endfor
parser:token("in");
symbol = parser.symbols["in"];
parser:reserve_keyword(symbol);
if (parser:token().id == "[")
this.subtype = "range";
(length(a) < 2) || raise("Syntax error", "Too many loop variables", parser);
parser:token("[");
first = parser:expression(0);
a = {@a, first};
parser:token("..");
second = parser:expression(0);
a = {@a, second};
parser:token("]");
else
this.subtype = "collection";
(length(a) < 3) || raise("Syntax error", "Too many loop variables", parser);
parser:token("(");
expression = parser:expression(0);
a = {@a, expression};
parser:token(")");
endif
parser.loop_variables = {@parser.loop_variables, @variables};
parser.loop_depth = parser.loop_depth + 1;
statements = parser:statements("endfor", "end");
a = {@a, statements};
l = length(variables);
parser.loop_variables = parser.loop_variables[1..$ - l];
parser.loop_depth = parser.loop_depth - 1;
if ((id = parser:token().id) == "endfor")
parser:advance("endfor");
else
parser:advance("end");
endif
symbol = parser.symbols[id];
parser:reserve_keyword(symbol);
this.value = a;
return this;
return;
"{parser} = args;";
"";
"/* update the symbol table */";
"parser:reserve_statement(this);";
"";
"a = {};";
"";
"/* the index(s) */";
"variables = {};";
"";
"variable = parser:token();";
"parser:make_variable(variable);";
"parser:advance();";
"variables = {@variables, variable};";
"";
"if (parser:token().id == \",\")";
"  while (parser:token().id == \",\")";
"    parser:advance(\",\");";
"    variable = parser:token();";
"    parser:make_variable(variable);";
"    parser:advance();";
"    variables = {@variables, variable};";
"  endwhile";
"elseif (parser:token().id == \"->\")";
"  while (parser:token().id == \"->\")";
"    parser:advance(\"->\");";
"    variable = parser:token();";
"    parser:make_variable(variable);";
"    parser:advance();";
"    variables = {variable, @variables};";
"  endwhile";
"endif";
"";
"a = {@a, @variables};";
"";
"for _, i in (variables)";
"  variables[i] = variables[i].id;";
"endfor";
"";
"parser:token(\"in\");";
"";
"/* update the symbol table */";
"symbol = parser.symbols[\"in\"];";
"parser:reserve_keyword(symbol);";
"";
"/* could be a range or a collection */";
"if (parser:token().id == \"[\")";
"  /* range */";
"  this.subtype = \"range\";";
"  length(a) < 2 || raise(\"Syntax error\", \"Too many loop variables\", parser);";
"  parser:token(\"[\");";
"  first = parser:expression(0);";
"  a = {@a, first};";
"  parser:token(\"..\");";
"  second = parser:expression(0);";
"  a = {@a, second};";
"  parser:token(\"]\");";
"else";
"  /* collection */";
"  this.subtype = \"collection\";";
"  length(a) < 3 || raise(\"Syntax error\", \"Too many loop variables\", parser);";
"  parser:token(\"(\");";
"  expression = parser:expression(0);";
"  a = {@a, expression};";
"  parser:token(\")\");";
"endif";
"";
"/* the body */";
"parser.loop_variables = {@parser.loop_variables, @variables};";
"parser.loop_depth = parser.loop_depth + 1;";
"";
"statements = parser:statements(\"endfor\", \"end\");";
"a = {@a, statements};";
"";
"l = length(variables);";
"parser.loop_variables = parser.loop_variables[1..$ - l];";
"parser.loop_depth = parser.loop_depth - 1;";
"";
"/* the last token must be \"endfor\" or \"end\" */";
"if ((id = parser:token().id) == \"endfor\")";
"  parser:advance(\"endfor\");";
"else";
"  parser:advance(\"end\");";
"endif";
"";
"/* update the symbol table */";
"symbol = parser.symbols[id];";
"parser:reserve_keyword(symbol);";
"";
"/* store the parts in this token's `value' */";
"this.value = a;";
"";
"return this;";
"";
"chunk_length:93";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5AAB8E9CAAFE384224B1C38E9A1D2672AB4B26C6";
"-=-=-mxyzptlk-=-=-";
.
#66:0
{parser} = args;
parser:reserve_statement(this);
end = tostr("end", this.id);
a = {};
variables = {};
if (((type = parser:token().type) == "variable") || (type == "name"))
variable = parser:token();
parser:make_variable(variable);
parser:advance();
variables = {@variables, variable.id};
a = {@a, variable};
endif
parser:token("(");
expression = parser:expression(0);
a = {@a, expression};
parser:token(")");
parser.loop_variables = {@parser.loop_variables, @variables};
parser.loop_depth = parser.loop_depth + 1;
statements = parser:statements(end, "end");
a = {@a, statements};
l = length(variables);
parser.loop_variables = parser.loop_variables[1..$ - l];
parser.loop_depth = parser.loop_depth - 1;
if ((id = parser:token().id) == end)
parser:advance(end);
else
parser:advance("end");
endif
symbol = parser.symbols[id];
parser:reserve_keyword(symbol);
this.value = a;
return this;
return;
"{parser} = args;";
"";
"/* update the symbol table */";
"parser:reserve_statement(this);";
"";
"end = tostr(\"end\", this.id);";
"";
"a = {};";
"";
"/* possible, optional loop name */";
"variables = {};";
"if ((type = parser:token().type) == \"variable\" || type == \"name\")";
"  variable = parser:token();";
"  parser:make_variable(variable);";
"  parser:advance();";
"  variables = {@variables, variable.id};";
"  a = {@a, variable};";
"endif";
"";
"/* the condition */";
"parser:token(\"(\");";
"expression = parser:expression(0);";
"a = {@a, expression};";
"parser:token(\")\");";
"";
"/* the body */";
"parser.loop_variables = {@parser.loop_variables, @variables};";
"parser.loop_depth = parser.loop_depth + 1;";
"";
"statements = parser:statements(end, \"end\");";
"a = {@a, statements};";
"";
"l = length(variables);";
"parser.loop_variables = parser.loop_variables[1..$ - l];";
"parser.loop_depth = parser.loop_depth - 1;";
"";
"/* the last token must be \"endwhile/enduntil\" or \"end\" */";
"if ((id = parser:token().id) == end)";
"  parser:advance(end);";
"else";
"  parser:advance(\"end\");";
"endif";
"";
"/* update the symbol table */";
"symbol = parser.symbols[id];";
"parser:reserve_keyword(symbol);";
"";
"/* store the parts in this token's `value' */";
"this.value = a;";
"";
"return this;";
"";
"chunk_length:51";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:DC2BECAEBBED52539E7926D3C715C5F443673A8D";
"-=-=-mxyzptlk-=-=-";
.
#67:0
{parser} = args;
parser:reserve_statement(this);
a = {};
if (((type = parser:token().type) == "variable") || (type == "name"))
variable = parser:token();
parser:make_variable(variable);
parser:advance();
a = {@a, variable};
endif
parser:token("(");
expression = parser:expression(0);
a = {@a, expression};
parser:token(")");
statements = parser:statements("endfork", "end");
a = {@a, statements};
if ((id = parser:token().id) == "endfork")
parser:advance("endfork");
else
parser:advance("end");
endif
symbol = parser.symbols[id];
parser:reserve_keyword(symbol);
this.value = a;
return this;
return;
"{parser} = args;";
"";
"/* update the symbol table */";
"parser:reserve_statement(this);";
"";
"a = {};";
"";
"/* possible, optional task name */";
"if ((type = parser:token().type) == \"variable\" || type == \"name\")";
"  variable = parser:token();";
"  parser:make_variable(variable);";
"  parser:advance();";
"  a = {@a, variable};";
"endif";
"";
"/* the expression */";
"parser:token(\"(\");";
"expression = parser:expression(0);";
"a = {@a, expression};";
"parser:token(\")\");";
"";
"/* the body */";
"statements = parser:statements(\"endfork\", \"end\");";
"a = {@a, statements};";
"";
"/* the last token must be \"endfork\" or \"end\" */";
"if ((id = parser:token().id) == \"endfork\")";
"  parser:advance(\"endfork\");";
"else";
"  parser:advance(\"end\");";
"endif";
"";
"/* update the symbol table */";
"symbol = parser.symbols[id];";
"parser:reserve_keyword(symbol);";
"";
"/* store the parts in this token's `value' */";
"this.value = a;";
"";
"return this;";
"";
"chunk_length:40";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0ED7146966275E0722F7F9DF4BD7F76C03BB0DDD";
"-=-=-mxyzptlk-=-=-";
.
#68:0
{parser} = args;
parser:reserve_statement(this);
a = {};
body = parser:statements("except", "finally", "endtry", "end");
a = {@a, body};
if (parser:token().id == "finally")
parser:advance("finally");
b = parser:statements("endtry", "end");
symbol = parser.symbols["finally"];
parser:reserve_keyword(symbol);
this.subtype = "finally";
a = {@a, b};
else
b = {};
id = parser:push("@", 0, this.plastic.prefix_operator_proto);
while (parser:token().id == "except")
parser:advance("except");
if ((variable = parser:token()).id != "(")
parser:advance();
if ((variable.type != "name") && (variable.type != "variable"))
raise("Syntax error", "Variable must be an identifier", parser);
endif
parser:make_variable(variable);
parser:token("(");
if ((token = parser:token()).id == "ANY")
parser:advance("ANY");
symbol = parser.symbols["ANY"];
parser:reserve_keyword(symbol);
codes = {token};
else
codes = this.plastic.utilities:parse_list_sequence(parser, ",", ")");
endif
parser:token(")");
(!codes) && raise("Syntax error", "Codes may not be empty", parser);
b = {variable, codes};
else
parser:token("(");
if ((token = parser:token()).id == "ANY")
parser:advance("ANY");
symbol = parser.symbols["ANY"];
parser:reserve_keyword(symbol);
codes = {token};
else
codes = this.plastic.utilities:parse_list_sequence(parser, ",", ")");
endif
parser:token(")");
(!codes) && raise("Syntax error", "Codes may not be empty", parser);
b = {codes};
endif
handler = parser:statements("except", "finally", "endtry", "end");
b = {@b, handler};
symbol = parser.symbols["except"];
parser:reserve_keyword(symbol);
a = {@a, b};
endwhile
parser:pop(id);
if (!b)
raise("Syntax error", "Missing except", parser);
endif
this.subtype = "except";
endif
if ((id = parser:token().id) == "endtry")
parser:advance("endtry");
else
parser:advance("end");
endif
symbol = parser.symbols[id];
parser:reserve_keyword(symbol);
this.value = a;
return this;
return;
"{parser} = args;";
"";
"/* update the symbol table */";
"parser:reserve_statement(this);";
"";
"a = {};";
"";
"/* the body */";
"body = parser:statements(\"except\", \"finally\", \"endtry\", \"end\");";
"a = {@a, body};";
"";
"if (parser:token().id == \"finally\")";
"  parser:advance(\"finally\");";
"";
"  b = parser:statements(\"endtry\", \"end\");";
"";
"  /* update the symbol table */";
"  symbol = parser.symbols[\"finally\"];";
"  parser:reserve_keyword(symbol);";
"";
"  this.subtype = \"finally\";";
"";
"  a = {@a, b};";
"";
"else";
"  b = {};";
"";
"  id = parser:push(\"@\", 0, this.plastic.prefix_operator_proto);";
"";
"  /* the exceptions */";
"  while (parser:token().id == \"except\")";
"    parser:advance(\"except\");";
"";
"    /* variable and codes */";
"    if ((variable = parser:token()).id != \"(\")";
"      parser:advance();";
"";
"      if (variable.type != \"name\" && variable.type != \"variable\")";
"        raise(\"Syntax error\", \"Variable must be an identifier\", parser);";
"      endif";
"      parser:make_variable(variable);";
"";
"      parser:token(\"(\");";
"      if ((token = parser:token()).id == \"ANY\")";
"        parser:advance(\"ANY\");";
"        symbol = parser.symbols[\"ANY\"];";
"        parser:reserve_keyword(symbol);";
"        codes = {token};";
"      else";
"        codes = this.plastic.utilities:parse_list_sequence(parser, \",\", \")\");";
"      endif";
"      parser:token(\")\");";
"";
"      !codes && raise(\"Syntax error\", \"Codes may not be empty\", parser);";
"";
"      b = {variable, codes};";
"";
"    /* just codes */";
"    else";
"      parser:token(\"(\");";
"      if ((token = parser:token()).id == \"ANY\")";
"        parser:advance(\"ANY\");";
"        symbol = parser.symbols[\"ANY\"];";
"        parser:reserve_keyword(symbol);";
"        codes = {token};";
"      else";
"        codes = this.plastic.utilities:parse_list_sequence(parser, \",\", \")\");";
"      endif";
"      parser:token(\")\");";
"";
"      !codes && raise(\"Syntax error\", \"Codes may not be empty\", parser);";
"";
"      b = {codes};";
"";
"    endif";
"";
"    /* handler */";
"    handler = parser:statements(\"except\", \"finally\", \"endtry\", \"end\");";
"    b = {@b, handler};";
"";
"    /* update the symbol table */";
"    symbol = parser.symbols[\"except\"];";
"    parser:reserve_keyword(symbol);";
"";
"    a = {@a, b};";
"";
"  endwhile";
"";
"  parser:pop(id);";
"";
"  if (!b)";
"    raise(\"Syntax error\", \"Missing except\", parser);";
"  endif";
"";
"  this.subtype = \"except\";";
"";
"endif";
"";
"/* the last token must be \"endtry\" or \"end\" */";
"if ((id = parser:token().id) == \"endtry\")";
"  parser:advance(\"endtry\");";
"else";
"  parser:advance(\"end\");";
"endif";
"";
"/* update the symbol table */";
"symbol = parser.symbols[id];";
"parser:reserve_keyword(symbol);";
"";
"/* store the parts in this token's `value' */";
"this.value = a;";
"";
"return this;";
"";
"chunk_length:113";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E35D0E704DAB84B635FDF374A2AE5B68C2A8A8EC";
"-=-=-mxyzptlk-=-=-";
.
#69:0
return this;
return;
"return this;";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:58CFE4977A49A7695FEE4D2F29BB87606D70E92F";
"-=-=-mxyzptlk-=-=-";
.
#70:0
{parser} = args;
first = parser:expression(700);
if (first.id == "(end)")
raise("Syntax error", "Expected an expression", parser);
endif
this.type = "unary";
this.first = first;
return this;
return;
"{parser} = args;";
"";
"first = parser:expression(700);";
"";
"if (first.id == \"(end)\")";
"  raise(\"Syntax error\", \"Expected an expression\", parser);";
"endif";
"";
"this.type = \"unary\";";
"this.first = first;";
"";
"return this;";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:71052EB9A64F517E3CBE29438E498136C830D190";
"-=-=-mxyzptlk-=-=-";
.
#70:1
{parser, first} = args;
second = parser:expression(this.bp);
if (second.id == "(end)")
raise("Syntax error", "Expected an expression", parser);
endif
this.type = "binary";
this.first = first;
this.second = second;
return this;
return;
"{parser, first} = args;";
"";
"second = parser:expression(this.bp);";
"";
"if (second.id == \"(end)\")";
"  raise(\"Syntax error\", \"Expected an expression\", parser);";
"endif";
"";
"this.type = \"binary\";";
"this.first = first;";
"this.second = second;";
"";
"return this;";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A9AE696659B56975F48F68AF477F92EB2084698F";
"-=-=-mxyzptlk-=-=-";
.
#71:0
{parser} = args;
parser:reserve_statement(this);
types = {"name", "variable", "identifier"};
if ((target = parser:token()).type == "string")
parser:advance();
elseif ((target.type in types) && (target.value == "this"))
parser:advance();
elseif ((target.type in types) && (target.value[1] == "$"))
target = parser:expression();
if (target.id == ".")
temp = target;
while (temp.id == ".")
if (((temp.first.id != ".") && (!(temp.first.type in types))) && (!(temp.second.type in types)))
raise("Syntax error", tostr("Invalid reference: ", target.id), parser);
endif
temp = temp.first;
endwhile
elseif (target.value[1] == "$")
else
raise("Syntax error", tostr("Invalid reference: ", target.id), parser);
endif
else
raise("Syntax error", tostr("Invalid reference: ", target.id), parser);
endif
parser:token("use");
symbol = parser.symbols["use"];
parser:reserve_keyword(symbol);
imports = {};
if ((import = parser:token()).id == "(end)")
raise("Syntax error", "Expected an identifier", parser);
elseif (!(import.type in types))
raise("Syntax error", "Import must be an identifier", parser);
endif
parser:make_identifier(import);
parser:advance();
imports = {@imports, import};
while (parser:token().id == ",")
parser:advance(",");
if ((import = parser:token()).id == "(end)")
raise("Syntax error", "Expected an identifier", parser);
elseif (!(import.type in types))
raise("Syntax error", "Import must be an identifier", parser);
endif
parser:make_identifier(import);
parser:advance();
imports = {@imports, import};
endwhile
if (target.type == "string")
temp = parser.plastic.invocation_operator_proto:create("(");
temp.type = "binary";
temp.first = parser.plastic.name_proto:create("$lookup");
temp.first.type = "identifier";
temp.first.value = "$lookup";
temp.second = {target};
target = temp;
endif
first = parser.plastic.name_proto:create(tostr(random()));
first.type = "unique";
if (!length(imports))
raise("Syntax error", "Missing imports", parser);
endif
for import in (imports)
if (`parser.imports[import.id] ! E_RANGE' != E_RANGE)
raise("Syntax error", "Duplicate imports", parser);
endif
parser.imports[import.id] = first;
endfor
result = parser.plastic.assignment_operator_proto:create("=");
result.type = "binary";
result.first = first;
result.second = target;
return result;
return;
"{parser} = args;";
"";
"/* update the symbol table */";
"parser:reserve_statement(this);";
"";
"types = {\"name\", \"variable\", \"identifier\"};";
"";
"/* the reference */";
"if ((target = parser:token()).type == \"string\")";
"  parser:advance();";
"elseif (target.type in types && target.value == \"this\")";
"  parser:advance();";
"elseif (target.type in types && target.value[1] == \"$\")";
"  target = parser:expression();";
"  if (target.id == \".\")";
"    temp = target;";
"    while (temp.id == \".\")";
"      if ((temp.first.id != \".\" && !(temp.first.type in types)) && !(temp.second.type in types))";
"        raise(\"Syntax error\", tostr(\"Invalid reference: \", target.id), parser);";
"      endif";
"      temp = temp.first;";
"    endwhile";
"  elseif (target.value[1] == \"$\")";
"    /* ok */";
"  else";
"    raise(\"Syntax error\", tostr(\"Invalid reference: \", target.id), parser);";
"  endif";
"else";
"  raise(\"Syntax error\", tostr(\"Invalid reference: \", target.id), parser);";
"endif";
"";
"parser:token(\"use\");";
"";
"/* update the symbol table */";
"symbol = parser.symbols[\"use\"];";
"parser:reserve_keyword(symbol);";
"";
"/* the import(s) */";
"imports = {};";
"";
"if ((import = parser:token()).id == \"(end)\")";
"  raise(\"Syntax error\", \"Expected an identifier\", parser);";
"elseif (!(import.type in types))";
"  raise(\"Syntax error\", \"Import must be an identifier\", parser);";
"endif";
"parser:make_identifier(import);";
"parser:advance();";
"imports = {@imports, import};";
"";
"while (parser:token().id == \",\")";
"  parser:advance(\",\");";
"  if ((import = parser:token()).id == \"(end)\")";
"    raise(\"Syntax error\", \"Expected an identifier\", parser);";
"  elseif (!(import.type in types))";
"    raise(\"Syntax error\", \"Import must be an identifier\", parser);";
"  endif";
"  parser:make_identifier(import);";
"  parser:advance();";
"  imports = {@imports, import};";
"endwhile";
"";
"/* generate code */";
"if (target.type == \"string\")";
"  temp = parser.plastic.invocation_operator_proto:create(\"(\");";
"  temp.type = \"binary\";";
"  temp.first = parser.plastic.name_proto:create(\"$lookup\");";
"  temp.first.type = \"identifier\";";
"  temp.first.value = \"$lookup\";";
"  temp.second = {target};";
"  target = temp;";
"endif";
"";
"first = parser.plastic.name_proto:create(tostr(random()));";
"first.type = \"unique\";";
"";
"if (!length(imports))";
"  raise(\"Syntax error\", \"Missing imports\", parser);";
"endif";
"";
"for import in (imports)";
"  if (`parser.imports[import.id] ! E_RANGE' != E_RANGE)";
"    raise(\"Syntax error\", \"Duplicate imports\", parser);";
"  endif";
"  parser.imports[import.id] = first;";
"endfor";
"";
"result = parser.plastic.assignment_operator_proto:create(\"=\");";
"result.type = \"binary\";";
"result.first = first;";
"result.second = target;";
"";
"return result;";
"";
"chunk_length:92";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:7DB690B77D7FD6951C7E3F6EF124D6789998DC2D";
"-=-=-mxyzptlk-=-=-";
.
#74:0
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
return;
"ticks_left() < 10000 || seconds_left() < 2 && suspend(0);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C3608BDA1ACF59B6AE2D36C8E3B873466464014B";
"-=-=-mxyzptlk-=-=-";
.
#74:1
{lines, ?intern = []} = args;
algo = this.default_hash_algo;
result = {};
for line in (lines)
this:_suspend_if_necessary();
hash = string_hash(line, algo);
hash = `intern[hash] ! E_RANGE => intern[hash] = hash';
result = {@result, {line, hash}};
endfor
return {result, intern};
return;
"{lines, ?intern = []} = args;";
"";
"/* By interning strings we ensure that string storage is re-used,";
" * which reduces string compare down to a pointer equality check in";
" * the server.";
" */";
"";
"algo = this.default_hash_algo;";
"";
"result = {};";
"for line in (lines)";
"  this:_suspend_if_necessary();";
"  hash = string_hash(line, algo);";
"  hash = `intern[hash] ! E_RANGE => intern[hash] = hash';";
"  result = {@result, {line, hash}};";
"endfor";
"";
"return {result, intern};";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3B840B91F733C547C6F63B2420E85AD186EF1B0E";
"-=-=-mxyzptlk-=-=-";
.
#74:2
{lines1, lines2, intern} = args;
for v, k in (intern)
this:_suspend_if_necessary();
intern[k] = {{0, 0}, {0, 0}};
endfor
for line, i in (lines1)
this:_suspend_if_necessary();
intern[line[2]][1] = {intern[line[2]][1][1] + 1, i};
endfor
for line, i in (lines2)
this:_suspend_if_necessary();
intern[line[2]][2] = {intern[line[2]][2][1] + 1, i};
endfor
items = {};
for line in (lines1)
this:_suspend_if_necessary();
item = intern[line[2]];
if ((item[1][1] == 1) && (item[2][1] == 1))
items = {@items, {item[1][2], item[2][2]}};
endif
endfor
return items;
return;
"{lines1, lines2, intern} = args;";
"";
"for v, k in (intern)";
"  this:_suspend_if_necessary();";
"  intern[k] = {{0, 0}, {0, 0}};";
"endfor";
"";
"for line, i in (lines1)";
"  this:_suspend_if_necessary();";
"  intern[line[2]][1] = {intern[line[2]][1][1] + 1, i};";
"endfor";
"";
"for line, i in (lines2)";
"  this:_suspend_if_necessary();";
"  intern[line[2]][2] = {intern[line[2]][2][1] + 1, i};";
"endfor";
"";
"items = {};";
"for line in (lines1)";
"  this:_suspend_if_necessary();";
"  item = intern[line[2]];";
"  if (item[1][1] == 1 && item[2][1] == 1)";
"    items = {@items, {item[1][2], item[2][2]}};";
"  endif";
"endfor";
"";
"return items;";
"";
"chunk_length:27";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:BCF4FA5C1C969563D67684352B747F95260A8CAD";
"-=-=-mxyzptlk-=-=-";
.
#74:3
{items} = args;
stacks = {};
for item in (items)
last = 0;
for i in [1..length(stacks)]
this:_suspend_if_necessary();
if (item[2] < stacks[i][$][1][2])
stacks[i] = {@stacks[i], {item, last}};
item = 0;
break;
endif
last = length(stacks[i]);
endfor
if (item)
stacks = {@stacks, {{item, last}}};
endif
endfor
stacks = stacks:reverse();
i = stacks && length(stacks[1]);
results = {};
for stack in (stacks)
this:_suspend_if_necessary();
item = stack[i];
results = {item[1], @results};
i = item[2];
endfor
return results;
return;
"{items} = args;";
"";
"/* patience sort */";
"stacks = {};";
"for item in (items)";
"  last = 0;";
"  for i in [1..length(stacks)]";
"    this:_suspend_if_necessary();";
"    if (item[2] < stacks[i][$][1][2])";
"      stacks[i] = {@stacks[i], {item, last}};";
"      item = 0;";
"      break;";
"    endif";
"    last = length(stacks[i]);";
"  endfor";
"  if (item)";
"    stacks = {@stacks, {{item, last}}};";
"  endif";
"endfor";
"";
"stacks = stacks:reverse();";
"i = stacks && length(stacks[1]);";
"results = {};";
"for stack in (stacks)";
"  this:_suspend_if_necessary();";
"  item = stack[i];";
"  results = {item[1], @results};";
"  i = item[2];";
"endfor";
"";
"return results;";
"";
"chunk_length:31";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F2F39DE79F64CBBB7E604B1600CB04F108F937D1";
"-=-=-mxyzptlk-=-=-";
.
#74:4
{lines1, lines2, lcs} = args;
last = {0, 0};
lcs = {@lcs, {length(lines1) + 1, length(lines2) + 1}};
results = {};
for pos in (lcs)
this:_suspend_if_necessary();
i1 = last[1] + 1;
j1 = pos[1] - 1;
i2 = last[2] + 1;
j2 = pos[2] - 1;
while (i1 < j1)
this:_suspend_if_necessary();
if (lines1[i1][2] == `lines2[i2][2] ! E_RANGE')
i1 = i1 + 1;
i2 = i2 + 1;
continue;
endif
break;
endwhile
while (j1 >= i1)
this:_suspend_if_necessary();
if (lines1[j1][2] == `lines2[j2][2] ! E_RANGE')
j1 = j1 - 1;
j2 = j2 - 1;
continue;
endif
break;
endwhile
res1 = lines1[i1..j1]:slice(1);
res2 = lines2[i2..j2]:slice(1);
if (res1 && res2)
results = {@results, {"r", i1, i2, res1, res2}};
elseif (res1)
results = {@results, {"-", i1, i2, res1}};
elseif (res2)
results = {@results, {"+", i1, i2, res2}};
endif
last = pos;
endfor
return results;
return;
"{lines1, lines2, lcs} = args;";
"";
"last = {0, 0};";
"lcs = {@lcs, {length(lines1) + 1, length(lines2) + 1}};";
"";
"results = {};";
"for pos in (lcs)";
"  this:_suspend_if_necessary();";
"";
"  i1 = last[1] + 1;";
"  j1 = pos[1] - 1;";
"  i2 = last[2] + 1;";
"  j2 = pos[2] - 1;";
"  while (i1 < j1)";
"    this:_suspend_if_necessary();";
"    if (lines1[i1][2] == `lines2[i2][2] ! E_RANGE')";
"      i1 = i1 + 1;";
"      i2 = i2 + 1;";
"      continue;";
"    endif";
"    break;";
"  endwhile";
"  while (j1 >= i1)";
"    this:_suspend_if_necessary();";
"    if (lines1[j1][2] == `lines2[j2][2] ! E_RANGE')";
"      j1 = j1 - 1;";
"      j2 = j2 - 1;";
"      continue;";
"    endif";
"    break;";
"  endwhile";
"  res1 = lines1[i1..j1]:slice(1);";
"  res2 = lines2[i2..j2]:slice(1);";
"  if (res1 && res2)";
"    results = {@results, {\"r\", i1, i2, res1, res2}};";
"  elseif (res1)";
"    results = {@results, {\"-\", i1, i2, res1}};";
"  elseif (res2)";
"    results = {@results, {\"+\", i1, i2, res2}};";
"  endif";
"";
"  last = pos;";
"endfor";
"";
"return results;";
"";
"chunk_length:45";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:878B1D1E76A186DC5F3F522323593AEC88D154FF";
"-=-=-mxyzptlk-=-=-";
.
#74:5
{lines1, lines2} = args;
intern = [];
{lines1, intern} = this:_hash_lines(lines1, intern);
{lines2, intern} = this:_hash_lines(lines2, intern);
lcs = this:_find_lcs(this:_find_common_unique_lines(lines1, lines2, intern));
return this:_generate_diff(lines1, lines2, lcs);
return;
"{lines1, lines2} = args;";
"";
"intern = [];";
"{lines1, intern} = this:_hash_lines(lines1, intern);";
"{lines2, intern} = this:_hash_lines(lines2, intern);";
"";
"lcs = this:_find_lcs(this:_find_common_unique_lines(lines1, lines2, intern));";
"";
"return this:_generate_diff(lines1, lines2, lcs);";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:80A42BCA22606876E26013750C479B574B5A3CC5";
"-=-=-mxyzptlk-=-=-";
.
#78:0
{predicate} = args;
if (!predicate)
elseif (index("\"'", c = predicate[1]))
(n = match(predicate, ("[^\\]" + c) + " *")) || raise(E_INVARG, "Missing end-quote");
return {{STR, predicate[2..n[1]]:strsub({{"\\\\", "\\"}, {"\\\"", "\""}})}, predicate[n[2] + 1..$]};
elseif (((c == "#") && (r = match(predicate, "^%(#-?[0-9]+%) *"))) && ((length(predicate) == r[2]) || (predicate[r[2]] == " ")))
return {{OBJ, toobj(predicate[r[3][1][1]..r[3][1][2]])}, predicate[r[2] + 1..$]};
elseif (index("-+0123456789", c))
if ((r = match(predicate, "^%([-+]?[0-9]+%) *")) && ((length(predicate) == r[2]) || (predicate[r[2]] == " ")))
return {{INT, toint(predicate[r[3][1][1]..r[3][1][2]])}, predicate[r[2] + 1..$]};
elseif ((r = match(predicate, "^%([-+]?[0-9]+%.[0-9]+%) *")) && ((length(predicate) == r[2]) || (predicate[r[2]] == " ")))
return {{FLOAT, tofloat(predicate[r[3][1][1]..r[3][1][2]])}, predicate[r[2] + 1..$]};
endif
elseif ((r = match(predicate, "^%(%?%|%#%|[_a-z][_a-z0-9]*%) *")) && ((length(predicate) == r[2]) || (predicate[r[2]] == " ")))
return {{-1, predicate[r[3][1][1]..r[3][1][2]]}, predicate[r[2] + 1..$]};
endif
raise(E_INVARG, tostr("Unmatched literal or identifier:  ", predicate));
return;
"{predicate} = args;";
"";
"/* the predicate string must _not_ start with whitespace */";
"if (!predicate)";
"  ;";
"elseif (index(\"\\\"'\", (c = predicate[1])))";
"  (n = match(predicate, \"[^\\\\]\" + c + \" *\")) || raise(E_INVARG, \"Missing end-quote\");";
"  return {{STR, predicate[2..n[1]]:strsub({{\"\\\\\\\\\", \"\\\\\"}, {\"\\\\\\\"\", \"\\\"\"}})}, predicate[n[2] + 1..$]};";
"elseif (c == \"#\" && (r = match(predicate, \"^%(#-?[0-9]+%) *\")) && (length(predicate) == r[2] || predicate[r[2]] == \" \"))";
"  return {{OBJ, toobj(predicate[r[3][1][1]..r[3][1][2]])}, predicate[r[2] + 1..$]};";
"elseif (index(\"-+0123456789\", c))";
"  if ((r = match(predicate, \"^%([-+]?[0-9]+%) *\")) && (length(predicate) == r[2] || predicate[r[2]] == \" \"))";
"    return {{INT, toint(predicate[r[3][1][1]..r[3][1][2]])}, predicate[r[2] + 1..$]};";
"  elseif ((r = match(predicate, \"^%([-+]?[0-9]+%.[0-9]+%) *\")) && (length(predicate) == r[2] || predicate[r[2]] == \" \"))";
"    return {{FLOAT, tofloat(predicate[r[3][1][1]..r[3][1][2]])}, predicate[r[2] + 1..$]};";
"  endif";
"elseif ((r = match(predicate, \"^%(%?%|%#%|[_a-z][_a-z0-9]*%) *\")) && (length(predicate) == r[2] || predicate[r[2]] == \" \"))";
"  return {{-1, predicate[r[3][1][1]..r[3][1][2]]}, predicate[r[2] + 1..$]};";
"endif";
"";
"raise(E_INVARG, tostr(\"Unmatched literal or identifier:  \", predicate));";
"";
"chunk_length:21";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:DAEA6192C540D70B5A757640AF059D2ACBB228E9";
"-=-=-mxyzptlk-=-=-";
.
#78:1
{predicate} = args;
if (!predicate)
elseif ((r = match(predicate, "^%(>=?%|<=?%|=[=~]?%|!=%|includes%|in%|is%) *")) && ((length(predicate) == r[2]) || (predicate[r[2]] == " ")))
return {predicate[r[3][1][1]..r[3][1][2]], predicate[r[2] + 1..$]};
endif
raise(E_INVARG, tostr("Unmatched operator:  ", predicate));
return;
"{predicate} = args;";
"";
"/* the predicate string must _not_ start with whitespace */";
"if (!predicate)";
"  ;";
"elseif ((r = match(predicate, \"^%(>=?%|<=?%|=[=~]?%|!=%|includes%|in%|is%) *\")) && (length(predicate) == r[2] || predicate[r[2]] == \" \"))";
"  return {predicate[r[3][1][1]..r[3][1][2]], predicate[r[2] + 1..$]};";
"endif";
"";
"raise(E_INVARG, tostr(\"Unmatched operator:  \", predicate));";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:AC122D01FE3F4E7A7AFDC9FC85D8A569EDEE82A9";
"-=-=-mxyzptlk-=-=-";
.
#78:2
{predicate, @args} = args;
predicate = predicate:trim();
predicate || raise(E_INVARG, "Empty predicate");
{operand1, predicate} = this:_match_literal_or_identifier(predicate);
{operator, predicate} = this:_match_operator(predicate);
{operand2, predicate} = this:_match_literal_or_identifier(predicate);
predicate && raise(E_INVARG, "Trailing predicate");
if (operator == "is")
if ((operand2[1] < 0) && (operand2[2] == "true"))
operand2 = {INT, 1};
elseif ((operand2[1] < 0) && (operand2[2] == "false"))
operand2 = {INT, 0};
else
raise(E_INVARG, tostr("Invalid operand for `is': ", operand2[2]));
endif
endif
if (operand1[1] < 0)
if (operand1[2] == "?")
{arg, @args} = args;
operand1 = {typeof(arg), arg};
elseif (operand1[2] == "#")
operand1[2] = $ask.ID;
endif
endif
if (operand2[1] < 0)
if (operand2[2] == "?")
{arg, @args} = args;
operand2 = {typeof(arg), arg};
elseif (operand2[2] == "#")
operand2[2] = $ask.ID;
endif
endif
return {operand1, operator, operand2};
return;
"{predicate, @args} = args;";
"";
"predicate = predicate:trim();";
"";
"predicate || raise(E_INVARG, \"Empty predicate\");";
"";
"{operand1, predicate} = this:_match_literal_or_identifier(predicate);";
"{operator, predicate} = this:_match_operator(predicate);";
"{operand2, predicate} = this:_match_literal_or_identifier(predicate);";
"";
"predicate && raise(E_INVARG, \"Trailing predicate\");";
"";
"/* handle the special case \"is true\"/\"is false\" */";
"";
"if (operator == \"is\")";
"  if (operand2[1] < 0 && operand2[2] == \"true\")";
"    operand2 = {INT, 1};";
"  elseif (operand2[1] < 0 && operand2[2] == \"false\")";
"    operand2 = {INT, 0};";
"  else";
"    raise(E_INVARG, tostr(\"Invalid operand for `is': \", operand2[2]));";
"  endif";
"endif";
"";
"/* The first item in the operand list is either -1 or a type value";
" * (INT, FLOAT, STR, etc.).  If the first item is -1, the second item";
" * is either an identifier, \"?\" or \"#\".  \"?\" is replaced by the";
" * appropriate positional argument, just as if it were a literal.  \"#\"";
" * is replaced by the special object number identifier `$ask:id()'.";
" */";
"if (operand1[1] < 0)";
"  if (operand1[2] == \"?\")";
"    {arg, @args} = args;";
"    operand1 = {typeof(arg), arg};";
"  elseif (operand1[2] == \"#\")";
"    operand1[2] = $ask.ID;";
"  endif";
"endif";
"";
"if (operand2[1] < 0)";
"  if (operand2[2] == \"?\")";
"    {arg, @args} = args;";
"    operand2 = {typeof(arg), arg};";
"  elseif (operand2[2] == \"#\")";
"    operand2[2] = $ask.ID;";
"  endif";
"endif";
"";
"return {operand1, operator, operand2};";
"";
"chunk_length:49";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0A4130D05BB4D1C532E5FB363997D56CE669D96F";
"-=-=-mxyzptlk-=-=-";
.
#78:3
{from} = args;
instance = (this == $ask) ? create(this, 1) | this;
(instance.from == 0) || raise(E_INVARG, "Second from not allowed");
instance.from = from;
return instance;
return;
"{from} = args;";
"";
"instance = (this == $ask) ? create(this, 1) | this;";
"";
"instance.from == 0 || raise(E_INVARG, \"Second from not allowed\");";
"instance.from = from;";
"";
"return instance;";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:399743308123418C6E9DC37E80DA3D3391EAE8CD";
"-=-=-mxyzptlk-=-=-";
.
#78:4
attributes = args;
instance = (this == $ask) ? create(this, 1) | this;
select = ["select" -> attributes];
instance.operations = instance.operations ? {@instance.operations, select} | {select};
return instance;
return;
"attributes = args;";
"";
"instance = (this == $ask) ? create(this, 1) | this;";
"";
"select = [\"select\" -> attributes];";
"instance.operations = instance.operations ? {@instance.operations, select} | {select};";
"";
"return instance;";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:979DD4149551202740B6FE74ED36E489F86EB1FC";
"-=-=-mxyzptlk-=-=-";
.
#78:5
{predicate, @args} = args;
instance = (this == $ask) ? create(this, 1) | this;
where = ["where" -> $ask:_parse_predicate(predicate, @args)];
instance.operations = instance.operations ? {@instance.operations, where} | {where};
return instance;
return;
"{predicate, @args} = args;";
"";
"instance = (this == $ask) ? create(this, 1) | this;";
"";
"where = [\"where\" -> $ask:_parse_predicate(predicate, @args)];";
"instance.operations = instance.operations ? {@instance.operations, where} | {where};";
"";
"return instance;";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:F29FE8B2918492C1B96ACF93F62CA740549F59BC";
"-=-=-mxyzptlk-=-=-";
.
#78:6
(this == $ask) && raise(E_PERM, "Call not allowed on prototype");
res = this.query_utilities:query(this, -1);
return length(res);
return;
"(this == $ask) && raise(E_PERM, \"Call not allowed on prototype\");";
"res = this.query_utilities:query(this, -1);";
"return length(res);";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:104E61B99CA2451A2809603B1C64330E1957BA86";
"-=-=-mxyzptlk-=-=-";
.
#78:7
(this == $ask) && raise(E_PERM, "Call not allowed on prototype");
res = this.query_utilities:query(this, -1);
return res;
return;
"(this == $ask) && raise(E_PERM, \"Call not allowed on prototype\");";
"res = this.query_utilities:query(this, -1);";
"return res;";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:29DD8D06B8AD2994A9A481FB485402A2761DADCE";
"-=-=-mxyzptlk-=-=-";
.
#78:8
(this == $ask) && raise(E_PERM, "Call not allowed on prototype");
res = this.query_utilities:query(this, 1);
return res;
return;
"(this == $ask) && raise(E_PERM, \"Call not allowed on prototype\");";
"res = this.query_utilities:query(this, 1);";
"return res;";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:DBE1452404E71AD84A28F81BC5B7A781A7AC09A7";
"-=-=-mxyzptlk-=-=-";
.
#80:0
set_task_perms(caller_perms());
{prototype, instance, properties, ?loud = 0} = args;
properties = this:_before_validate(prototype, instance, properties);
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
for constraints, property in (`prototype.constraints ! E_PROPNF => []')
for constraint in (constraints)
if (LIST == typeof(constraint))
{constraint, ?options = []} = constraint;
else
options = [];
endif
if ("" == constraint)
elseif ("present" == constraint)
properties = $model.validates_presence_of:validate(prototype, instance, properties, property, options);
elseif ("unique" == constraint)
properties = $model.validates_uniqueness_of:validate(prototype, instance, properties, property, options);
elseif ("immutable" == constraint)
properties = $model.validates_immutability_of:validate(prototype, instance, properties, property, options);
elseif ("format" == constraint)
properties = $model.validates_format_of:validate(prototype, instance, properties, property, options);
endif
endfor
endfor
(loud && `properties[$model.errors] ! E_RANGE') && raise("-*-invalid-*-", "Validation failed", properties);
properties = this:_after_validate(prototype, instance, properties);
return properties;
return;
"set_task_perms(caller_perms());";
"";
"{prototype, instance, properties, ?loud = 0} = args;";
"";
"properties = this:_before_validate(prototype, instance, properties);";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"for constraints, property in (`prototype.constraints ! E_PROPNF => []')";
"  for constraint in (constraints)";
"    if (LIST == typeof(constraint))";
"      {constraint, ?options = []} = constraint;";
"    else";
"      options = [];";
"    endif";
"    if (\"\" == constraint)";
"      ;";
"    elseif (\"present\" == constraint)";
"      properties = $model.validates_presence_of:validate(prototype, instance, properties, property, options);";
"    elseif (\"unique\" == constraint)";
"      properties = $model.validates_uniqueness_of:validate(prototype, instance, properties, property, options);";
"    elseif (\"immutable\" == constraint)";
"      properties = $model.validates_immutability_of:validate(prototype, instance, properties, property, options);";
"    elseif (\"format\" == constraint)";
"      properties = $model.validates_format_of:validate(prototype, instance, properties, property, options);";
"    endif";
"  endfor";
"endfor";
"";
"loud && `properties[$model.errors] ! E_RANGE' && raise(\"-*-invalid-*-\", \"Validation failed\", properties);";
"";
"properties = this:_after_validate(prototype, instance, properties);";
"";
"return properties;";
"";
"chunk_length:35";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:996C4D4E8FE6299445840AC49953FAB4F54BE917";
"-=-=-mxyzptlk-=-=-";
.
#80:1
set_task_perms(caller_perms());
{prototype, properties, ?loud = 0} = args;
(typeof(properties) == MAP) || raise(E_INVARG, "properties must be a map");
if ((typeof(prototype) != OBJ) || (!valid(prototype)))
properties[$model.errors] = "invalid prototype";
return properties;
endif
instance = $nothing;
properties = this:validate(prototype, instance, properties, loud);
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
properties = this:_before_create(prototype, instance, properties);
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
try
instance = create(prototype);
properties[$model.id] = instance;
except (E_PERM)
properties[$model.errors] = "permission denied";
return properties;
except (E_QUOTA)
properties[$model.errors] = "quota exceeded";
return properties;
endtry
for value, property in (properties)
if (`property in prototype.accessible ! E_PROPNF')
temp = $shapes:write_value(instance, property, ["Value" -> ["value" -> value]]);
if (`error = temp["Error"]["diagnostic"] ! E_RANGE')
properties = properties:set_value_by_path({$model.errors, property}, error);
endif
properties[property] = temp["Value"]["value"];
endif
endfor
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
properties = this:_after_create(prototype, instance, properties);
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
return this:read(prototype, instance);
return;
"set_task_perms(caller_perms());";
"";
"{prototype, properties, ?loud = 0} = args;";
"";
"(typeof(properties) == MAP) || raise(E_INVARG, \"properties must be a map\");";
"";
"if (typeof(prototype) != OBJ || !valid(prototype))";
"  properties[$model.errors] = \"invalid prototype\";";
"  return properties;";
"endif";
"";
"instance = $nothing;";
"";
"properties = this:validate(prototype, instance, properties, loud);";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"properties = this:_before_create(prototype, instance, properties);";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"try";
"  instance = create(prototype);";
"  properties[$model.id] = instance;";
"except (E_PERM)";
"  properties[$model.errors] = \"permission denied\";";
"  return properties;";
"except (E_QUOTA)";
"  properties[$model.errors] = \"quota exceeded\";";
"  return properties;";
"endtry";
"";
"for value, property in (properties)";
"  if (`property in prototype.accessible ! E_PROPNF')";
"    temp = $shapes:write_value(instance, property, [\"Value\" -> [\"value\" -> value]]);";
"    if (`error = temp[\"Error\"][\"diagnostic\"] ! E_RANGE')";
"      properties = properties:set_value_by_path({$model.errors, property}, error);";
"    endif";
"    properties[property] = temp[\"Value\"][\"value\"];";
"  endif";
"endfor";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"properties = this:_after_create(prototype, instance, properties);";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"return this:read(prototype, instance);";
"";
"chunk_length:53";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9094A3498D54EE7FBAD3193E9D686292F3FDA546";
"-=-=-mxyzptlk-=-=-";
.
#80:2
set_task_perms(caller_perms());
{prototype, instance, properties, ?loud = 0} = args;
(typeof(properties) == MAP) || raise(E_INVARG, "properties must be a map");
if (((typeof(prototype) != OBJ) || (!valid(prototype))) || (!isa(instance, prototype)))
properties[$model.errors] = "invalid prototype";
return properties;
endif
properties = this:validate(prototype, instance, properties, loud);
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
properties = this:_before_update(prototype, instance, properties);
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
properties[$model.id] = instance;
for value, property in (properties)
if (`property in prototype.accessible ! E_PROPNF')
temp = $shapes:write_value(instance, property, ["Value" -> ["value" -> value]]);
if (`error = temp["Error"]["diagnostic"] ! E_RANGE')
properties = properties:set_value_by_path({$model.errors, property}, error);
endif
properties[property] = temp["Value"]["value"];
endif
endfor
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
properties = this:_after_update(prototype, instance, properties);
if (`properties[$model.errors] ! E_RANGE')
return properties;
endif
return this:read(prototype, instance);
return;
"set_task_perms(caller_perms());";
"";
"{prototype, instance, properties, ?loud = 0} = args;";
"";
"(typeof(properties) == MAP) || raise(E_INVARG, \"properties must be a map\");";
"";
"if (typeof(prototype) != OBJ || !valid(prototype) || !isa(instance, prototype))";
"  properties[$model.errors] = \"invalid prototype\";";
"  return properties;";
"endif";
"";
"properties = this:validate(prototype, instance, properties, loud);";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"properties = this:_before_update(prototype, instance, properties);";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"properties[$model.id] = instance;";
"";
"for value, property in (properties)";
"  if (`property in prototype.accessible ! E_PROPNF')";
"    temp = $shapes:write_value(instance, property, [\"Value\" -> [\"value\" -> value]]);";
"    if (`error = temp[\"Error\"][\"diagnostic\"] ! E_RANGE')";
"      properties = properties:set_value_by_path({$model.errors, property}, error);";
"    endif";
"    properties[property] = temp[\"Value\"][\"value\"];";
"  endif";
"endfor";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"properties = this:_after_update(prototype, instance, properties);";
"if (`properties[$model.errors] ! E_RANGE')";
"  return properties;";
"endif";
"";
"return this:read(prototype, instance);";
"";
"chunk_length:42";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C8EF776DD7FC71F04B9E9471BEF542BE23ECB42E";
"-=-=-mxyzptlk-=-=-";
.
#80:3
set_task_perms(caller_perms());
{prototype, instance} = args;
if (((typeof(prototype) != OBJ) || (!valid(prototype))) || (!isa(instance, prototype)))
return [$model.errors -> "invalid prototype"];
endif
properties = [];
properties[$model.id] = instance;
for property in (`prototype.accessible ! E_PROPNF => {}')
try
properties[property] = instance.(property);
except (E_PERM)
properties = properties:set_value_by_path({$model.errors, property}, "permission denied");
endtry
endfor
return properties;
return;
"set_task_perms(caller_perms());";
"";
"{prototype, instance} = args;";
"";
"if (typeof(prototype) != OBJ || !valid(prototype) || !isa(instance, prototype))";
"  return [$model.errors -> \"invalid prototype\"];";
"endif";
"";
"properties = [];";
"";
"properties[$model.id] = instance;";
"";
"for property in (`prototype.accessible ! E_PROPNF => {}')";
"  try";
"    properties[property] = instance.(property);";
"  except (E_PERM)";
"    properties = properties:set_value_by_path({$model.errors, property}, \"permission denied\");";
"  endtry";
"endfor";
"";
"return properties;";
"";
"chunk_length:21";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3DEBDE00FB50329462550C19FC51CD38CC9B1634";
"-=-=-mxyzptlk-=-=-";
.
#80:4
$private();
set_task_perms(caller_perms());
{prototype, instance, properties} = args;
if (r = match(verb, "^_%(before%|after%)_%(%validate%|create%|update%)$"))
callback = tostr(verb[r[3][1][1]..r[3][1][2]], "_", verb[r[3][2][1]..r[3][2][2]]);
if (respond_to(prototype, callback))
properties = prototype:(callback)(prototype, instance, properties);
(typeof(properties) == MAP) || raise(E_TYPE, "Invalid returned value", properties);
endif
endif
return properties;
return;
"$private();";
"";
"set_task_perms(caller_perms());";
"";
"{prototype, instance, properties} = args;";
"";
"if (r = match(verb, \"^_%(before%|after%)_%(%validate%|create%|update%)$\"))";
"  callback = tostr(verb[r[3][1][1]..r[3][1][2]], \"_\", verb[r[3][2][1]..r[3][2][2]]);";
"  if (respond_to(prototype, callback))";
"    properties = prototype:(callback)(prototype, instance, properties);";
"    typeof(properties) == MAP || raise(E_TYPE, \"Invalid returned value\", properties);";
"  endif";
"endif";
"";
"return properties;";
"";
"chunk_length:15";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2E339CD45EAA1B9296CA5424A2EBB4F7F5B16833";
"-=-=-mxyzptlk-=-=-";
.
#80:5
{prototype, @values} = args;
accessible = setadd(`prototype.accessible ! E_PROPNF => {}', $model.id);
if (verb == "find")
return $ask:from(prototype):select(@accessible);
elseif (r = match(verb, "^find_by_%([a-zA-Z0-9_]+%)$"))
name = r[4][r[3][1][1]..r[3][1][2]];
return $ask:from(prototype):select(@accessible):where(tostr(name, " = ?"), @values);
endif
raise(E_INVARG);
return;
"{prototype, @values} = args;";
"";
"accessible = setadd(`prototype.accessible ! E_PROPNF => {}', $model.id);";
"";
"if (verb == \"find\")";
"  return $ask:from(prototype):select(@accessible);";
"";
"elseif (r = match(verb, \"^find_by_%([a-zA-Z0-9_]+%)$\"))";
"  name = r[4][r[3][1][1]..r[3][1][2]];";
"  return $ask:from(prototype):select(@accessible):where(tostr(name, \" = ?\"), @values);";
"";
"endif";
"";
"raise(E_INVARG);";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:397C76FC5D8E9E8B0EC0BE361357B9E01171E880";
"-=-=-mxyzptlk-=-=-";
.
#82:0
set_task_perms(caller_perms());
return $model:(verb)(this, @args);
return;
"set_task_perms(caller_perms());";
"";
"/* Verbs `create()', `find()' and `find_by_*()' only require a valid";
" * prototype.  Use `this'.";
" */";
"";
"return $model:(verb)(this, @args);";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9B45952FF2F2F705E3135AB046B4F2DB06AF1C86";
"-=-=-mxyzptlk-=-=-";
.
#82:1
set_task_perms(caller_perms());
if (args && (typeof(args[1]) == OBJ))
return $model:(verb)(this, @args);
else
for parent in (parents(this))
if (isa(parent, $model.model_proto))
return $model:(verb)(parent, this, @args);
endif
endfor
endif
return;
"set_task_perms(caller_perms());";
"";
"/* Verbs `validate()', `update()' and `read()' require a valid";
" * prototype and a valid instance.  If neither are provided,";
" * the prototype is the first parent that is a model prototype";
" * and the instance is `this'.";
" */";
"";
"if (args && typeof(args[1]) == OBJ)";
"  return $model:(verb)(this, @args);";
"else";
"  for parent in (parents(this))";
"    if (isa(parent, $model.model_proto))";
"      return $model:(verb)(parent, this, @args);";
"    endif";
"  endfor";
"endif";
"";
"chunk_length:17";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B4E95A4D90B448D4686BF0A59C7B0EFA9FA2F2AA";
"-=-=-mxyzptlk-=-=-";
.
#83:0
{prototype, instance, properties, name, ?options = []} = args;
return properties;
return;
"{prototype, instance, properties, name, ?options = []} = args;";
"";
"return properties;";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:67FE5D7C3F0338E4E7C76CB2951354635A13F833";
"-=-=-mxyzptlk-=-=-";
.
#83:1
{properties, name, message} = args;
if (errors = properties:value_by_path({$model.errors, name}))
properties = properties:set_value_by_path({$model.errors, name}, (typeof(errors) == LIST) ? {@errors, message} | {errors, message});
else
properties = properties:set_value_by_path({$model.errors, name}, message);
endif
return properties;
return;
"{properties, name, message} = args;";
"";
"if (errors = properties:value_by_path({$model.errors, name}))";
"  properties = properties:set_value_by_path({$model.errors, name}, typeof(errors) == LIST ? {@errors, message} | {errors, message});";
"else";
"  properties = properties:set_value_by_path({$model.errors, name}, message);";
"endif";
"";
"return properties;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C12EC174BC809275A4A14E90F5178CEFD8303C3D";
"-=-=-mxyzptlk-=-=-";
.
#83:2
set_task_perms(caller_perms());
{h, k} = args;
if (typeof(h) == MAP)
present = (typeof(v = `h[k] ! E_RANGE') == STR) ? match(v, "[^ ]") | v;
else
present = (typeof(v = `h.(k) ! E_PROPNF') == STR) ? match(v, "[^ ]") | v;
endif
return ("is_present" == verb) ? !(!present) | (!present);
return;
"set_task_perms(caller_perms());";
"";
"{h, k} = args;";
"";
"if (typeof(h) == MAP)";
"  present = typeof(v = `h[k] ! E_RANGE') == STR ?";
"              match(v, \"[^ ]\") |";
"              v;";
"else";
"  present = typeof(v = `h.(k) ! E_PROPNF') == STR ?";
"              match(v, \"[^ ]\") |";
"              v;";
"endif";
"";
"return (\"is_present\" == verb) ? !!present | !present;";
"";
"chunk_length:15";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5D3B24A96E58FE63A1849C19C223D4F65011F313";
"-=-=-mxyzptlk-=-=-";
.
#84:0
set_task_perms(caller_perms());
{prototype, instance, properties, name, ?options = []} = args;
if (this:is_blank(properties, name) && (!(valid(instance) && this:is_present(instance, name))))
properties = this:add_error(properties, name, "can't be blank");
endif
return properties;
return;
"set_task_perms(caller_perms());";
"";
"{prototype, instance, properties, name, ?options = []} = args;";
"";
"if (this:is_blank(properties, name) && !(valid(instance) && this:is_present(instance, name)))";
"  properties = this:add_error(properties, name, \"can't be blank\");";
"endif";
"";
"return properties;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:B646EB67CE2967ABDF993394C5B736CBF6119220";
"-=-=-mxyzptlk-=-=-";
.
#85:0
set_task_perms(caller_perms());
{prototype, instance, properties, name, ?options = []} = args;
if ((`properties[name] ! E_RANGE' != E_RANGE) && (!(valid(instance) && (properties[name] == instance.(name)))))
if (valid($ask:from(prototype):where(name + " = ?", properties[name]):one()))
properties = this:add_error(properties, name, "is already taken");
endif
endif
return properties;
return;
"set_task_perms(caller_perms());";
"";
"{prototype, instance, properties, name, ?options = []} = args;";
"";
"if (`properties[name] ! E_RANGE' != E_RANGE && !(valid(instance) && properties[name] == instance.(name)))";
"  if (valid($ask:from(prototype):where(name + \" = ?\", properties[name]):one()))";
"    properties = this:add_error(properties, name, \"is already taken\");";
"  endif";
"endif";
"";
"return properties;";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:63D90B2847224BDDA7400772E0D7BC9D74207EA1";
"-=-=-mxyzptlk-=-=-";
.
#86:0
set_task_perms(caller_perms());
{prototype, instance, properties, name, ?options = []} = args;
if ((`properties[name] ! E_RANGE' != E_RANGE) && (valid(instance) && (properties[name] != instance.(name))))
properties = this:add_error(properties, name, "can't be changed");
endif
return properties;
return;
"set_task_perms(caller_perms());";
"";
"{prototype, instance, properties, name, ?options = []} = args;";
"";
"if (`properties[name] ! E_RANGE' != E_RANGE && (valid(instance) && properties[name] != instance.(name)))";
"  properties = this:add_error(properties, name, \"can't be changed\");";
"endif";
"";
"return properties;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:38D76B88B8BD9959CC3564E753DFC10D4D8C97EE";
"-=-=-mxyzptlk-=-=-";
.
#87:0
{prototype, instance, properties, name, ?options = []} = args;
pattern = `options["pattern"] ! E_RANGE => "^$"';
message = `options["message"] ! E_RANGE => "is not valid"';
if ((`properties[name] ! E_RANGE' != E_RANGE) && (!match(properties[name], pattern)))
properties = this:add_error(properties, name, message);
endif
return properties;
return;
"{prototype, instance, properties, name, ?options = []} = args;";
"";
"pattern = `options[\"pattern\"] ! E_RANGE => \"^$\"';";
"message = `options[\"message\"] ! E_RANGE => \"is not valid\"';";
"";
"if (`properties[name] ! E_RANGE' != E_RANGE && !match(properties[name], pattern))";
"  properties = this:add_error(properties, name, message);";
"endif";
"";
"return properties;";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:52898C132056483AE48A3E3D89923F6E938A81A6";
"-=-=-mxyzptlk-=-=-";
.
#88:0
set_task_perms(caller_perms());
{prototype, instance, properties, name, ?options = []} = args;
if (valid(instance))
if (!(`properties[name] ! E_RANGE' != E_RANGE))
return this:add_error(properties, name, "is required");
elseif (properties[name] != instance.(name))
return this:add_error(properties, name, "is invalid");
endif
else
if (`properties[name] ! E_RANGE' != E_RANGE)
return this:add_error(properties, name, "is invalid");
endif
endif
properties[name] = `properties[name] ! E_RANGE => 0' + 1;
return properties;
return;
"set_task_perms(caller_perms());";
"";
"{prototype, instance, properties, name, ?options = []} = args;";
"";
"if (valid(instance))";
"  if (!(`properties[name] ! E_RANGE' != E_RANGE))";
"    return this:add_error(properties, name, \"is required\");";
"  elseif (properties[name] != instance.(name))";
"    return this:add_error(properties, name, \"is invalid\");";
"  endif";
"else";
"  if (`properties[name] ! E_RANGE' != E_RANGE)";
"    return this:add_error(properties, name, \"is invalid\");";
"  endif";
"endif";
"";
"properties[name] = `properties[name] ! E_RANGE => 0' + 1;";
"";
"return properties;";
"";
"chunk_length:19";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:00949BFF81FF829D374CB54CF26FAF20FC2A09FA";
"-=-=-mxyzptlk-=-=-";
.
#91:0
$restrict_to_caller($system, "server_started");
try
file_stat(".");
`file_mkdir("private") || server_log(tostr(file_version(), ": created \"files/private\"")) ! E_FILE';
`file_mkdir("private/app") || server_log(tostr(file_version(), ": created \"files/private/app\"")) ! E_FILE';
`file_mkdir("public") || server_log(tostr(file_version(), ": created \"files/public\"")) ! E_FILE';
`file_mkdir("public/app") || server_log(tostr(file_version(), ": created \"files/public/app\"")) ! E_FILE';
`file_mkdir("public/css") || server_log(tostr(file_version(), ": created \"files/public/css\"")) ! E_FILE';
`file_mkdir("public/img") || server_log(tostr(file_version(), ": created \"files/public/img\"")) ! E_FILE';
`file_mkdir("public/js") || server_log(tostr(file_version(), ": created \"files/public/js\"")) ! E_FILE';
`file_mkdir("tmp") || server_log(tostr(file_version(), ": created \"files/tmp\"")) ! E_FILE';
except (ANY)
server_log(tostr(file_version(), ": missing \"files\" directory"));
endtry
return;
"$restrict_to_caller($system, \"server_started\");";
"try";
"  file_stat(\".\");";
"  `file_mkdir(\"private\") || server_log(tostr(file_version(), \": created \\\"files/private\\\"\")) ! E_FILE';";
"  `file_mkdir(\"private/app\") || server_log(tostr(file_version(), \": created \\\"files/private/app\\\"\")) ! E_FILE';";
"  `file_mkdir(\"public\") || server_log(tostr(file_version(), \": created \\\"files/public\\\"\")) ! E_FILE';";
"  `file_mkdir(\"public/app\") || server_log(tostr(file_version(), \": created \\\"files/public/app\\\"\")) ! E_FILE';";
"  `file_mkdir(\"public/css\") || server_log(tostr(file_version(), \": created \\\"files/public/css\\\"\")) ! E_FILE';";
"  `file_mkdir(\"public/img\") || server_log(tostr(file_version(), \": created \\\"files/public/img\\\"\")) ! E_FILE';";
"  `file_mkdir(\"public/js\") || server_log(tostr(file_version(), \": created \\\"files/public/js\\\"\")) ! E_FILE';";
"  `file_mkdir(\"tmp\") || server_log(tostr(file_version(), \": created \\\"files/tmp\\\"\")) ! E_FILE';";
"except (ANY)";
"  server_log(tostr(file_version(), \": missing \\\"files\\\" directory\"));";
"endtry";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:494FB4EEE91B453CA651336A969FA2E47144B1ED";
"-=-=-mxyzptlk-=-=-";
.
#92:0
$permit("wizard", "owner");
{?full = 1} = args;
if (full)
return mapvalues(this.attachments);
else
return mapkeys(this.attachments);
endif
return;
"$permit(\"wizard\", \"owner\");";
"";
"{?full = 1} = args;";
"";
"if (full)";
"  return mapvalues(this.attachments);";
"else";
"  return mapkeys(this.attachments);";
"endif";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4B94E55E2C7EDCD795795DEA27557075D64CDF49";
"-=-=-mxyzptlk-=-=-";
.
#92:1
$permit("wizard", "owner");
{attachment, ?option = 0} = args;
if (!option)
return this.attachments[attachment];
elseif (`value = this.attachments[attachment][option] ! E_RANGE')
return value;
elseif (option == "data")
fh = -1;
data = "";
path = this.attachments[attachment]["path"];
size = this.attachments[attachment]["size"];
try
fh = file_open(path, "r-bn");
while ((pos = file_tell(fh)) != size)
chunk = file_read(fh, size - pos);
data = data ? data + chunk | chunk;
endwhile
finally
(fh > -1) && file_close(fh);
endtry
return data;
else
raise(E_INVARG);
endif
return;
"$permit(\"wizard\", \"owner\");";
"";
"{attachment, ?option = 0} = args;";
"";
"if (!option)";
"  return this.attachments[attachment];";
"elseif (`value = this.attachments[attachment][option] ! E_RANGE')";
"  return value;";
"elseif (option == \"data\")";
"  fh = -1;";
"  data = \"\";";
"  path = this.attachments[attachment][\"path\"];";
"  size = this.attachments[attachment][\"size\"];";
"  try";
"    fh = file_open(path, \"r-bn\");";
"    while ((pos = file_tell(fh)) != size)";
"      chunk = file_read(fh, size - pos);";
"      data = data ? data + chunk | chunk;";
"    endwhile";
"  finally";
"    (fh > -1) && file_close(fh);";
"  endtry";
"  return data;";
"else";
"  raise(E_INVARG);";
"endif";
"";
"chunk_length:26";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:09868DF21A3E53C9FD1CE92F4F523BA1F8857827";
"-=-=-mxyzptlk-=-=-";
.
#92:2
$permit("wizard", "owner");
{attachment} = args;
`this.attachments[attachment] ! E_RANGE => raise(E_INVARG, tostr("No such attachment: ", attachment), attachment)';
`file_stat(filename = this.attachments[attachment]["path"]) ! E_RANGE, E_FILE => raise(E_INVARG, tostr("No such attached file: ", filename), filename)';
return 1;
return;
"$permit(\"wizard\", \"owner\");";
"";
"{attachment} = args;";
"";
"/* Raises E_INVARG if the attachment is not an attachment; raises";
" * E_FILE if the associated file does not exist.";
" */";
"`this.attachments[attachment] ! E_RANGE => raise(E_INVARG, tostr(\"No such attachment: \", attachment), attachment)';";
"`file_stat(filename = this.attachments[attachment][\"path\"]) ! E_RANGE, E_FILE => raise(E_INVARG, tostr(\"No such attached file: \", filename), filename)';";
"";
"return 1;";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6E03C948540B6FB85C955A0034BC4B4C6152EFD7";
"-=-=-mxyzptlk-=-=-";
.
#92:3
$restrict_to_builtin("recycle");
args && raise(E_ARGS);
for attachment in (this.attachments)
`file_remove(attachment["path"]) ! E_RANGE, E_FILE';
endfor
return;
"$restrict_to_builtin(\"recycle\");";
"";
"args && raise(E_ARGS);";
"";
"for attachment in (this.attachments)";
"  `file_remove(attachment[\"path\"]) ! E_RANGE, E_FILE'; /* if the file is missing, move on... */";
"endfor";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:11679240172E789BD6A0031B98447E9A887C2E2F";
"-=-=-mxyzptlk-=-=-";
.
#92:4
$private();
{name, pool, ?mkdir = 1} = args;
name || raise(E_INVARG, name);
`this.attachment_pools[pool] ! E_RANGE' || raise(E_INVARG, pool);
path = string_hash(tostr(this, name, pool), "md5");
path[3] = "/";
path[6] = "/";
path[9] = "/";
if (mkdir)
parts = {path[1..2], path[1..5], path[1..8]};
for part in (parts)
`file_mkdir(tostr(this.attachment_pools[pool], "/", part)) ! E_FILE';
endfor
endif
return path;
return;
"$private();";
"";
"{name, pool, ?mkdir = 1} = args;";
"";
"name || raise(E_INVARG, name);";
"`this.attachment_pools[pool] ! E_RANGE' || raise(E_INVARG, pool);";
"";
"path = string_hash(tostr(this, name, pool), \"md5\");";
"path[3] = \"/\";";
"path[6] = \"/\";";
"path[9] = \"/\";";
"";
"if (mkdir)";
"  parts = {path[1..2], path[1..5], path[1..8]};";
"  for part in (parts)";
"    `file_mkdir(tostr(this.attachment_pools[pool], \"/\", part)) ! E_FILE';";
"  endfor";
"endif";
"";
"return path;";
"";
"chunk_length:20";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5011167A064F72953458E0B2BC00F33F0591576A";
"-=-=-mxyzptlk-=-=-";
.
#92:5
$permit("wizard", "owner");
{data, attachment, pool, type, ?processors = []} = args;
this:_check_limit();
(typeof(data) == STR) || raise(E_TYPE);
`this.attachments[attachment] ! E_RANGE' && raise(E_INVARG, tostr("Already an attachment: ", attachment), attachment);
`this.attachment_pools[pool] ! E_RANGE' || raise(E_INVARG, tostr("Invalid pool: ", pool), pool);
path = tostr(this.attachment_pools[pool], "/", this:_path_for(attachment, pool));
fh = -1;
try
fh = file_open(path, "w-bn");
file_write(fh, data);
finally
(fh > -1) && file_close(fh);
endtry
size = file_size(path);
this.attachments[attachment] = {attachment, path, pool, type};
this.attachments[attachment] = ["name" -> attachment, "path" -> path, "size" -> size, "type" -> type, "pool" -> pool];
for _, process in (processors)
if ("thumbnail" == process)
sizes = processors["thumbnail"];
sizes = (typeof(sizes) == STR) ? {sizes} | sizes;
this:_thumbnail(attachment, path, pool, type, sizes);
else
raise(E_INVARG, process);
endif
endfor
return this;
return;
"$permit(\"wizard\", \"owner\");";
"";
"{data, attachment, pool, type, ?processors = []} = args;";
"";
"this:_check_limit();";
"";
"typeof(data) == STR || raise(E_TYPE);";
"`this.attachments[attachment] ! E_RANGE' && raise(E_INVARG, tostr(\"Already an attachment: \", attachment), attachment);";
"`this.attachment_pools[pool] ! E_RANGE' || raise(E_INVARG, tostr(\"Invalid pool: \", pool), pool);";
"";
"path = tostr(this.attachment_pools[pool], \"/\", this:_path_for(attachment, pool));";
"";
"fh = -1;";
"try";
"  fh = file_open(path, \"w-bn\");";
"  file_write(fh, data);";
"finally";
"  (fh > -1) && file_close(fh);";
"endtry";
"";
"size = file_size(path);";
"";
"this.attachments[attachment] = {attachment, path, pool, type};";
"this.attachments[attachment] = [\"name\" -> attachment, \"path\" -> path, \"size\" -> size, \"type\" -> type, \"pool\" -> pool];";
"";
"for _, process in (processors)";
"  if (\"thumbnail\" == process)";
"    sizes = processors[\"thumbnail\"];";
"    sizes = typeof(sizes) == STR ? {sizes} | sizes;";
"    this:_thumbnail(attachment, path, pool, type, sizes);";
"  else";
"    raise(E_INVARG, process);";
"  endif";
"endfor";
"";
"return this;";
"";
"chunk_length:36";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:43B5B4F10D7EC1F96065734938CB29BF72D8D077";
"-=-=-mxyzptlk-=-=-";
.
#92:6
$permit("wizard", "owner");
{filename, attachment, pool, type, ?processors = []} = args;
this:_check_limit();
(typeof(filename) == STR) || raise(E_TYPE);
`this.attachments[attachment] ! E_RANGE' && raise(E_INVARG, tostr("Already an attachment: ", attachment), attachment);
`this.attachment_pools[pool] ! E_RANGE' || raise(E_INVARG, tostr("Invalid pool: ", pool), pool);
match(filename, "^/?tmp/.") || raise(E_INVARG, tostr("Must be a temporary file: ", filename), filename);
(file_type(filename) == "reg") || raise(E_INVARG, tostr("Must be a regular file: ", filename), filename);
for path in ({filename, attachment})
index(path, "./") && raise(E_INVARG, path);
index(path, "..") && raise(E_INVARG, path);
endfor
old_path = filename;
new_path = tostr(this.attachment_pools[pool], "/", this:_path_for(attachment, pool));
file_rename(old_path, new_path);
size = file_size(new_path);
this.attachments[attachment] = {attachment, new_path, pool, type};
this.attachments[attachment] = ["name" -> attachment, "path" -> new_path, "size" -> size, "type" -> type, "pool" -> pool];
for _, process in (processors)
if ("thumbnail" == process)
sizes = processors["thumbnail"];
sizes = (typeof(sizes) == STR) ? {sizes} | sizes;
this:_thumbnail(attachment, new_path, pool, type, sizes);
else
raise(E_INVARG, process);
endif
endfor
return this;
return;
"$permit(\"wizard\", \"owner\");";
"";
"{filename, attachment, pool, type, ?processors = []} = args;";
"";
"this:_check_limit();";
"";
"typeof(filename) == STR || raise(E_TYPE);";
"`this.attachments[attachment] ! E_RANGE' && raise(E_INVARG, tostr(\"Already an attachment: \", attachment), attachment);";
"`this.attachment_pools[pool] ! E_RANGE' || raise(E_INVARG, tostr(\"Invalid pool: \", pool), pool);";
"";
"(match(filename, \"^/?tmp/.\")) || raise(E_INVARG, tostr(\"Must be a temporary file: \", filename), filename);";
"(file_type(filename) == \"reg\") || raise(E_INVARG, tostr(\"Must be a regular file: \", filename), filename);";
"";
"for path in ({filename, attachment})";
"  index(path, \"./\") && raise(E_INVARG, path);";
"  index(path, \"..\") && raise(E_INVARG, path);";
"endfor";
"";
"old_path = filename;";
"new_path = tostr(this.attachment_pools[pool], \"/\", this:_path_for(attachment, pool));";
"file_rename(old_path, new_path);";
"";
"size = file_size(new_path);";
"";
"this.attachments[attachment] = {attachment, new_path, pool, type};";
"this.attachments[attachment] = [\"name\" -> attachment, \"path\" -> new_path, \"size\" -> size, \"type\" -> type, \"pool\" -> pool];";
"";
"for _, process in (processors)";
"  if (\"thumbnail\" == process)";
"    sizes = processors[\"thumbnail\"];";
"    sizes = typeof(sizes) == STR ? {sizes} | sizes;";
"    this:_thumbnail(attachment, new_path, pool, type, sizes);";
"  else";
"    raise(E_INVARG, process);";
"  endif";
"endfor";
"";
"return this;";
"";
"chunk_length:38";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E8D005C377A1CF4345A68C85CEAEBEC971958B9D";
"-=-=-mxyzptlk-=-=-";
.
#92:7
$permit("wizard", "owner");
{attachment} = args;
`this.attachments[attachment] ! E_RANGE' || raise(E_INVARG, tostr("No such attachment: ", attachment), attachment);
`file_remove(this.attachments[attachment]["path"]) ! E_RANGE, E_FILE';
this.attachments = mapdelete(this.attachments, attachment);
return this;
return;
"$permit(\"wizard\", \"owner\");";
"";
"{attachment} = args;";
"";
"`this.attachments[attachment] ! E_RANGE' || raise(E_INVARG, tostr(\"No such attachment: \", attachment), attachment);";
"";
"`file_remove(this.attachments[attachment][\"path\"]) ! E_RANGE, E_FILE';";
"";
"this.attachments = mapdelete(this.attachments, attachment);";
"";
"return this;";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2A1E791398FFB08044F57E069C493272A8E0377E";
"-=-=-mxyzptlk-=-=-";
.
#92:8
$private();
{path} = args;
try
{code, out, ERR} = exec({"identify", "-format", "%m", path});
except (E_INVARG, E_FILE)
return 0;
endtry
code && raise(E_INVARG, tostr("Can't identify: ", decode_binary(ERR)[1]));
return decode_binary(out)[1];
return;
"$private();";
"";
"{path} = args;";
"";
"try";
"  {code, out, err} = exec({\"identify\", \"-format\", \"%m\", path});";
"except (E_INVARG, E_FILE)";
"  return 0;";
"endtry";
"";
"code && raise(E_INVARG, tostr(\"Can't identify: \", decode_binary(err)[1]));";
"";
"return decode_binary(out)[1];";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:CBC9E169942E62FE158B7341C7A667DB5A5CE85F";
"-=-=-mxyzptlk-=-=-";
.
#92:9
$private();
{attachment, path, pool, type, sizes} = args;
if (!this:_identify(tostr("files/", path)))
return;
endif
for size in (sizes)
this:_check_limit();
match(size, "^%([1-9][0-9][0-9]?%)x%([1-9][0-9][0-9]?%)$") || raise(E_INVARG, size);
attachment = size + ".png";
thumbnail = tostr(this.attachment_pools[pool], "/", this:_path_for(attachment, pool));
exec({"convert", tostr("files/", path), "-thumbnail", size, "-bordercolor", "white", "-border", "60", "-gravity", "center", "-crop", size + "+0+0", "+repage", tostr("files/", thumbnail)});
this.attachments[size + ".png"] = {size + ".png", thumbnail, pool, "image/png"};
this.attachments[attachment] = ["name" -> attachment, "path" -> thumbnail, "size" -> file_size(thumbnail), "type" -> "image/png", "pool" -> pool];
endfor
return;
"$private();";
"";
"{attachment, path, pool, type, sizes} = args;";
"";
"/* raise an error if we can't identify the file type */";
"/* but don't raise an error if we can't identify at all */";
"if (!this:_identify(tostr(\"files/\", path)))";
"  return;";
"endif";
"";
"for size in (sizes)";
"  this:_check_limit();";
"  match(size, \"^%([1-9][0-9][0-9]?%)x%([1-9][0-9][0-9]?%)$\") || raise(E_INVARG, size);";
"  attachment = size + \".png\";";
"  thumbnail = tostr(this.attachment_pools[pool], \"/\", this:_path_for(attachment, pool));";
"  exec({\"convert\", tostr(\"files/\", path), \"-thumbnail\", size, \"-bordercolor\", \"white\", \"-border\", \"60\", \"-gravity\", \"center\", \"-crop\", size + \"+0+0\", \"+repage\", tostr(\"files/\", thumbnail)});";
"  this.attachments[size + \".png\"] = {size + \".png\", thumbnail, pool, \"image/png\"};";
"  this.attachments[attachment] = [\"name\" -> attachment, \"path\" -> thumbnail, \"size\" -> file_size(thumbnail), \"type\" -> \"image/png\", \"pool\" -> pool];";
"endfor";
"";
"chunk_length:19";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:92B08D48B59BD0224852AC07FB4E283C90FE84E9";
"-=-=-mxyzptlk-=-=-";
.
#92:10
$private();
(length(this.attachments) < this.attachment_limit) || raise(E_QUOTA);
return;
"$private();";
"";
"(length(this.attachments) < this.attachment_limit) || raise(E_QUOTA);";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:2605769F71081BDE86193A8F286D9AD2D2F1270A";
"-=-=-mxyzptlk-=-=-";
.
#93:0
$restrict_to_caller($composed);
return;
"$restrict_to_caller($composed);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:43EC437995D2B286E71AB2D966AB5FA752BDC714";
"-=-=-mxyzptlk-=-=-";
.
#93:1
$restrict_to_caller($composed);
return;
"$restrict_to_caller($composed);";
"";
"chunk_length:1";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:43EC437995D2B286E71AB2D966AB5FA752BDC714";
"-=-=-mxyzptlk-=-=-";
.
#96:0
{h, ?p = ""} = args;
q = "";
for vl, k in (h)
for v in ((typeof(vl) == LIST) ? vl | {vl})
q = q ? q + "&" | q;
if (typeof(v) == MAP)
q = tostr(q, this:generate_query_string(v, ((p + "[") + k) + "]"));
else
q = tostr(q, p, k, "=", v);
endif
endfor
endfor
return q;
return;
"{h, ?p = \"\"} = args;";
"q = \"\";";
"for vl, k in (h)";
"  for v in (typeof(vl) == LIST ? vl | {vl})";
"    q = q ? q + \"&\" | q;";
"    if (typeof(v) == MAP)";
"      q = tostr(q, this:generate_query_string(v, p + \"[\" + k + \"]\"));";
"    else";
"      q = tostr(q, p, k, \"=\", v);";
"    endif";
"  endfor";
"endfor";
"return q;";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:32835C46F41640AEE7452E0D62262B8F0FCB33D7";
"-=-=-mxyzptlk-=-=-";
.
#96:1
{s, ?c = 0} = args;
if (!s)
return [];
endif
h = [];
l = {};
s = s + "&";
while (s)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (c >= 1000)
raise("-*-parameters-is-too-long-*-");
endif
c = c + 1;
i = index(s, "&");
l = {@l, s[1..i - 1]};
s[1..i] = "";
endwhile
for p in (l)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
i = index(p, "=");
f = i ? p[1..i - 1] | p;
v = i ? p[i + 1..$] | "";
if (`h[f] ! E_RANGE' != E_RANGE)
h[f] = (typeof(h[f]) == LIST) ? {@h[f], v} | {h[f], v};
else
h[f] = v;
endif
endfor
return h;
return;
"{s, ?c = 0} = args;";
"/* Limit query strings to 1000 items to prevent DOS attacks.";
" * Start at `c', the count of parameters so far.";
" * See http://permalink.gmane.org/gmane.comp.security.full-disclosure/83694";
" *     http://www.ocert.org/advisories/ocert-2011-003.html";
" */";
"if (!s)";
"  return [];";
"endif";
"h = [];";
"l = {};";
"s = s + \"&\";";
"while (s)";
"  ticks_left() < 10000 || seconds_left() < 2 && suspend(0);";
"  if (c >= 1000)";
"    raise(\"-*-parameters-is-too-long-*-\");";
"  endif";
"  c = c + 1;";
"  i = index(s, \"&\");";
"  l = {@l, s[1..i - 1]};";
"  s[1..i] = \"\";";
"endwhile";
"for p in (l)";
"  ticks_left() < 10000 || seconds_left() < 2 && suspend(0);";
"  i = index(p, \"=\");";
"  f = i ? p[1..i - 1] | p;";
"  v = i ? p[i + 1..$] | \"\";";
"  if (`h[f] ! E_RANGE' != E_RANGE)";
"    h[f] = (typeof(h[f]) == LIST) ? {@h[f], v} | {h[f], v};";
"  else";
"    h[f] = v;";
"  endif";
"endfor";
"return h;";
"";
"chunk_length:34";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3752CD009AA2FD5ED7AD88DDCE84E582C84DB28E";
"-=-=-mxyzptlk-=-=-";
.
#96:2
{uri} = args;
new = "";
while (uri)
if (r = match(uri, "[][!*'();:@&=+$,?#/ ]"))
i = uri[r[1]..r[2]] in this.reserved;
new = (new + uri[1..r[1] - 1]) + this.escaped[i];
uri[1..r[2]] = "";
else
new = tostr(new, uri);
uri = "";
endif
endwhile
return new;
return;
"{uri} = args;";
"";
"new = \"\";";
"";
"while (uri)";
"  if (r = match(uri, \"[][!*'();:@&=+$,?#/ ]\"))";
"    i = uri[r[1]..r[2]] in this.reserved;";
"    new = new + uri[1..r[1] - 1] + this.escaped[i];";
"    uri[1..r[2]] = \"\";";
"  else";
"    new = tostr(new, uri);";
"    uri = \"\";";
"  endif";
"endwhile";
"";
"return new;";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:637EBD4E0AA597C2DC5B1F30E38C514D3F94581E";
"-=-=-mxyzptlk-=-=-";
.
#96:3
{uri} = args;
new = "";
while (uri)
if (r = match(uri, "%%[a-fA-F0-9][a-fA-F0-9]%|%+"))
chr = (uri[r[1]] != "+") ? "~" + uri[r[1] + 1..r[2]] | "~20";
new = (new + uri[1..r[1] - 1]) + ((typeof(c = decode_binary(chr)[1]) == INT) ? chr | c);
uri[1..r[2]] = "";
else
new = tostr(new, uri);
uri = "";
endif
endwhile
return new;
return;
"{uri} = args;";
"";
"new = \"\";";
"";
"while (uri)";
"  if (r = match(uri, \"%%[a-fA-F0-9][a-fA-F0-9]%|%+\"))";
"    chr = uri[r[1]] != \"+\" ? \"~\" + uri[r[1] + 1..r[2]] | \"~20\";";
"    new = new + uri[1..r[1] - 1] + (typeof(c = decode_binary(chr)[1]) == INT ? chr | c);";
"    uri[1..r[2]] = \"\";";
"  else";
"    new = tostr(new, uri);";
"    uri = \"\";";
"  endif";
"endwhile";
"";
"return new;";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:AD204C72D983E85A556094E75B2A8AF3B8E702FA";
"-=-=-mxyzptlk-=-=-";
.
#97:0
$private();
server_log(tostr(@args));
return;
"$private();";
"";
"server_log(tostr(@args));";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:650D9D9FCADD450749A1A67E616832EAFF78DC8D";
"-=-=-mxyzptlk-=-=-";
.
#97:1
$private();
bytes = {};
for i in [1..128 / 3]
n = random((256 * 256) * 256);
while (n)
bytes = {n % 256, @bytes};
n = n / 256;
endwhile
endfor
return encode_binary(bytes);
return;
"$private();";
"";
"bytes = {};";
"for i in [1..128 / 3]";
"  n = random(256 * 256 * 256);";
"  while (n)";
"    bytes = {n % 256, @bytes};";
"    n = n / 256;";
"  endwhile";
"endfor";
"";
"return encode_binary(bytes);";
"";
"chunk_length:12";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:BE0F8436461794647C35BFCB578C81BDC32E0C55";
"-=-=-mxyzptlk-=-=-";
.
#97:2
$permit("owner", "wizard");
`{port} = args ! E_ARGS => raise(E_ARGS, "Incorrect number of arguments:  port")';
this.key = this:_key();
listen(this, port, 0);
this.port = port;
return;
"$permit(\"owner\", \"wizard\");";
"";
"`{port} = args ! E_ARGS => raise(E_ARGS, \"Incorrect number of arguments:  port\")';";
"";
"this.key = this:_key();";
"";
"listen(this, port, 0);";
"";
"this.port = port;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:7F76AD640411783E10EA4C1E47BEFF625870BD6F";
"-=-=-mxyzptlk-=-=-";
.
#97:3
$permit("owner", "wizard");
args && raise(E_ARGS);
port = 0;
for listener in (listeners())
if (listener[1] == this)
port = listener[2];
break;
endif
endfor
(!port) && raise(E_INVARG, "Server not running");
unlisten(port);
this.key = 0;
return;
"$permit(\"owner\", \"wizard\");";
"";
"args && raise(E_ARGS);";
"";
"port = 0;";
"";
"for listener in (listeners())";
"  if (listener[1] == this)";
"    port = listener[2];";
"    break;";
"  endif";
"endfor";
"";
"!port && raise(E_INVARG, \"Server not running\");";
"";
"unlisten(port);";
"";
"this.key = 0;";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3BDA0CFA5F590ECE040EEEA832C47E8AFDE9836E";
"-=-=-mxyzptlk-=-=-";
.
#97:4
$private();
return read_http("request", @args);
return;
"$private();";
"";
"/* provides a place to redefine network behavior in a child */";
"return read_http(\"request\", @args);";
"";
"chunk_length:4";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:00D751116B2CEA7C7EF4819AF89A1BA8E462315E";
"-=-=-mxyzptlk-=-=-";
.
#97:5
$private();
return notify(@args);
return;
"$private();";
"";
"/* provides a place to redefine network behavior in a child */";
"return notify(@args);";
"";
"chunk_length:4";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:EA8C0826FC0A7CFF737A580317BDF00143C24910";
"-=-=-mxyzptlk-=-=-";
.
#97:6
$private();
if (verb == "_session_cookie_name")
return this.session_cookie_name;
elseif (verb == "_flash_socket_policy")
return this.flash_socket_policy;
endif
return;
"$private();";
"";
"/* centralizes wiz-perm code for access to `c' properties on children */";
"if (verb == \"_session_cookie_name\")";
"  return this.session_cookie_name;";
"elseif (verb == \"_flash_socket_policy\")";
"  return this.flash_socket_policy;";
"endif";
"";
"chunk_length:8";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:41E5EEE5DB4FEB501050CBE720AC9ED755B7C38C";
"-=-=-mxyzptlk-=-=-";
.
#97:7
$private();
{connection} = args;
return this:_read_http(connection);
return;
"$private();";
"";
"{connection} = args;";
"";
"return this:_read_http(connection);";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6C14F1268410277776C8D9DCF817CD425371F333";
"-=-=-mxyzptlk-=-=-";
.
#97:8
$private();
{connection, response} = args;
status_codes = this.status_codes;
status = `response["status"] ! E_RANGE => 0';
`status_codes[status] ! E_RANGE' || raise(E_INVARG, tostr("Status code must be one of:  ", status_codes:keys():join(", ")));
if (`body = response["body"] ! E_RANGE' != E_RANGE)
content_type = response["headers"]["content-type"];
content_length = response["headers"]["content-length"];
this:_notify(connection, tostr("HTTP/1.1 ", status, " ", status_codes[status], "~0D~0A"));
this:_notify(connection, tostr("Content-Type: ", content_type, "~0D~0A"));
this:_notify(connection, tostr("Content-Length: ", content_length, "~0D~0A"));
for value, field in (`response["headers"] ! E_RANGE => []')
if (!(field in {"Content-Type", "Content-Length"}))
this:_notify(connection, tostr(field, ": ", value, "~0D~0A"));
endif
endfor
this:_notify(connection, "~0D~0A");
this:_notify(connection, body);
else
this:_notify(connection, tostr("HTTP/1.1 ", status, " ", status_codes[status], "~0D~0A"));
this:_notify(connection, tostr("Content-Length: ", 0, "~0D~0A"));
for value, field in (`response["headers"] ! E_RANGE => []')
this:_notify(connection, tostr(field, ": ", value, "~0D~0A"));
endfor
this:_notify(connection, "~0D~0A");
endif
return;
"$private();";
"";
"{connection, response} = args;";
"";
"status_codes = this.status_codes;";
"status = `response[\"status\"] ! E_RANGE => 0';";
"`status_codes[status] ! E_RANGE' || raise(E_INVARG, tostr(\"Status code must be one of:  \", status_codes:keys():join(\", \")));";
"";
"if (`body = response[\"body\"] ! E_RANGE' != E_RANGE)";
"  content_type = response[\"headers\"][\"content-type\"];";
"  content_length = response[\"headers\"][\"content-length\"];";
"";
"  this:_notify(connection, tostr(\"HTTP/1.1 \", status, \" \", status_codes[status], \"~0D~0A\"));";
"  this:_notify(connection, tostr(\"Content-Type: \", content_type, \"~0D~0A\"));";
"  this:_notify(connection, tostr(\"Content-Length: \", content_length, \"~0D~0A\"));";
"  for value, field in (`response[\"headers\"] ! E_RANGE => []')";
"    if (!(field in {\"Content-Type\", \"Content-Length\"}))";
"      this:_notify(connection, tostr(field, \": \", value, \"~0D~0A\"));";
"    endif";
"  endfor";
"  this:_notify(connection, \"~0D~0A\");";
"  this:_notify(connection, body);";
"";
"else";
"  this:_notify(connection, tostr(\"HTTP/1.1 \", status, \" \", status_codes[status], \"~0D~0A\"));";
"  this:_notify(connection, tostr(\"Content-Length: \", 0, \"~0D~0A\"));";
"  for value, field in (`response[\"headers\"] ! E_RANGE => []')";
"    this:_notify(connection, tostr(field, \": \", value, \"~0D~0A\"));";
"  endfor";
"  this:_notify(connection, \"~0D~0A\");";
"";
"endif";
"";
"chunk_length:32";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:DB748D8D8C5AC6023EEF06939CDE38ABF5472F90";
"-=-=-mxyzptlk-=-=-";
.
#97:9
$private();
{connection, chain} = args;
try
request = create(this.request_proto, 1);
response = create(this.response_proto, 1);
raw_request = this:_read_from_connection(connection);
raw_response = [];
if (`raw_request["error"] ! E_RANGE')
this:_log("DIALOG: ", player, " bad request: ", raw_request["error"][1], ": ", raw_request["error"][2]);
return 0;
endif
for v, k in (raw_request)
request.(k) = v;
endfor
{request, response} = this:_do_chain(request, response, chain);
for v in ({"status", "headers", "body"})
if (!is_clear_property(response, v))
raw_response[v] = response.(v);
endif
endfor
this:_write_to_connection(connection, raw_response);
finally
recycle(request);
recycle(response);
endtry
return 1;
return;
"$private()";
"";
"{connection, chain} = args";
"";
"try";
"  request = create(this.request_proto, 1)";
"  response = create(this.response_proto, 1)";
"";
"  raw_request = this:_read_from_connection(connection)";
"  raw_response = []";
"";
"  if (raw_request[\"error\"] !! E_RANGE)";
"    this:_log(\"DIALOG: \", player, \" bad request: \", raw_request[\"error\"][1], \": \", raw_request[\"error\"][2])";
"    return 0";
"  end";
"";
"  for v, k in (raw_request)";
"    request.(k) = v";
"  end";
"";
"  {request, response} = this:_do_chain(request, response, chain)";
"";
"  for v in ({\"status\", \"headers\", \"body\"})";
"    if (!is_clear_property(response, v))";
"      raw_response[v] = response.(v)";
"    endif";
"  end";
"";
"  this:_write_to_connection(connection, raw_response)";
"";
"finally";
"  recycle(request)";
"  recycle(response)";
"end";
"";
"return 1";
"";
"chunk_length:36";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:2F1A69565AA0B12C9B794977ED5345832250F66B";
"-=-=-mxyzptlk-=-=-";
.
#97:10
$restrict_to_server();
set_connection_option(player, "hold-input", 1);
set_connection_option(player, "disable-oob", 1);
set_connection_option(player, "binary", 1);
if (flash_socket_policy = this:_flash_socket_policy())
if ((line = read(player)) == "<policy-file-request/>~00")
this:_log("DIALOG: serving policy file: ", flash_socket_policy);
notify(player, flash_socket_policy);
boot_player(player);
return;
else
force_input(player, line, 1);
endif
endif
while (1)
if (!this:_do_request(player, this.default_chain))
boot_player(player);
break;
endif
endwhile
return;
"$restrict_to_server();";
"";
"set_connection_option(player, \"hold-input\", 1);";
"set_connection_option(player, \"disable-oob\", 1);";
"set_connection_option(player, \"binary\", 1);";
"";
"/* If a flash socket policy is set, peek at the first line.  If it's a";
" * policy file request, serve the policy and finish; otherwise, put";
" * the line back and continue.";
" *";
" * A reasonable socket policy for localhost is:";
" * \"<?xml version=\\\"1.0\\\"?><cross-domain-policy><allow-access-from domain=\\\"localhost\\\" to-ports=\\\"*\\\"/></cross-domain-policy>\"";
" *";
" */";
"if (flash_socket_policy = this:_flash_socket_policy())";
"  if ((line = read(player)) == \"<policy-file-request/>~00\")";
"    this:_log(\"DIALOG: serving policy file: \", flash_socket_policy);";
"    notify(player, flash_socket_policy);";
"    boot_player(player);";
"    return;";
"  else";
"    force_input(player, line, 1);";
"  endif";
"endif";
"";
"/* Loop forever (or until the client closes the connection or until";
" * failure or until something else happens).";
" */";
"while (1)";
"  if (!this:_do_request(player, this.default_chain))";
"    boot_player(player);";
"    break;";
"  endif";
"endwhile";
"";
"chunk_length:34";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:60C47FCCDA2F5078D4BC25D74E6BFC3A69F8BB8C";
"-=-=-mxyzptlk-=-=-";
.
#97:11
$private();
{request, response, chain} = args;
try
cookies = request:cookies();
try
if (`cookie = cookies[this:_session_cookie_name()] ! E_RANGE')
i = cookie:index("-");
hmac = decode_base64(cookie[1..i - 1]);
session = decode_base64(cookie[i + 1..$]);
if ((hmac && session) && (string_hmac(session, this.key) == hmac))
session = parse_json(session, "embedded-types");
if ((session["stamp"] + 604800) > time())
session["data"];
else
this:_log("DIALOG: session cookie has expired");
session = [];
endif
else
this:_log("DIALOG: session cookie hmac does not match");
session = [];
endif
else
session = [];
endif
except (ANY)
this:_log("DIALOG: session cookie is invalid");
session = [];
endtry
if (session)
session = session["data"];
endif
if (!`session["authenticity_token"] ! E_RANGE')
token = string_hash(tostr(random(), time()));
for i in [1..10 + random(100)]
token = string_hash(tostr(random(), token));
endfor
session["authenticity_token"] = token;
endif
if (`session["player"] ! E_RANGE' != E_RANGE)
player = `session["player"] ! E_RANGE => $nothing';
player = (((typeof(player) == OBJ) && valid(player)) && is_player(player)) ? player | $nothing;
session["player"] = player;
endif
local = task_local();
local["http"] = ["session" -> session];
set_task_local(local);
return {request, response, chain};
except ex (ANY)
request = request:set_exception(ex);
return {request, response, {"cleanup", "500"}};
endtry
return;
"$private();";
"";
"{request, response, chain} = args;";
"";
"/* Validate the session and transfer it to a tamper-proof container.";
" * Create a new session if necessary.";
" */";
"";
"try";
"  cookies = request:cookies();";
"";
"  try";
"    if (`cookie = cookies[this:_session_cookie_name()] ! E_RANGE')";
"      i = cookie:index(\"-\");";
"      hmac = decode_base64(cookie[1..i - 1]);";
"      session = decode_base64(cookie[i + 1..$]);";
"      if (hmac && session && string_hmac(session, this.key) == hmac)";
"        session = parse_json(session, \"embedded-types\");";
"        if (session[\"stamp\"] + 604800 > time())";
"          /* probe the value */";
"          session[\"data\"];";
"        else";
"          this:_log(\"DIALOG: session cookie has expired\");";
"          session = [];";
"        endif";
"      else";
"        this:_log(\"DIALOG: session cookie hmac does not match\");";
"        session = [];";
"      endif";
"    else";
"      /* no session cookie */";
"      session = [];";
"    endif";
"  except (ANY)";
"    this:_log(\"DIALOG: session cookie is invalid\");";
"    session = [];";
"  endtry";
"";
"  if (session)";
"    session = session[\"data\"];";
"  endif";
"";
"  /* add an authenticity_token if missing */";
"  if (!`session[\"authenticity_token\"] ! E_RANGE')";
"    token = string_hash(tostr(random(), time()));";
"    for i in [1..10 + random(100)]";
"      token = string_hash(tostr(random(), token));";
"    endfor";
"    session[\"authenticity_token\"] = token;";
"  endif";
"";
"  /* validate the player if present */";
"  if (`session[\"player\"] ! E_RANGE' != E_RANGE)";
"    player = `session[\"player\"] ! E_RANGE => $nothing';";
"    player = typeof(player) == OBJ && valid(player) && is_player(player) ? player | $nothing;";
"    session[\"player\"] = player;";
"  endif";
"";
"  local = task_local();";
"  local[\"http\"] = [\"session\" -> session];";
"  set_task_local(local);";
"";
"  return {request, response, chain};";
"";
"except ex (ANY)";
"  request = request:set_exception(ex);";
"  return {request, response, {\"cleanup\", \"500\"}};";
"endtry";
"";
"chunk_length:68";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:15AB144A52452936167909CBE136B94E014A3C0B";
"-=-=-mxyzptlk-=-=-";
.
#97:12
{request, response, chain} = args;
$private();
for item in (this.contents)
if (isa(item, this.route_proto))
if (route = item:match(request))
{object, verb, parameters} = route;
request = request:set_parameters(`request:parameters() ! E_RANGE => []':merge(parameters));
request = request:set_handler({object, verb});
break;
endif
endif
endfor
return {request, response, chain};
return;
"{request, response, chain} = args;";
"";
"$private();";
"";
"for item in (this.contents)";
"  if (isa(item, this.route_proto))";
"    if (route = item:match(request))";
"      {object, verb, parameters} = route;";
"      request = request:set_parameters(`request:parameters() ! E_RANGE => []':merge(parameters));";
"      request = request:set_handler({object, verb});";
"      break;";
"    endif";
"  endif";
"endfor";
"";
"return {request, response, chain};";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4D54E4ABBFEE9D7B0330F92ED66848FF6D4407F8";
"-=-=-mxyzptlk-=-=-";
.
#97:13
{request, response, chain} = args;
$private();
try
connection = player;
parameters = [];
plen = 0;
parameters = parameters:merge(this.utilities:parse_query_string(this.utilities:unescape(request:query()), plen));
plen = length(parameters);
if (`{type, ?mtparams = []} = request:type("full") ! E_RANGE')
if (type == "application/x-www-form-urlencoded")
parameters = parameters:merge(this.utilities:parse_query_string(this.utilities:unescape(`request:body() ! E_RANGE => ""'), plen));
plen = length(parameters);
elseif (type == "multipart/form-data")
if (mtparams && `boundary = mtparams["boundary"] ! E_RANGE')
body = request:body():trimr(tostr("--", boundary, "--~0D~0A"));
for part in (body:split(tostr("--", boundary, "~0D~0A")))
content_disposition = {};
content_type = {"text/plain"};
while (c = part:index("~0D~0A"))
if (c > 1)
header = part[1..c - 1]:split(":");
field = header[1]:trim();
value = header[2]:trim():split(";");
for i in [1..length(value)]
if (i > 1)
j = value[i]:index("=");
value[i] = {value[i][1..j - 1]:trim(), value[i][j + 1..$]:trim()};
else
value[i] = value[i]:trim();
endif
endfor
if (field == "Content-Disposition")
content_disposition = value;
elseif (field == "Content-Type")
content_type = value;
endif
part = part[c + 6..$];
else
part = part[c + 6..$];
break;
endif
endwhile
value = part[1..$ - 6];
if (((len = length(content_disposition)) > 0) && (content_disposition[1] == "form-data"))
for attr in (content_disposition[2..$])
if (attr[1] == "name")
name = attr[2]:trim("\"");
elseif (attr[1] == "filename")
filename = attr[2]:trim("\"");
value = ["__filename__" -> filename, "__content-type__" -> content_type, "__data__" -> value];
endif
endfor
if (`name ! E_VARNF')
if (plen >= 1000)
raise("-*-parameters-is-too-long-*-");
endif
plen = plen + 1;
parameters[name] = value;
endif
endif
endfor
endif
endif
endif
for v, k in (parameters)
parameters = parameters:delete(k);
ll = {};
while (k)
if (r = match(k, "^%[[^][]*%]"))
if (match(p = r[4][r[1] + 1..r[2] - 1], "^ *__"))
ll = 0;
break;
endif
ll = {@ll, p};
k[r[1]..r[2]] = "";
else
if (match(k, "^ *__"))
ll = 0;
break;
endif
ll = {@ll, k};
k = "";
endif
endwhile
if (ll)
if (((typeof(v) == MAP) && `v["__filename__"] ! E_RANGE') && `v["__data__"] ! E_RANGE')
file_mkdir(tostr("tmp/", task_id()));
filename = tostr("tmp/", task_id(), "/", value_hash(random(), "md5"));
f = -1;
try
f = file_open(filename, "w-bn");
file_write(f, v["__data__"]);
finally
(f > -1) && file_close(f);
endtry
v["__data__"] = filename;
endif
if ((z = parameters:value_by_path(ll)) != E_RANGE)
parameters = parameters:set_value_by_path(ll, (typeof(z) == LIST) ? {@z, v} | {z, v});
else
parameters = parameters:set_value_by_path(ll, v);
endif
endif
endfor
session = `task_local()["http"]["session"] ! E_RANGE => []';
if (`authenticity_token = session["authenticity_token"] ! E_RANGE')
parameters["__authenticity_token__"] = authenticity_token;
endif
if (`valid(player = session["player"]) ! E_RANGE')
parameters["__player__"] = ["id" -> player, "name" -> player.name];
endif
headers = request:headers();
if (`headers["X-Requested-With"] == "XMLHttpRequest" ! E_RANGE')
parameters["__xhr__"] = 1;
else
parameters["__xhr__"] = 0;
endif
if (`headers["X-Forwarded-Proto"] == "https" ! E_RANGE')
parameters["__ssl__"] = 1;
protocol = "https";
else
parameters["__ssl__"] = 0;
protocol = "http";
endif
{?host = "", ?port = ""} = (`headers["X-Forwarded-Host"]:split(":") ! E_RANGE' || `headers["Host"]:split(":") ! E_RANGE') || {};
if (host && port)
parameters["__url_base__"] = tostr(protocol, "://", host, ":", port);
elseif (host)
parameters["__url_base__"] = tostr(protocol, "://", host);
endif
if (`clients = headers["X-Forwarded-For"] ! E_RANGE')
parameters["__remote_client__"] = clients:split(",")[$]:trim(" ");
else
parameters["__remote_client__"] = connection_name(connection):split(" ")[4]:trim(",");
endif
request = request:set_parameters(parameters);
return {request, response, chain};
except ex ("-*-parameters-is-too-long-*-")
request = request:set_exception(ex);
return {request, response, {"cleanup", "413"}};
except ex (ANY)
request = request:set_exception(ex);
return {request, response, {"cleanup", "500"}};
endtry
return;
"{request, response, chain} = args;";
"";
"$private();";
"";
"try";
"  /* Save the player/connection.  This may be trounced";
"   * by the session, later.";
"   */";
"  connection = player;";
"";
"  /* Parameters derived from the query string and from the body are";
"   * under the control of an external user and therefore we can't";
"   * trust them.  Therefore, add them first, and then add all other";
"   * parameters from more-trusted/trusted sources (like the";
"   * convenience parameters).";
"   */";
"  parameters = [];";
"  plen = 0;";
"";
"  /* parameters from the query string */";
"  parameters = parameters:merge(this.utilities:parse_query_string(this.utilities:unescape(request:query()), plen));";
"  plen = length(parameters);";
"";
"  /* parameters from the body */";
"  if (`{type, ?mtparams = []} = request:type(\"full\") ! E_RANGE')";
"";
"    /* urlencoded parameters from the POST body */";
"    if (type == \"application/x-www-form-urlencoded\")";
"      parameters = parameters:merge(this.utilities:parse_query_string(this.utilities:unescape(`request:body() ! E_RANGE => \"\"'), plen));";
"      plen = length(parameters);";
"";
"    /* multipart form-data parameters from the POST body */";
"    elseif (type == \"multipart/form-data\")";
"      if (mtparams && `boundary = mtparams[\"boundary\"] ! E_RANGE')";
"        /* trim the fat and process each part */";
"        body = request:body():trimr(tostr(\"--\", boundary, \"--~0D~0A\"));";
"        for part in (body:split(tostr(\"--\", boundary, \"~0D~0A\")))";
"          content_disposition = {};";
"          content_type = {\"text/plain\"};";
"          /* process headers */";
"          while (c = part:index(\"~0D~0A\"))";
"            if (c > 1)";
"              header = part[1..c - 1]:split(\":\");";
"              field = header[1]:trim();";
"              value = header[2]:trim():split(\";\");";
"              for i in [1..length(value)]";
"                if (i > 1)";
"                  j = value[i]:index(\"=\");";
"                  value[i] = {value[i][1..j - 1]:trim(), value[i][j + 1..$]:trim()};";
"                else";
"                  value[i] = value[i]:trim();";
"                endif";
"              endfor";
"              if (field == \"Content-Disposition\")";
"                content_disposition = value;";
"              elseif (field == \"Content-Type\")";
"                content_type = value;";
"              endif";
"              part = part[c + 6..$];";
"            else";
"              part = part[c + 6..$];";
"              break;";
"            endif";
"          endwhile";
"          /* the value is what remains */";
"          value = part[1..$ - 6];";
"          /* add parameter */";
"          if ((len = length(content_disposition)) > 0 && content_disposition[1] == \"form-data\")";
"            for attr in (content_disposition[2..$])";
"              if (attr[1] == \"name\")";
"                name = attr[2]:trim(\"\\\"\");";
"              elseif (attr[1] == \"filename\")";
"                filename = attr[2]:trim(\"\\\"\");";
"                value = [\"__filename__\" -> filename, \"__content-type__\" -> content_type, \"__data__\" -> value];";
"              endif";
"            endfor";
"            if (`name ! E_VARNF')";
"              if (plen >= 1000)";
"                raise(\"-*-parameters-is-too-long-*-\");";
"              endif";
"              plen = plen + 1;";
"              parameters[name] = value;";
"            endif";
"          endif";
"        endfor";
"      endif";
"    endif";
"  endif";
"";
"  /* At this point the parameters map is flat, except for form data";
"   * upload parameters.  Step through the key/value pairs, strip out";
"   * pairs where the key begins with a double-underscore, create";
"   * nested parameters, create temporary files for upload data.";
"   */";
"  for v, k in (parameters)";
"    parameters = parameters:delete(k);";
"";
"    ll = {};";
"    while (k)";
"      if (r = match(k, \"^%[[^][]*%]\"))";
"        if (match((p = r[4][r[1] + 1..r[2] - 1]), \"^ *__\"))";
"          ll = 0;";
"          break;";
"        endif";
"        ll = {@ll, p};";
"        k[r[1]..r[2]] = \"\";";
"      else";
"        if (match(k, \"^ *__\"))";
"          ll = 0;";
"          break;";
"        endif";
"        ll = {@ll, k};";
"        k = \"\";";
"      endif";
"    endwhile";
"";
"    if (ll)";
"      if (typeof(v) == MAP && `v[\"__filename__\"] ! E_RANGE' && `v[\"__data__\"] ! E_RANGE')";
"        file_mkdir(tostr(\"tmp/\", task_id()));";
"        filename = tostr(\"tmp/\", task_id(), \"/\", value_hash(random(), \"md5\"));";
"        f = -1;";
"        try";
"          f = file_open(filename, \"w-bn\");";
"          file_write(f, v[\"__data__\"]);";
"        finally";
"          (f > -1) && file_close(f);";
"        endtry";
"        v[\"__data__\"] = filename;";
"      endif";
"";
"      if ((z = parameters:value_by_path(ll)) != E_RANGE)";
"        parameters = parameters:set_value_by_path(ll, typeof(z) == LIST ? {@z, v} | {z, v});";
"      else";
"        parameters = parameters:set_value_by_path(ll, v);";
"      endif";
"    endif";
"";
"  endfor";
"";
"  /* Add system/convenience parameters after _all_ _user supplied";
"   * parameters_ are added to prevent accidental/intentional redefinition.";
"   */";
"  session = `task_local()[\"http\"][\"session\"] ! E_RANGE => []';";
"";
"  if (`(authenticity_token = session[\"authenticity_token\"]) ! E_RANGE')";
"    parameters[\"__authenticity_token__\"] = authenticity_token;";
"  endif";
"  if (`valid(player = session[\"player\"]) ! E_RANGE')";
"    parameters[\"__player__\"] = [\"id\" -> player, \"name\" -> player.name];";
"  endif";
"";
"  headers = request:headers();";
"";
"  if (`headers[\"X-Requested-With\"] == \"XMLHttpRequest\" ! E_RANGE')";
"    parameters[\"__xhr__\"] = 1;";
"  else";
"    parameters[\"__xhr__\"] = 0;";
"  endif";
"";
"  if (`headers[\"X-Forwarded-Proto\"] == \"https\" ! E_RANGE')";
"    parameters[\"__ssl__\"] = 1;";
"    protocol = \"https\";";
"  else";
"    parameters[\"__ssl__\"] = 0;";
"    protocol = \"http\";";
"  endif";
"";
"  {?host = \"\", ?port = \"\"} = `headers[\"X-Forwarded-Host\"]:split(\":\") ! E_RANGE' || `headers[\"Host\"]:split(\":\") ! E_RANGE' || {};";
"  if (host && port)";
"    parameters[\"__url_base__\"] = tostr(protocol, \"://\", host, \":\", port);";
"  elseif (host)";
"    parameters[\"__url_base__\"] = tostr(protocol, \"://\", host);";
"  endif";
"";
"  if (`clients = headers[\"X-Forwarded-For\"] ! E_RANGE')";
"    parameters[\"__remote_client__\"] = clients:split(\",\")[$]:trim(\" \");";
"  else";
"    parameters[\"__remote_client__\"] = connection_name(connection):split(\" \")[4]:trim(\",\");";
"  endif";
"";
"  request = request:set_parameters(parameters);";
"";
"  return {request, response, chain};";
"";
"except ex (\"-*-parameters-is-too-long-*-\")";
"  request = request:set_exception(ex);";
"  return {request, response, {\"cleanup\", \"413\"}};";
"";
"except ex (ANY)";
"  request = request:set_exception(ex);";
"  return {request, response, {\"cleanup\", \"500\"}};";
"endtry";
"";
"chunk_length:192";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E337CB1AC84F107E9E5218E6828A80B9C0A3416A";
"-=-=-mxyzptlk-=-=-";
.
#97:14
{request, response, chain} = args;
$private();
try
if (((!(request:method() in {"GET", "HEAD"})) && ((token = `task_local()["http"]["session"]["authenticity_token"] ! E_RANGE') != `request:parameters()["authenticity_token"] ! E_RANGE')) && (token != `request:headers()["X-Authenticity-Token"] ! E_RANGE'))
return {request, response, {"cleanup", "422"}};
else
return {request, response, chain};
endif
except ex (ANY)
request = request:set_exception(ex);
return {request, response, {"cleanup", "500"}};
endtry
return;
"{request, response, chain} = args;";
"";
"$private();";
"";
"/* Per 9.1.1 Safe Methods, RFC 2616, GET and HEAD are explicitly safe";
" * methods and do not require the authenticity token.  POST, PUT and";
" * DELETE are explicitly non-safe; however, assume that all methods";
" * that are not explicitly safe are non-safe.";
" */";
"";
"try";
"  if (!(request:method() in {\"GET\", \"HEAD\"}) &&";
"      (token = `task_local()[\"http\"][\"session\"][\"authenticity_token\"] ! E_RANGE') != `request:parameters()[\"authenticity_token\"] ! E_RANGE' &&";
"      token != `request:headers()[\"X-Authenticity-Token\"] ! E_RANGE')";
"    return {request, response, {\"cleanup\", \"422\"}};";
"  else";
"    return {request, response, chain};";
"  endif";
"";
"except ex (ANY)";
"  request = request:set_exception(ex);";
"  return {request, response, {\"cleanup\", \"500\"}};";
"endtry";
"";
"chunk_length:23";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:EB7CB40EF0C82FC88B927AA59E60BC0690A8A59B";
"-=-=-mxyzptlk-=-=-";
.
#97:15
$private();
{request, response, chain} = args;
if (`handler = request:handler() ! E_RANGE')
{object, verb} = handler;
if (respond_to(object, verb))
start = time();
player = `task_local()["http"]["session"]["player"] ! E_RANGE => $nothing';
try
object = create({object, $dialog.handler_proto}, object.owner, 1);
object.name = tostr("#<HTTP @ ", ctime(start), ">");
object.session = task_local()["http"]["session"];
object.request = request;
object.response = response;
this:_drop_perms_and_call_verb(object, verb, request, response);
task_local = task_local();
task_local["http"]["start"] = start;
task_local["http"]["session"] = object.session;
set_task_local(task_local);
finally
recycle(object);
endtry
chain = chain:setremove("404");
endif
endif
return {request, response, chain};
return;
"$private()";
"";
"{request, response, chain} = args";
"";
"if (handler = request:handler() !! E_RANGE)";
"  {object, verb} = handler";
"";
"  if (respond_to(object, verb))";
"    start = time()";
"";
"    /* Set player and then drop perms in a wrapper verb so that the";
"     * dropped perms don't make us lose the player change.";
"     */";
"    player = (task_local()[\"http\"][\"session\"][\"player\"] !! E_RANGE => $nothing)";
"";
"    try";
"      object = create({object, $dialog.handler_proto}, object.owner, 1)";
"      object.name = tostr(\"#<HTTP @ \", ctime(start), \">\")";
"      object.session = task_local()[\"http\"][\"session\"]";
"      object.request = request";
"      object.response = response";
"";
"      this:_drop_perms_and_call_verb(object, verb, request, response)";
"";
"      task_local = task_local()";
"      task_local[\"http\"][\"start\"] = start";
"      task_local[\"http\"][\"session\"] = object.session";
"      set_task_local(task_local)";
"    finally";
"      recycle(object)";
"    end";
"";
"    /* If successful, remove the 404 -- if 404 is present, it";
"     * should be the first, last and only 404.";
"     */";
"    chain = chain:setremove(\"404\")";
"  end";
"end";
"";
"return {request, response, chain}";
"";
"chunk_length:40";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:640B915671AF84A1097E0645172034ECFAE48DA3";
"-=-=-mxyzptlk-=-=-";
.
#97:16
{request, response, chain} = args;
$private();
try
data = `task_local()["http"]["session"] ! E_RANGE => []';
headers = `response:headers() ! E_RANGE => []';
session = ["data" -> data, "stamp" -> time()];
session = generate_json(session, "embedded-types");
hmac = string_hmac(session, this.key);
session = encode_base64(session);
hmac = encode_base64(hmac);
set_cookie = `headers["Set-Cookie"] ! E_RANGE => {}';
set_cookie = {@set_cookie, tostr(this.session_cookie_name, "=", hmac, "-", session, ";path=/;HttpOnly")};
headers["Set-Cookie"] = set_cookie:join(",");
package = $lookup("package");
headers["Server"] = tostr(package.identifier, "/", package.version);
headers["Date"] = this.utilities.time:rfc1123_time();
response = response:set_headers(headers);
try
for file in (file_list(tostr("tmp/", task_id())))
file_remove(tostr("tmp/", task_id(), "/", file));
endfor
file_rmdir(tostr("tmp/", task_id()));
except (E_FILE)
endtry
if (!is_clear_property(response, "body"))
body = response:body();
if ((t = typeof(body)) == LIST)
body = body:join("~0D~0A") + "~0D~0A";
elseif (t != STR)
body = tostr(body) + "~0D~0A";
endif
headers["Content-Type"] = `headers["Content-Type"] ! E_RANGE => "text/plain"';
headers["Content-Length"] = `headers["Content-Length"] ! E_RANGE => length(decode_binary(body, 1))';
response = response:set_headers(headers):set_body(body);
endif
return {request, response, chain};
except ex (ANY)
request = request:set_exception(ex);
return {request, response, {"500"}};
endtry
return;
"{request, response, chain} = args;";
"";
"$private();";
"";
"try";
"  data = `task_local()[\"http\"][\"session\"] ! E_RANGE => []';";
"";
"  headers = `response:headers() ! E_RANGE => []';";
"";
"  /* secure session */";
"  session = [\"data\" -> data, \"stamp\" -> time()];";
"  session = generate_json(session, \"embedded-types\");";
"  hmac = string_hmac(session, this.key);";
"  session = encode_base64(session);";
"  hmac = encode_base64(hmac);";
"";
"  /* store in cookie */";
"  set_cookie = `headers[\"Set-Cookie\"] ! E_RANGE => {}';";
"  set_cookie = {@set_cookie, tostr(this.session_cookie_name, \"=\", hmac, \"-\", session, \";path=/;HttpOnly\")};";
"  headers[\"Set-Cookie\"] = set_cookie:join(\",\");";
"";
"  /* add Server header */";
"  package = $lookup(\"package\");";
"  headers[\"Server\"] = tostr(package.identifier, \"/\", package.version);";
"";
"  /* add Date header */";
"  headers[\"Date\"] = this.utilities.time:rfc1123_time();";
"";
"  response = response:set_headers(headers);";
"";
"  /* clean temporary files */";
"  try";
"    for file in (file_list(tostr(\"tmp/\", task_id())))";
"      file_remove(tostr(\"tmp/\", task_id(), \"/\", file));";
"    endfor";
"    file_rmdir(tostr(\"tmp/\", task_id()));";
"  except (E_FILE)";
"  endtry";
"";
"  /* Deal with the body.  Processing can fail with E_QUOTA/E_INVARG";
"   * when concatenating strings and computing the length of the body.";
"   */";
"  if (!is_clear_property(response, \"body\"))";
"    body = response:body();";
"    /* if the body is not a string, make it a string */";
"    if ((t = typeof(body)) == LIST)";
"      body = body:join(\"~0D~0A\") + \"~0D~0A\";";
"    elseif (t != STR)";
"      body = tostr(body) + \"~0D~0A\";";
"    endif";
"";
"    /* ensure we have content type and content length */";
"    headers[\"Content-Type\"] = `headers[\"Content-Type\"] ! E_RANGE => \"text/plain\"';";
"    headers[\"Content-Length\"] = `headers[\"Content-Length\"] ! E_RANGE => length(decode_binary(body, 1))';";
"";
"    response = response:set_headers(headers):set_body(body);";
"  endif";
"";
"  return {request, response, chain};";
"";
"except ex (ANY)";
"  request = request:set_exception(ex);";
"  return {request, response, {\"500\"}};";
"endtry";
"";
"chunk_length:64";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:CEC4DCCC593C5D89F648554018E5D79871486D6F";
"-=-=-mxyzptlk-=-=-";
.
#97:17
$private();
{request, response, chain} = args;
try
code = toint(verb);
description = this.status_codes[code];
except (E_RANGE)
code = 500;
description = "Internal Server Error";
endtry
body = "<html><head><title>%m</title></head><body><h1>%m</h1>%c</body></html>";
if (`ex = request:exception() ! E_RANGE')
body = body:strsub(["%m" -> description, "%c" -> this:traceback(ex)]);
response = response:set_status(code):set_type("text/html"):set_length(length(body)):set_body(body);
else
body = body:strsub(["%m" -> description, "%c" -> ""]);
response = response:set_status(code):set_type("text/html"):set_length(length(body)):set_body(body);
endif
return {request, response, chain};
return;
"$private();";
"";
"{request, response, chain} = args;";
"";
"try";
"  code = toint(verb);";
"  description = this.status_codes[code];";
"except (E_RANGE)";
"  code = 500;";
"  description = \"Internal Server Error\";";
"endtry";
"";
"body = \"<html><head><title>%m</title></head><body><h1>%m</h1>%c</body></html>\";";
"";
"if (`ex = request:exception() ! E_RANGE')";
"  body = body:strsub([\"%m\" -> description, \"%c\" -> this:traceback(ex)]);";
"  response = response:set_status(code):set_type(\"text/html\"):set_length(length(body)):set_body(body);";
"else";
"  body = body:strsub([\"%m\" -> description, \"%c\" -> \"\"]);";
"  response = response:set_status(code):set_type(\"text/html\"):set_length(length(body)):set_body(body);";
"endif";
"";
"return {request, response, chain};";
"";
"chunk_length:23";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0B52F53CCFC46208D5C43BF16F2BA2BEC5BFB623";
"-=-=-mxyzptlk-=-=-";
.
#97:18
{ex} = args;
$private();
{l, @r} = ex[4];
tb = "<ol>";
tb = tostr(tb, "<li><code>", l[4], ":", l[2], @(l[4] != l[1]) ? {" (this == ", toliteral(l[1]), ")"} | {}, ", line ", l[6], ": ", ex[2], "</code></li>");
for l in (r)
tb = tostr(tb, "<li><code>... called from ", l[4], ":", l[2], @(l[4] != l[1]) ? {" (this == ", toliteral(l[1]), ")"} | {}, ", line ", l[6], "</code></li>");
endfor
tb = tostr(tb, "<li><code>(End of traceback)</code></li>");
tb = tostr(tb, "</ol>");
return tb;
return;
"{ex} = args;";
"$private();";
"{l, @r} = ex[4];";
"tb = \"<ol>\";";
"tb = tostr(tb, \"<li><code>\", l[4], \":\", l[2], @l[4] != l[1] ? {\" (this == \", toliteral(l[1]), \")\"} | {}, \", line \", l[6], \": \", ex[2], \"</code></li>\");";
"for l in (r)";
"  tb = tostr(tb, \"<li><code>... called from \", l[4], \":\", l[2], @l[4] != l[1] ? {\" (this == \", toliteral(l[1]), \")\"} | {}, \", line \", l[6], \"</code></li>\");";
"endfor";
"tb = tostr(tb, \"<li><code>(End of traceback)</code></li>\");";
"tb = tostr(tb, \"</ol>\");";
"return tb;";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:7D865CCCDBB718C6F8351AC45C64C5A9CF06D7FF";
"-=-=-mxyzptlk-=-=-";
.
#97:19
{verb, @args} = args;
$permit("wizard");
set_task_perms(caller_perms());
(verb in {"_do_request", "external", "session", "player", "route", "parameters", "protect_from_forgery", "serve", "cleanup", "404", "500"}) || raise(E_INVARG);
return this:(verb)(@args);
return;
"{verb, @args} = args;";
"$permit(\"wizard\");";
"set_task_perms(caller_perms());";
"verb in {\"_do_request\", \"external\", \"session\", \"player\", \"route\", \"parameters\", \"protect_from_forgery\", \"serve\", \"cleanup\", \"404\", \"500\"} || raise(E_INVARG);";
"return this:(verb)(@args);";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:CD7E4970FACB9D0130ACEEDDE6A3CD618FBBE8E6";
"-=-=-mxyzptlk-=-=-";
.
#97:20
$private();
{object, verb, request, response} = args;
set_task_perms(player);
try
object:(verb)(request:parameters());
return {request, response};
except (E_ARGS)
{request, response} = object:(verb)(request, response);
return {request, response};
endtry
return;
"$private()";
"";
"{object, verb, request, response} = args";
"";
"set_task_perms(player)";
"";
"/* For now, attempt both the new and old styles";
" * of delivery.  Assumes the verbs use scattering";
" * to distribute `args'.";
" */";
"try";
"  object:(verb)(request:parameters())";
"  return {request, response}";
"except (E_ARGS)";
"  {request, response} =  object:(verb)(request, response)";
"  return {request, response}";
"end";
"";
"chunk_length:17";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:6EE9652577C963B12456D95A504992FE72079D54";
"-=-=-mxyzptlk-=-=-";
.
#97:21
$private();
{request, response, chain} = args;
set_task_perms($nothing);
try
while (chain)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
{top, @chain} = chain;
if (typeof(top) == LIST)
{object, verb} = top;
else
object = this;
verb = top;
endif
if (!((object == this) || (object in this.contents)))
raise(E_PERM, tostr("Permission denied:  couldn't chain to ", object, ":", verb));
elseif (!respond_to(object, verb))
raise(E_VERBNF, tostr("Verb not found:  couldn't chain to ", object, ":", verb));
else
{request, response, chain} = object:(verb)(request, response, chain);
endif
endwhile
except ex (ANY)
request = request:set_exception(ex);
if ("cleanup" in chain)
{request, response, chain} = this:cleanup(request, response, chain);
endif
{request, response, chain} = this:("500")(request, response, chain);
endtry
return {request, response};
return;
"$private();";
"";
"{request, response, chain} = args;";
"";
"/* Drop perms here as a precaution.  Any special (wiz) verbs called";
" * below won't see themselves as having been called with special (wiz)";
" * permissions.";
" */";
"set_task_perms($nothing);";
"";
"try";
"";
"  while (chain)";
"    ticks_left() < 10000 || seconds_left() < 2 && suspend(0);";
"";
"    {top, @chain} = chain;";
"";
"    if (typeof(top) == LIST)";
"      {object, verb} = top;";
"    else";
"      object = this;";
"      verb = top;";
"    endif";
"";
"    /* For boots and suspenders, make sure the object on which the";
"     * verb is being invoked is on this or in the contents of this.";
"     * And make sure it's callable.";
"     */";
"    if (!(object == this || object in this.contents))";
"      raise(E_PERM, tostr(\"Permission denied:  couldn't chain to \", object, \":\", verb));";
"    elseif (!respond_to(object, verb))";
"      raise(E_VERBNF, tostr(\"Verb not found:  couldn't chain to \", object, \":\", verb));";
"    else";
"      {request, response, chain} = object:(verb)(request, response, chain);";
"    endif";
"  endwhile";
"";
"/* Try to be smart about failure.  No matter what's left in the chain,";
" * only do the \"cleanup\" and \"500\" steps -- if we fail while doing";
" * them, _don't_ fail again.";
" */";
"except ex (ANY)";
"  request = request:set_exception(ex);";
"";
"  if (\"cleanup\" in chain)";
"    {request, response, chain} = this:cleanup(request, response, chain);";
"  endif";
"";
"  {request, response, chain} = this:(\"500\")(request, response, chain);";
"endtry";
"";
"return {request, response};";
"";
"chunk_length:52";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E06C52C1D9541FAA362F8ABEFEE46817BCAC4768";
"-=-=-mxyzptlk-=-=-";
.
#98:0
property = verb;
return this.(property);
return;
"property = verb;";
"return this.(property);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:DE435FF968D67DDC75EFF17144A65E2A61CAD871";
"-=-=-mxyzptlk-=-=-";
.
#98:1
{value} = args;
property = verb[5..$];
this.(property) = value;
return this;
return;
"{value} = args;";
"property = verb[5..$];";
"this.(property) = value;";
"return this;";
"";
"chunk_length:4";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:53C593653EFB12DF7A88C698495B2B8D25084617";
"-=-=-mxyzptlk-=-=-";
.
#98:2
cookies = [];
cookie = `this.headers["cookie"] ! ANY => ""';
for cookie in (cookie:split(";"))
i = index(cookie, "=");
key = cookie[1..i - 1]:trim();
value = cookie[i + 1..$]:trim();
cookies[key] = value;
endfor
return cookies;
return;
"cookies = [];";
"cookie = `this.headers[\"cookie\"] ! ANY => \"\"';";
"for cookie in (cookie:split(\";\"))";
"  i = index(cookie, \"=\");";
"  key = cookie[1..i - 1]:trim();";
"  value = cookie[i + 1..$]:trim();";
"  cookies[key] = value;";
"endfor";
"return cookies;";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D76FDFB46B9B95363AE174571AE09C2248412A19";
"-=-=-mxyzptlk-=-=-";
.
#98:3
i = this.uri:index("?");
return i ? this.uri[1..i - 1] | this.uri;
return;
"i = this.uri:index(\"?\");";
"return i ? this.uri[1..i - 1] | this.uri;";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9215FEDB92107E86EFFE7CB971B3B1FF835E97CF";
"-=-=-mxyzptlk-=-=-";
.
#98:4
i = this.uri:index("?");
return i ? this.uri[i + 1..$] | "";
return;
"i = this.uri:index(\"?\");";
"return i ? this.uri[i + 1..$] | \"\";";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:421B26D75F80E176C56505F7D6046F5E7071D9B6";
"-=-=-mxyzptlk-=-=-";
.
#98:5
{?full = 0} = args;
{type, ?parameters = ""} = this.headers["Content-Type"]:split(";");
if (full)
temp = [];
for parameter in (parameters:split(","))
{k, v} = parameter:split("=");
temp[k:trim()] = v:trim();
endfor
return {type:trim(), temp};
else
return type:trim();
endif
return;
"{?full = 0} = args;";
"";
"{type, ?parameters = \"\"} = this.headers[\"Content-Type\"]:split(\";\");";
"";
"if (full)";
"  temp = [];";
"  for parameter in (parameters:split(\",\"))";
"    {k, v} = parameter:split(\"=\");";
"    temp[k:trim()] = v:trim();";
"  endfor";
"  return {type:trim(), temp};";
"else";
"  return type:trim();";
"endif";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5DCC09F7B82DB57F280018DB38F0AB98980165D6";
"-=-=-mxyzptlk-=-=-";
.
#98:6
{type, ?parameters = []} = args;
if (parameters)
temp = {};
for v, k in (parameters)
temp = {@temp, tostr(k, "=", v)};
endfor
this.headers["Content-Type"] = tostr(type, "; ", temp:join());
else
this.headers["Content-Type"] = type;
endif
return this;
return;
"{type, ?parameters = []} = args;";
"";
"if (parameters)";
"  temp = {};";
"  for v, k in (parameters)";
"    temp = {@temp, tostr(k, \"=\", v)};";
"  endfor";
"  this.headers[\"Content-Type\"] = tostr(type, \"; \", temp:join());";
"else";
"  this.headers[\"Content-Type\"] = type;";
"endif";
"";
"return this;";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6909B5C41C68B53EB9C0D643BCFAB8ADA30975DD";
"-=-=-mxyzptlk-=-=-";
.
#98:7
args && raise(E_ARGS);
return this.headers["Content-Length"];
return;
"args && raise(E_ARGS);";
"";
"return this.headers[\"Content-Length\"];";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6B9D45DE29C3416F9244F5293CD9E0DA18FB8E45";
"-=-=-mxyzptlk-=-=-";
.
#98:8
{length} = args;
this.headers["Content-Length"] = length;
return this;
return;
"{length} = args;";
"";
"this.headers[\"Content-Length\"] = length;";
"";
"return this;";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D12550F8D598B99DD1D5947056326B966D997322";
"-=-=-mxyzptlk-=-=-";
.
#99:0
property = verb;
return this.(property);
return;
"property = verb;";
"return this.(property);";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:DE435FF968D67DDC75EFF17144A65E2A61CAD871";
"-=-=-mxyzptlk-=-=-";
.
#99:1
{value} = args;
property = verb[5..$];
this.(property) = value;
return this;
return;
"{value} = args;";
"property = verb[5..$];";
"this.(property) = value;";
"return this;";
"";
"chunk_length:4";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:53C593653EFB12DF7A88C698495B2B8D25084617";
"-=-=-mxyzptlk-=-=-";
.
#99:2
{?full = 0} = args;
{type, ?parameters = ""} = this.headers["Content-Type"]:split(";");
if (full)
temp = [];
for parameter in (parameters:split(","))
{k, v} = parameter:split("=");
temp[k:trim()] = v:trim();
endfor
return {type:trim(), temp};
else
return type:trim();
endif
return;
"{?full = 0} = args;";
"";
"{type, ?parameters = \"\"} = this.headers[\"Content-Type\"]:split(\";\");";
"";
"if (full)";
"  temp = [];";
"  for parameter in (parameters:split(\",\"))";
"    {k, v} = parameter:split(\"=\");";
"    temp[k:trim()] = v:trim();";
"  endfor";
"  return {type:trim(), temp};";
"else";
"  return type:trim();";
"endif";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5DCC09F7B82DB57F280018DB38F0AB98980165D6";
"-=-=-mxyzptlk-=-=-";
.
#99:3
{type, ?parameters = []} = args;
if (parameters)
temp = {};
for v, k in (parameters)
temp = {@temp, tostr(k, "=", v)};
endfor
this.headers["Content-Type"] = tostr(type, "; ", temp:join());
else
this.headers["Content-Type"] = type;
endif
return this;
return;
"{type, ?parameters = []} = args;";
"";
"if (parameters)";
"  temp = {};";
"  for v, k in (parameters)";
"    temp = {@temp, tostr(k, \"=\", v)};";
"  endfor";
"  this.headers[\"Content-Type\"] = tostr(type, \"; \", temp:join());";
"else";
"  this.headers[\"Content-Type\"] = type;";
"endif";
"";
"return this;";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:6909B5C41C68B53EB9C0D643BCFAB8ADA30975DD";
"-=-=-mxyzptlk-=-=-";
.
#99:4
args && raise(E_ARGS);
fields = ["length" -> "Content-Length", "location" -> "Location"];
return this.headers[fields[verb]];
return;
"args && raise(E_ARGS);";
"";
"fields = [\"length\" -> \"Content-Length\", \"location\" -> \"Location\"];";
"";
"return this.headers[fields[verb]];";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:FE66217513FEA4C464F462910F36C00AE0BF4F4D";
"-=-=-mxyzptlk-=-=-";
.
#99:5
{value} = args;
fields = ["set_length" -> "Content-Length", "set_location" -> "Location"];
this.headers[fields[verb]] = value;
return this;
return;
"{value} = args;";
"";
"fields = [\"set_length\" -> \"Content-Length\", \"set_location\" -> \"Location\"];";
"";
"this.headers[fields[verb]] = value;";
"";
"return this;";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A694D806221EB41BFC94352365127F1133728337";
"-=-=-mxyzptlk-=-=-";
.
#100:0
return {};
return;
"/* A route can match on anything in a request -- common criteria are";
" * HTTP method and URI.  A matched route returns the object/verb that";
" * will handle the request, as well as parameters that will be added";
" * to the other parameters in the request.";
" *";
" * In:";
" *  MAP request";
" * Out:";
" *  OBJ receiver";
" *  STR verb";
" *  MAP parameters";
" */";
"return {};";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:4BD935C3BDE051C54B2484EC2D8E80EEFD6205EC";
"-=-=-mxyzptlk-=-=-";
.
#101:0
$private();
return this.request;
return;
"$private()";
"";
"return this.request // limited, secure access to the request";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:4F1E66619CCEB5BDCFEF503B0E63BF7FA01C3C3F";
"-=-=-mxyzptlk-=-=-";
.
#101:1
$private();
return this.response;
return;
"$private()";
"";
"return this.response // limited, secure access to the response";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:92CB24D6887D08B8C6AB2F4E902E51AAB6D71611";
"-=-=-mxyzptlk-=-=-";
.
#101:2
$private();
this._ensure_once && raise(E_INVARG, "Multiple calls to helpers");
this._ensure_once = this._ensure_once + 1;
return;
"$private()";
"";
"this._ensure_once && raise(E_INVARG, \"Multiple calls to helpers\")";
"";
"this._ensure_once += 1";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:A968E1606D3F823583B0D8C312BFA8DB598F28C5";
"-=-=-mxyzptlk-=-=-";
.
#101:3
$protected();
{body, ?type = "text/html", ?code = 200} = args;
this:_ensure_once();
this:_response():set_status(code):set_type(type):set_body(body);
return;
"$protected()";
"";
"{body, type = \"text/html\", code = 200} = args";
"";
"this:_ensure_once()";
"";
"this:_response():set_status(code):set_type(type):set_body(body)";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:D792358C3E37FA977E3256F0B474ACC5DB67E188";
"-=-=-mxyzptlk-=-=-";
.
#101:4
$protected();
{?code = 400} = args;
this:_ensure_once();
this:_response():set_status(code);
return;
"$protected()";
"";
"{code = 400} = args";
"";
"this:_ensure_once()";
"";
"this:_response():set_status(code)";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:E1631C1495C0546D523F4DC046B5295350CB828A";
"-=-=-mxyzptlk-=-=-";
.
#101:5
$protected();
{?code = 403} = args;
this:_ensure_once();
this:_response():set_status(code);
return;
"$protected()";
"";
"{code = 403} = args";
"";
"this:_ensure_once()";
"";
"this:_response():set_status(code)";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:A16D781CDF9BEB2854103FC982EA1CB7288D316A";
"-=-=-mxyzptlk-=-=-";
.
#101:6
$protected();
{body, ?type = "text/html", ?code = 404} = args;
this:_ensure_once();
this:_response():set_status(code):set_type(type):set_body(body);
return;
"$protected()";
"";
"{body, type = \"text/html\", code = 404} = args";
"";
"this:_ensure_once()";
"";
"this:_response():set_status(code):set_type(type):set_body(body)";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:B2ED5773046177A2BB8BB0BA9BD1B39B7CC92FBF";
"-=-=-mxyzptlk-=-=-";
.
#101:7
$protected();
{?code = 406} = args;
this:_ensure_once();
this:_response():set_status(code);
return;
"$protected()";
"";
"{code = 406} = args";
"";
"this:_ensure_once()";
"";
"this:_response():set_status(code)";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:8B4568336842137F438E3C2E5D39DC4742320304";
"-=-=-mxyzptlk-=-=-";
.
#101:8
$protected();
{?code = 413} = args;
this:_ensure_once();
this:_response():set_status(code);
return;
"$protected()";
"";
"{code = 413} = args";
"";
"this:_ensure_once()";
"";
"this:_response():set_status(code)";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:EC1EBE95F675141B59084E1FAE2F7C12E00E45DC";
"-=-=-mxyzptlk-=-=-";
.
#101:9
$protected();
{body, ?type = "text/html", ?code = 500} = args;
this:_ensure_once();
this:_response():set_status(code):set_type(type):set_body(body);
return;
"$protected()";
"";
"{body, type = \"text/html\", code = 500} = args";
"";
"this:_ensure_once()";
"";
"this:_response():set_status(code):set_type(type):set_body(body)";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:46A21BD2A5E94AD17715E0AB088F4EAF8CF3E6B2";
"-=-=-mxyzptlk-=-=-";
.
#101:10
$protected();
{location, ?code = 302} = args;
this:_ensure_once();
this:_response():set_status(code):set_location(location);
return;
"$protected()";
"";
"{location, code = 302} = args";
"";
"this:_ensure_once()";
"";
"this:_response():set_status(code):set_location(location)";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:13782343138F69F3D887D7035024D9DB8B95495B";
"-=-=-mxyzptlk-=-=-";
.
#102:0
$permit("owner", "wizard");
{player} = args;
(valid(player) || (player == $nothing)) || raise(E_INVARG, tostr("Invalid argument:  ", player), player);
(valid(player) && (player.wizard || player.programmer)) && raise(E_INVARG, tostr("Invalid argument:  ", player), player);
if (valid(player))
valid = 0;
for prototype in (this.prototypes)
if (isa(player, prototype))
valid = 1;
break;
endif
endfor
else
valid = 1;
endif
(!valid) && raise(E_PERM);
set_task_local(task_local():merge(["http" -> ["session" -> ["player" -> player]]]));
return;
"$permit(\"owner\", \"wizard\")";
"";
"{player} = args;";
"";
"(valid(player) || player == $nothing) || raise(E_INVARG, tostr(\"Invalid argument:  \", player), player)";
"valid(player) && (player.wizard || player.programmer) && raise(E_INVARG, tostr(\"Invalid argument:  \", player), player)";
"";
"if (valid(player))";
"  valid = 0";
"  for prototype in (this.prototypes)";
"    if (isa(player, prototype))";
"      valid = 1";
"      break";
"    endif";
"  endfor";
"else";
"  valid = 1";
"endif";
"";
"!valid && raise(E_PERM)";
"";
"set_task_local(task_local():merge([\"http\" -> [\"session\" -> [\"player\" -> player]]]))";
"";
"chunk_length:22";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:8C8F66867688AB485A32D9335358CBFC7E8E9E00";
"-=-=-mxyzptlk-=-=-";
.
#102:1
$permit("owner", "wizard");
return task_local()["http"]["session"]["player"];
return;
"$permit(\"owner\", \"wizard\")";
"";
"return task_local()[\"http\"][\"session\"][\"player\"]";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:E63E4A886C997A9E1D2AAE6232B4FBB55F3E291D";
"-=-=-mxyzptlk-=-=-";
.
#103:0
$restrict_to_caller(this.location);
{request} = args;
if (request:uri() == "/")
return {this, "it_works!", []};
else
return {};
endif
return;
"$restrict_to_caller(this.location)";
"";
"{request} = args";
"";
"if (request:uri() == \"/\")";
"  return {this, \"it_works!\", []}";
"else";
"  return {}";
"endif";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:DA1A4B86E074DF149917F0CC4D6F67EACF452994";
"-=-=-mxyzptlk-=-=-";
.
#103:1
_2134902771 = this;
$restrict_to_caller(parent(this).location);
{parameters} = args;
_2134902771:ok({"<html>", "<head>", "<title>Welcome to Stunt!</title>", "</head>", "<body>", "<h1>Welcome to Stunt!</h1>", "<p>It works!  For information about Stunt, check out <a href=\"http://stunt.io/\">http://stunt.io/</a>.</p>", ("<!-- " + this.name) + " -->", "</body>", "</html>"});
return;
"from this use ok";
"";
"$restrict_to_caller(parent(this).location)";
"";
"{parameters} = args";
"";
"ok({";
"  '<html>',";
"    '<head>',";
"      '<title>Welcome to Stunt!</title>',";
"    '</head>',";
"    '<body>',";
"      '<h1>Welcome to Stunt!</h1>',";
"      '<p>It works!  For information about Stunt, check out <a href=\"http://stunt.io/\">http://stunt.io/</a>.</p>',";
"      '<!-- ' + this.name + ' -->',";
"    '</body>',";
"  '</html>'";
"})";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:A75C1E6770AAB09E9B3F05DD1DF5C1A5A38B3B4D";
"-=-=-mxyzptlk-=-=-";
.
#106:0
$restrict_to_caller($dialog.server, "route");
{request} = args;
uri = request:uri();
uri = uri:strsub(["%20" -> " "]);
if (index(uri, "///") == 1)
return {};
endif
if (uri[$] == "/")
uri = uri + "index.html";
endif
file = "public" + uri;
if (`stat = file_stat(file) ! E_FILE, E_INVARG, E_PERM' && (stat[2] == "reg"))
return {this, "get", ["__sendfile__" -> file]};
endif
return {};
return;
"$restrict_to_caller($dialog.server, \"route\");";
"";
"{request} = args;";
"";
"uri = request:uri();";
"";
"/* replace common URI escapes */";
"uri = uri:strsub([\"%20\" ->\" \"]);";
"";
"/* avoid uris that start with \"///\", which is the database handler path prefix */";
"if (index(uri, \"///\") == 1)";
"  return {};";
"endif";
"";
"/* handle the common case of directory access */";
"if (uri[$] == \"/\")";
"  uri = uri + \"index.html\";";
"endif";
"";
"file = \"public\" + uri;";
"";
"if (`(stat = file_stat(file)) ! E_FILE, E_INVARG, E_PERM' && stat[2] == \"reg\")";
"  return {this, \"get\", [\"__sendfile__\" -> file]};";
"endif";
"";
"return {};";
"";
"chunk_length:26";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E3D5D93459DAE9506EC7E795ED4F70840ED8BDEC";
"-=-=-mxyzptlk-=-=-";
.
#106:1
$restrict_to_caller($dialog.server, "_drop_perms_and_call_verb", "serve");
{request, response} = args;
try
file = request:parameters()["__sendfile__"];
headers = `response:headers() ! E_RANGE => []';
headers["Last-Modified"] = last_modified = $core.utility.time:rfc1123_time(file_stat(file)[7]);
response = response:set_headers(headers);
if (`request:headers()["If-Modified-Since"] ! E_RANGE' == last_modified)
response = response:set_status(304);
return {request, response};
endif
data = "";
size = file_size(file);
fh = -1;
try
fh = file_open(file, "r-bn");
while ((pos = file_tell(fh)) != size)
chunk = file_read(fh, size - pos);
data = data ? data + chunk | chunk;
endwhile
finally
(fh > -1) && file_close(fh);
endtry
type = "application/octet-stream";
ext = (length(parts = file:split(".")) > 1) ? parts[$] | "";
if ("txt" == ext)
type = "text/plain";
elseif (("html" == ext) || ("htm" == ext))
type = "text/html";
elseif ("jpeg" == ext)
type = "image/jpeg";
elseif ("jpg" == ext)
type = "image/jpeg";
elseif ("png" == ext)
type = "image/png";
elseif ("gif" == ext)
type = "image/gif";
elseif ("css" == ext)
type = "text/css";
elseif ("less" == ext)
type = "text/css";
elseif ("js" == ext)
type = "text/javascript";
elseif ("json" == ext)
type = "application/json";
elseif ("xml" == ext)
type = "application/xml";
elseif ("swf" == ext)
type = "application/x-shockwave-flash";
elseif (("moo" == ext) || ("moocode" == ext))
type = "application/x-moocode";
else
try
{code, out, ERR} = exec({"identify", "-format", "%m", "files/" + file});
if (!code)
if ("JPEG" == (out = decode_binary(out)[1]))
type = "image/jpeg";
elseif ("PNG" == out)
type = "image/png";
elseif ("GIF" == out)
type = "image/gif";
endif
endif
except (E_INVARG, E_EXEC)
endtry
endif
server_log(tostr("HTTP: serving file: ", file));
response = response:set_status(200):set_body(data):set_type(type):set_length(size);
return {request, response};
except (E_FILE)
endtry
return {request, response};
return;
"$restrict_to_caller($dialog.server, \"_drop_perms_and_call_verb\", \"serve\");";
"";
"{request, response} = args;";
"";
"try";
"  /* \"__sendfile__\" is the file to send */";
"  file = request:parameters()[\"__sendfile__\"];";
"";
"  /* set Last-Modified header */";
"  headers = `response:headers() ! E_RANGE => []';";
"  headers[\"Last-Modified\"] = last_modified = $core.utility.time:rfc1123_time(file_stat(file)[7]);";
"  response = response:set_headers(headers);";
"";
"  /* don't serve the file if it hasn't changed */";
"  if (`request:headers()[\"If-Modified-Since\"] ! E_RANGE' == last_modified)";
"    response = response:set_status(304);";
"    return {request, response};";
"  endif";
"";
"  /* read data */";
"  data = \"\";";
"  size = file_size(file);";
"  fh = -1;";
"";
"  try";
"    fh = file_open(file, \"r-bn\");";
"    while ((pos = file_tell(fh)) != size)";
"      chunk = file_read(fh, size - pos);";
"      data = data ? data + chunk | chunk;";
"    endwhile";
"  finally";
"    (fh > -1) && file_close(fh);";
"  endtry";
"";
"  /* determine the type */";
"  type = \"application/octet-stream\";";
"";
"  ext = length(parts = file:split(\".\")) > 1 ? parts[$] | \"\";";
"";
"  if (\"txt\" == ext)";
"    type = \"text/plain\";";
"  elseif (\"html\" == ext || \"htm\" == ext)";
"    type = \"text/html\";";
"  elseif (\"jpeg\" == ext)";
"    type = \"image/jpeg\";";
"  elseif (\"jpg\" == ext)";
"    type = \"image/jpeg\";";
"  elseif (\"png\" == ext)";
"    type = \"image/png\";";
"  elseif (\"gif\" == ext)";
"    type = \"image/gif\";";
"  elseif (\"css\" == ext)";
"    type = \"text/css\";";
"  elseif (\"less\" == ext)";
"    type = \"text/css\";";
"  elseif (\"js\" == ext)";
"    type = \"text/javascript\";";
"  elseif (\"json\" == ext)";
"    type = \"application/json\";";
"  elseif (\"xml\" == ext)";
"    type = \"application/xml\";";
"  elseif (\"swf\" == ext)";
"    type = \"application/x-shockwave-flash\";";
"  elseif (\"moo\" == ext || \"moocode\" == ext)";
"    type = \"application/x-moocode\";";
"  else";
"    /* last ditch effort, try to exec `identify' */";
"    try";
"      {code, out, err} = exec({\"identify\", \"-format\", \"%m\", \"files/\" + file});";
"      if (!code)";
"        if (\"JPEG\" == (out = decode_binary(out)[1]))";
"          type = \"image/jpeg\";";
"        elseif (\"PNG\" == out)";
"          type = \"image/png\";";
"        elseif (\"GIF\" == out)";
"          type = \"image/gif\";";
"        endif";
"      endif";
"    except (E_INVARG, E_EXEC)";
"    endtry";
"  endif";
"";
"  server_log(tostr(\"HTTP: serving file: \", file));";
"";
"  response = response:set_status(200):set_body(data):set_type(type):set_length(size);";
"";
"  return {request, response};";
"";
"except (E_FILE)";
"endtry";
"";
"return {request, response};";
"";
"chunk_length:92";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D94F0FEFE6BFCA8C80AD9C3266AD37CDEFFF3C0F";
"-=-=-mxyzptlk-=-=-";
.
#107:0
$restrict_to_caller($dialog.server, "route");
{request} = args;
uri = request:uri();
if (uri:index("///") == 1)
if (request:method() == "get")
return {this, "get", []};
elseif (request:method() == "put")
return {this, "put", []};
elseif (request:method() == "post")
return {this, "post", []};
elseif (request:method() == "delete")
return {this, "delete", []};
endif
endif
return {};
return;
"$restrict_to_caller($dialog.server, \"route\");";
"";
"{request} = args;";
"";
"uri = request:uri();";
"";
"if (uri:index(\"///\") == 1)";
"  if (request:method() == \"get\")";
"    return {this, \"get\", []};";
"  elseif (request:method() == \"put\")";
"    return {this, \"put\", []};";
"  elseif (request:method() == \"post\")";
"    return {this, \"post\", []};";
"  elseif (request:method() == \"delete\")";
"    return {this, \"delete\", []};";
"  endif";
"endif";
"";
"return {};";
"";
"chunk_length:19";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0875C635816E12E580F8E3B06EE9A208AA17D102";
"-=-=-mxyzptlk-=-=-";
.
#107:1
$private();
{uri} = args;
if ((uri:index("///") == 1) && ((r = uri:split("/")):length() < 5))
{?a = "", ?b = "", ?c = "", ?d = ""} = r;
return {a, b, c, d};
else
return 0;
endif
return;
"$private();";
"";
"{uri} = args;";
"";
"/*";
"if (r = uri:match(\"^///\" + \"%(%(%w+%)/%(%w+%)?%)?\" + \"%(/%(%w+%)/%(%w+%)?%)?\" + \"$\"))";
"  a1 = r[4][r[3][2][1]..r[3][2][2]];";
"  a2 = r[4][r[3][3][1]..r[3][3][2]];";
"  b1 = r[4][r[3][5][1]..r[3][5][2]];";
"  b2 = r[4][r[3][6][1]..r[3][6][2]];";
"  return {a1, a2, b1, b2};";
"*/";
"if (uri:index(\"///\") == 1 && (r = uri:split(\"/\")):length() < 5)";
"  {?a = \"\", ?b = \"\", ?c = \"\", ?d = \"\"} = r;";
"  return {a, b, c, d};";
"else";
"  return 0;";
"endif";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:7F7443E20EE530973234647DC499BE53D981636E";
"-=-=-mxyzptlk-=-=-";
.
#107:2
{o} = args;
if (match(o, "^#?-?[0-9]+$"))
return toobj(o);
else
return $nothing;
endif
return;
"{o} = args;";
"if (match(o, \"^#?-?[0-9]+$\"))";
"  return toobj(o);";
"else";
"  return $nothing;";
"endif";
"";
"chunk_length:6";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0FA2F2DA5428FB786F77073FE5616CAA57888902";
"-=-=-mxyzptlk-=-=-";
.
#107:3
$restrict_to_caller($dialog.server, "_drop_perms_and_call_verb", "serve");
set_task_perms(caller_perms());
{request, response} = args;
uri = request:uri();
if (r = this:_match_uri(uri))
{a1, a2, b1, b2} = r;
if ((((!a1) && (!a2)) && (!b1)) && (!b2))
response = response:set_status(200);
response = response:set_type("application/json");
response = response:set_body("{}");
elseif (((("objects" == a1) && (!a2)) && (!b1)) && (!b2))
response = response:set_status(200);
response = response:set_type("application/json");
response = response:set_body("{}");
elseif (((("objects" == a1) && a2) && (!b1)) && (!b2))
o = this:_toobj(a2);
o = $shapes:read_object(o);
status = o["Meta"]["status"];
status = (status == "invalid") ? 404 | ((status == "denied") ? 403 | 200);
response = response:set_status(status);
response = response:set_type("application/json");
response = response:set_body(generate_json(o, "embedded-types"):strsub("~", "~7E"));
else
response = response:set_status(404);
response = response:set_type("application/json");
response = response:set_body("{}");
endif
else
response = response:set_status(404);
response = response:set_type("application/json");
response = response:set_body("{}");
endif
return {request, response};
return;
"$restrict_to_caller($dialog.server, \"_drop_perms_and_call_verb\", \"serve\");";
"";
"set_task_perms(caller_perms());";
"";
"{request, response} = args;";
"";
"uri = request:uri();";
"";
"if (r = this:_match_uri(uri))";
"  {a1, a2, b1, b2} = r;";
"  if (!a1 && !a2 && !b1 && !b2)";
"    response = response:set_status(200);";
"    response = response:set_type(\"application/json\");";
"    response = response:set_body(\"{}\");";
"  elseif (\"objects\" == a1 && !a2 && !b1 && !b2)";
"    response = response:set_status(200);";
"    response = response:set_type(\"application/json\");";
"    response = response:set_body(\"{}\");";
"  elseif (\"objects\" == a1 && a2 && !b1 && !b2)";
"    o = this:_toobj(a2);";
"    o = $shapes:read_object(o);";
"    status = o[\"Meta\"][\"status\"];";
"    status = (status == \"invalid\" ? 404 | (status == \"denied\" ? 403 | 200));";
"    response = response:set_status(status);";
"    response = response:set_type(\"application/json\");";
"    response = response:set_body(generate_json(o, \"embedded-types\"):strsub(\"~\", \"~7E\"));";
"  /*";
"  elseif (\"objects\" == a1 && a2 && \"attributes\" == b1 && b2)";
"    response = response:set_status(200);";
"    response = response:set_type(\"application/json\");";
"    response = response:set_body(generate_json($shapes:read_attribute(this:_toobj(a2), b2), \"embedded-types\"));";
"  elseif (\"objects\" == a1 && a2 && \"properties\" == b1 && b2)";
"    response = response:set_status(200);";
"    response = response:set_type(\"application/json\");";
"    response = response:set_body(generate_json($shapes:read_property(this:_toobj(a2), toint(b2)), \"embedded-types\"));";
"  elseif (\"objects\" == a1 && a2 && \"verbs\" == b1 && b2)";
"    response = response:set_status(200);";
"    response = response:set_type(\"application/json\");";
"    response = response:set_body(generate_json($shapes:read_verb(this:_toobj(a2), toint(b2)), \"embedded-types\"));";
"  */";
"  else";
"    response = response:set_status(404);";
"    response = response:set_type(\"application/json\");";
"    response = response:set_body(\"{}\");";
"  endif";
"else";
"  response = response:set_status(404);";
"  response = response:set_type(\"application/json\");";
"  response = response:set_body(\"{}\");";
"endif";
"";
"return {request, response};";
"";
"chunk_length:52";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:40DF01BD0DCE5EABC26CFD68538904B0F49DD264";
"-=-=-mxyzptlk-=-=-";
.
#107:4
$restrict_to_caller($dialog.server, "_drop_perms_and_call_verb", "serve");
set_task_perms(caller_perms());
{request, response} = args;
if (((`request:type() ! E_RANGE' != "application/json") || (`body = request:body() ! E_RANGE' == E_RANGE)) || (`body = parse_json(body, "embedded-types") ! E_INVARG' == E_INVARG))
response = response:set_status(415);
return {request, response};
endif
uri = request:uri();
if (r = this:_match_uri(uri))
{type, id, x1, x2} = r;
if (((("objects" == type) && id) && (!x1)) && (!x2))
if (!valid(o = this:_toobj(id)))
response = response:set_status(404);
return {request, response};
elseif (!$shapes:controls(player, o))
response = response:set_status(403);
return {request, response};
endif
body = $shapes:write_object(o, body);
body = generate_json(body, "embedded-types");
response = response:set_status(200):set_type("application/json"):set_body(body);
return {request, response};
endif
endif
response = response:set_status(404);
return {request, response};
return;
"$restrict_to_caller($dialog.server, \"_drop_perms_and_call_verb\", \"serve\");";
"";
"set_task_perms(caller_perms());";
"";
"{request, response} = args;";
"";
"if (`request:type() ! E_RANGE' != \"application/json\" ||";
"    `(body = request:body()) ! E_RANGE' == E_RANGE ||";
"    `(body = parse_json(body, \"embedded-types\")) ! E_INVARG' == E_INVARG)";
"  response = response:set_status(415);";
"  return {request, response};";
"endif";
"";
"uri = request:uri();";
"";
"if (r = this:_match_uri(uri))";
"  {type, id, x1, x2} = r;";
"  if (\"objects\" == type && id && !x1 && !x2)";
"    if (!valid(o = this:_toobj(id)))";
"      response = response:set_status(404);";
"      return {request, response};";
"    elseif (!$shapes:controls(player, o))";
"      response = response:set_status(403);";
"      return {request, response};";
"    endif";
"    body = $shapes:write_object(o, body);";
"    body = generate_json(body, \"embedded-types\");";
"    response = response:set_status(200):set_type(\"application/json\"):set_body(body);";
"    return {request, response};";
"  endif";
"endif";
"";
"response = response:set_status(404);";
"return {request, response};";
"";
"chunk_length:34";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5FC18E0AD92A5A2A1C47D188D6EDB39CBFBFCDF0";
"-=-=-mxyzptlk-=-=-";
.
#107:5
$restrict_to_caller($dialog.server, "_drop_perms_and_call_verb", "serve");
set_task_perms(caller_perms());
{request, response} = args;
if (((`request:type() ! E_RANGE' != "application/json") || (`body = request:body() ! E_RANGE' == E_RANGE)) || (`body = parse_json(body, "embedded-types") ! E_INVARG' == E_INVARG))
response = response:set_status(415);
return {request, response};
endif
uri = request:uri();
if (r = this:_match_uri(uri))
{type, x0, x1, x2} = r;
if (((("objects" == type) && (!x0)) && (!x1)) && (!x2))
if (!valid(player))
response = response:set_status(403);
return {request, response};
endif
o = create($nothing);
body = $shapes:write_object(o, body);
body = generate_json(body, "embedded-types");
response = response:set_status(201):set_location(tostr("///objects/", toint(o))):set_type("application/json"):set_body(body);
return {request, response};
endif
endif
response = response:set_status(404);
return {request, response};
return;
"$restrict_to_caller($dialog.server, \"_drop_perms_and_call_verb\", \"serve\");";
"";
"set_task_perms(caller_perms());";
"";
"{request, response} = args;";
"";
"if (`request:type() ! E_RANGE' != \"application/json\" ||";
"    `(body = request:body()) ! E_RANGE' == E_RANGE ||";
"    `(body = parse_json(body, \"embedded-types\")) ! E_INVARG' == E_INVARG)";
"  response = response:set_status(415);";
"  return {request, response};";
"endif";
"";
"uri = request:uri();";
"";
"if (r = this:_match_uri(uri))";
"  {type, x0, x1, x2} = r;";
"  if (\"objects\" == type && !x0 && !x1 && !x2)";
"    if (!valid(player))";
"      response = response:set_status(403);";
"      return {request, response};";
"    endif";
"    o = create($nothing);";
"    body = $shapes:write_object(o, body);";
"    body = generate_json(body, \"embedded-types\");";
"    response = response:set_status(201):set_location(tostr(\"///objects/\", toint(o))):set_type(\"application/json\"):set_body(body);";
"    return {request, response};";
"  endif";
"endif";
"";
"response = response:set_status(404);";
"return {request, response};";
"";
"chunk_length:32";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:288A263C496C67358B7D74A1B9E53A74DE4FACD0";
"-=-=-mxyzptlk-=-=-";
.
#107:6
$restrict_to_caller($dialog.server, "_drop_perms_and_call_verb", "serve");
set_task_perms(caller_perms());
{request, response} = args;
uri = request:uri();
if (r = this:_match_uri(uri))
{type, id, x1, x2} = r;
if (((("objects" == type) && id) && (!x1)) && (!x2))
if (!valid(o = this:_toobj(id)))
response = response:set_status(404);
return {request, response};
elseif (!$shapes:controls(player, o))
response = response:set_status(403);
return {request, response};
endif
`recycle(o) ! ANY';
if (valid(o))
response = response:set_status(500);
return {request, response};
endif
response = response:set_status(204);
return {request, response};
endif
endif
response = response:set_status(404);
return {request, response};
return;
"$restrict_to_caller($dialog.server, \"_drop_perms_and_call_verb\", \"serve\");";
"";
"set_task_perms(caller_perms());";
"";
"{request, response} = args;";
"";
"uri = request:uri();";
"";
"if (r = this:_match_uri(uri))";
"  {type, id, x1, x2} = r;";
"  if (\"objects\" == type && id && !x1 && !x2)";
"    if (!valid(o = this:_toobj(id)))";
"      response = response:set_status(404);";
"      return {request, response};";
"    elseif (!$shapes:controls(player, o))";
"      response = response:set_status(403);";
"      return {request, response};";
"    endif";
"    `recycle(o) ! ANY';";
"    if (valid(o)) /* if it's stil around... */";
"      response = response:set_status(500);";
"      return {request, response};";
"    endif";
"    response = response:set_status(204);";
"    return {request, response};";
"  endif";
"endif";
"";
"response = response:set_status(404);";
"return {request, response};";
"";
"chunk_length:30";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D63893C8EA33B24FE5D829B1FE0A95154BC6377C";
"-=-=-mxyzptlk-=-=-";
.
#108:0
$restrict_to_caller($dialog.server, "_do_chain");
{request, response, chain} = args;
if (request:upgrade())
if ((`request:headers()["upgrade"] ! E_RANGE' == "moo") && (`request:headers()["X-Break-A-Leg"] ! E_RANGE' == "stunt"))
if (((typeof(new_player = `task_local()["http"]["session"]["player"] ! E_RANGE') == OBJ) && valid(new_player)) && is_player(new_player))
set_connection_option(player, "hold-input", 0);
set_connection_option(player, "disable-oob", 0);
set_connection_option(player, "binary", 0);
switch_player(player, new_player);
kill_task(task_id());
endif
boot_player(player);
return {request, response, {}};
endif
endif
return {request, response, chain};
return;
"$restrict_to_caller($dialog.server, \"_do_chain\");";
"";
"{request, response, chain} = args;";
"";
"if (request:upgrade())";
"  if (`request:headers()[\"upgrade\"] ! E_RANGE' == \"moo\" && `request:headers()[\"X-Break-A-Leg\"] ! E_RANGE' == \"stunt\")";
"    if (typeof(new_player = `task_local()[\"http\"][\"session\"][\"player\"] ! E_RANGE') == OBJ && valid(new_player) && is_player(new_player))";
"      /* put the connection into interactive mode */";
"      set_connection_option(player, \"hold-input\", 0);";
"      set_connection_option(player, \"disable-oob\", 0);";
"      set_connection_option(player, \"binary\", 0);";
"      switch_player(player, new_player);";
"      /* This is clumsy, but... when we successfully upgrade the";
"       * connection, end the task/request without booting the player";
"       * and let MOO's own command handling take over.";
"       */";
"      kill_task(task_id());";
"    endif";
"";
"    /* It's a valid upgrade, but the session is out-of-date or bogus.";
"     * For safety's sake, close the connection.";
"     */";
"    boot_player(player);";
"    return {request, response, {}};";
"  endif";
"endif";
"";
"/* continue if not upgrading */";
"return {request, response, chain};";
"";
"chunk_length:29";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:3DA5626BEDD8B12ECEFE3181CD693BBBB7315DD3";
"-=-=-mxyzptlk-=-=-";
.
#108:1
$restrict_to_caller($dialog.server, "_do_chain");
{request, response, chain} = args;
if (request:path() == "/__long_poll")
if (`request:headers()["X-Break-A-Leg"] ! E_RANGE' == "stunt")
if (((typeof(new_player = `task_local()["http"]["session"]["player"] ! E_RANGE') == OBJ) && valid(new_player)) && is_player(new_player))
notify(player, tostr("HTTP/1.1 ", 200, " ", "Ok", "~0D~0A"));
notify(player, tostr("Content-Type: ", "text/plain", "~0D~0A"));
notify(player, "~0D~0A");
for i in [1..16]
notify(player, "                                                                                                                                ");
endfor
set_connection_option(player, "hold-input", 0);
set_connection_option(player, "disable-oob", 0);
set_connection_option(player, "binary", 0);
switch_player(player, new_player);
if (cmd = `request:body() ! E_RANGE')
force_input(new_player, cmd);
endif
kill_task(task_id());
endif
boot_player(player);
return {request, response, {}};
endif
endif
return {request, response, chain};
return;
"$restrict_to_caller($dialog.server, \"_do_chain\");";
"";
"{request, response, chain} = args;";
"";
"if (request:path() == \"/__long_poll\")";
"  if (`request:headers()[\"X-Break-A-Leg\"] ! E_RANGE' == \"stunt\")";
"    if (typeof(new_player = `task_local()[\"http\"][\"session\"][\"player\"] ! E_RANGE') == OBJ && valid(new_player) && is_player(new_player))";
"      /* write a minimal header */";
"      notify(player, tostr(\"HTTP/1.1 \", 200, \" \", \"Ok\", \"~0D~0A\"));";
"      notify(player, tostr(\"Content-Type: \", \"text/plain\", \"~0D~0A\"));";
"      notify(player, \"~0D~0A\");";
"      /* write 2048 bytes to get chrome off its ass */";
"      for i in [1..16]";
"        notify(player, \"                                                                                                                                \");";
"      endfor";
"      /* put the connection into interactive mode */";
"      set_connection_option(player, \"hold-input\", 0);";
"      set_connection_option(player, \"disable-oob\", 0);";
"      set_connection_option(player, \"binary\", 0);";
"      switch_player(player, new_player);";
"      /* finally, force the body as a command */";
"      if (cmd = `request:body() ! E_RANGE')";
"        force_input(new_player, cmd);";
"      endif";
"      /* This is clumsy, but... when we successfully set up the";
"       * connection, end the task/request without booting the player";
"       * and let MOO's own command handling take over.";
"       */";
"      kill_task(task_id());";
"    endif";
"";
"    /* It's a valid poll, but the session is out-of-date or bogus.";
"     * For safety's sake, close the connection.";
"     */";
"    boot_player(player);";
"    return {request, response, {}};";
"  endif";
"";
"endif";
"";
"return {request, response, chain};";
"";
"chunk_length:41";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:C9DA4A4709AB750ED4339CFBC6B47CDFFF176FD2";
"-=-=-mxyzptlk-=-=-";
.
#109:0
$restrict_to_caller($dialog.server, "_do_chain");
{request, response, chain} = args;
finish = time();
start = `task_local()["http"]["start"] ! E_RANGE => finish';
client = `request:parameters()["__remote_client__"] ! E_RANGE => "NA"';
player = `task_local()["http"]["session"]["player"] ! E_RANGE => $nothing';
name = `player.name ! E_TYPE, E_INVIND => ""';
server_log(tostr("HTTP: ", client, " ", toliteral(name), " (", player, ") ", request:method(), " ", request:uri(), " ", response:status(), " ", finish - start));
return {request, response, chain};
return;
"$restrict_to_caller($dialog.server, \"_do_chain\")";
"";
"{request, response, chain} = args";
"";
"finish = time()";
"";
"start = (task_local()[\"http\"][\"start\"] !! E_RANGE => finish)";
"client = (request:parameters()[\"__remote_client__\"] !! E_RANGE => \"NA\")";
"player = (task_local()[\"http\"][\"session\"][\"player\"] !! E_RANGE => $nothing)";
"name = (player.name !! E_TYPE, E_INVIND => \"\")";
"";
"server_log(tostr(\"HTTP: \", client, \" \", toliteral(name), \" (\", player, \") \", request:method(), \" \", request:uri(), \" \", response:status(), \" \", finish - start))";
"";
"return {request, response, chain}";
"";
"chunk_length:14";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:07DF7F582068D0F8208AE222C368658830183C5B";
"-=-=-mxyzptlk-=-=-";
.
#110:0
{value} = args;
return strsub(strsub(strsub(strsub(value, "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), "\"", "&quot;");
return;
"{value} = args";
"return strsub(strsub(strsub(strsub(value, '&', '&amp;'), '<', '&lt;'), '>', '&gt;'), '\"', '&quot;')";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:BBE27A5BD0879899B3579ABE891C8194C4C66760";
"-=-=-mxyzptlk-=-=-";
.
#110:1
{context} = args;
return `this:escape(context["__authenticity_token__"]) ! E_RANGE => ""';
return;
"{context} = args";
"return this:escape(context[\"__authenticity_token__\"]) !! E_RANGE => \"\"";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:2260576335C92B28191B7B9B1CF7CCC3B804B046";
"-=-=-mxyzptlk-=-=-";
.
#110:2
{context, @stack} = args;
return tostr("<meta name=\"authenticity_token\" content=\"", this:authenticity_token(context), "\"/>");
return;
"{context, @stack} = args";
"return tostr('<meta name=\"authenticity_token\" content=\"', this:authenticity_token(context), '\"/>')";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:445E04C2D0ECB7191FF3D75D972C0EE24F59A9EE";
"-=-=-mxyzptlk-=-=-";
.
#110:3
{context, @stack} = args;
return tostr("<input type=\"hidden\" name=\"authenticity_token\" value=\"", this:authenticity_token(context), "\">");
return;
"{context, @stack} = args";
"return tostr('<input type=\"hidden\" name=\"authenticity_token\" value=\"', this:authenticity_token(context), '\">')";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:87B093FD9A78277610CB6A48F3F670F8177DA1E7";
"-=-=-mxyzptlk-=-=-";
.
#111:0
$restrict_to_caller($composed);
$external_compilers["application/x-mustache"] = $mustache.compiler;
return;
"$restrict_to_caller($composed);";
"";
"$external_compilers[\"application/x-mustache\"] = $mustache.compiler;";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:20B0254B84F3C85A0B3F9FBD3FA91AB168AEDFAE";
"-=-=-mxyzptlk-=-=-";
.
#111:1
$restrict_to_caller($composed);
$external_compilers = $external_compilers:delete("application/x-mustache");
return;
"$restrict_to_caller($composed);";
"";
"$external_compilers = $external_compilers:delete(\"application/x-mustache\");";
"";
"chunk_length:3";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:28F56276ABB1EBEE63718214A624DBB6D74EE42C";
"-=-=-mxyzptlk-=-=-";
.
#114:0
$private();
server_log(tostr(@args));
return;
"$private();";
"server_log(tostr(@args));";
"";
"chunk_length:2";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:5C711D4BD9B9002572DB2CFAFFD7E9106FB3C119";
"-=-=-mxyzptlk-=-=-";
.
#114:1
{source, ?options = []} = args;
(typeof(source) == LIST) || raise(E_TYPE, "Source must be a list");
code = {"stack = args;", "output = {};"};
start_delim = "{{";
end_delim = "}}";
had_partial = 0;
in_comment = 0;
tag_count = 0;
tag_stack = {};
linec = 0;
for line in (source)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
linec = linec + 1;
if (in_comment)
e = end_delim;
if (!(i = line:index(e)))
line = "";
else
line = line[i + length(e)..$];
tag_count = tag_count + 1;
in_comment = 0;
endif
else
tag_count = 0;
if (line == "")
code = {@code, "output = {@output, \"\", 0};"};
endif
endif
while (line)
escaped = 1;
start_new_context = 0;
start_new_inverted_context = 0;
end_context = 0;
include_partial = 0;
set_delimiters = 0;
comment = 0;
s = start_delim;
if (!(i = line:index(s)))
code = {@code, tostr("output = {@output, ", toliteral(line), ", ", tag_count, "};")};
tag_count = 0;
line = "";
continue;
endif
if ((c = line[i + length(s)]) == "{")
escaped = 0;
s = start_delim + "{";
e = "}" + end_delim;
elseif (c == "&")
escaped = 0;
s = start_delim + "&";
e = end_delim;
elseif (c == "#")
start_new_context = 1;
s = start_delim + "#";
e = end_delim;
elseif (c == "^")
start_new_inverted_context = 1;
s = start_delim + "^";
e = end_delim;
elseif (c == "/")
end_context = 1;
s = start_delim + "/";
e = end_delim;
elseif (c == ">")
include_partial = 1;
s = start_delim + ">";
e = end_delim;
elseif (c == "=")
set_delimiters = 1;
s = start_delim + "=";
e = "=" + end_delim;
elseif (c == "!")
comment = 1;
s = start_delim + "!";
e = end_delim;
else
s = start_delim;
e = end_delim;
endif
content = line[1..i - 1];
rest = line[i + length(s)..$];
if ((!(j = rest:index(e))) && comment)
code = {@code, tostr("output = {@output, ", toliteral(content), "};")};
in_comment = 1;
line = "";
continue;
elseif (!j)
code = {@code, tostr("output = {@output, ", toliteral(line), ", ", tag_count, "};")};
tag_count = 0;
line = "";
continue;
endif
j = ((j + i) + length(s)) - 1;
tag = original_tag = line[i + length(s)..j - 1]:trim();
tag_list = original_tag_list = (tag != ".") ? tag:split(".") | {"."};
code = {@code, tostr("output = {@output, ", toliteral(content), "};")};
line = line[j + length(e)..$];
if (comment)
tag_count = tag_count + 1;
elseif (include_partial)
had_partial = 1;
code = {@code, tostr("verb = `this:(\"", original_tag, "\")(@stack) ! E_VERBNF => {}';")};
code = {@code, "output = {@output, verb};"};
tag_count = tag_count + 1;
elseif (set_delimiters)
{start_delim, end_delim} = original_tag:split();
tag_count = tag_count + 1;
elseif (start_new_context)
tag_stack = {tag, @tag_stack};
if ((l = length(original_tag_list)) > 1)
code = {@code, "failed = 0;"};
tag = original_tag_list[1];
code = {@code, tostr("if (top = `stack[1][\"", tag, "\"] ! E_RANGE')")};
code = {@code, "stack = {stack[1]:merge(typeof(top) == MAP ? top | []), @stack};"};
code = {@code, "else"};
code = {@code, "stack = {[], @stack}; failed = 1;"};
code = {@code, "endif"};
for tag in (original_tag_list[2..$ - 1])
code = {@code, tostr("if (top = `stack[1][\"", tag, "\"] ! E_RANGE')")};
code = {@code, "stack = {typeof(top) == MAP ? top | [], @stack};"};
code = {@code, "else"};
code = {@code, "stack = {[], @stack}; failed = 1;"};
code = {@code, "endif"};
endfor
tag = original_tag_list[$];
code = {@code, tostr("if (!failed && (top = `stack[1][\"", tag, "\"] ! E_RANGE'))")};
code = {@code, "for item in (typeof(top) == LIST ? top | {top})"};
code = {@code, "ticks_left() < 10000 || seconds_left() < 2 && suspend(0);"};
code = {@code, "stack = {typeof(item) == MAP ? item | [\".\" -> item], @stack};"};
else
tag = original_tag_list[1];
code = {@code, tostr("if (top = `stack[1][\"", tag, "\"] ! E_RANGE')")};
code = {@code, "for item in (typeof(top) == LIST ? top | {top})"};
code = {@code, "ticks_left() < 10000 || seconds_left() < 2 && suspend(0);"};
code = {@code, "stack = {stack[1]:merge(typeof(item) == MAP ? item | [\".\" -> item]), @stack};"};
endif
tag_count = tag_count + 1;
elseif (start_new_inverted_context)
tag_stack = {tag, @tag_stack};
if ((l = length(original_tag_list)) > 1)
code = {@code, "failed = 0;"};
tag = original_tag_list[1];
code = {@code, tostr("if (top = `stack[1][\"", tag, "\"] ! E_RANGE')")};
code = {@code, "stack = {stack[1]:merge(typeof(top) == MAP ? top | []), @stack};"};
code = {@code, "else"};
code = {@code, "stack = {[], @stack}; failed = 1;"};
code = {@code, "endif"};
for tag in (original_tag_list[2..$ - 1])
code = {@code, tostr("if (top = `stack[1][\"", tag, "\"] ! E_RANGE')")};
code = {@code, "stack = {typeof(top) == MAP ? top | [], @stack};"};
code = {@code, "else"};
code = {@code, "stack = {[], @stack}; failed = 1;"};
code = {@code, "endif"};
endfor
tag = original_tag_list[$];
code = {@code, tostr("if (failed || !(top = `stack[1][\"", tag, "\"] ! E_RANGE'))")};
code = {@code, "for item in ({\"\"})"};
code = {@code, "ticks_left() < 10000 || seconds_left() < 2 && suspend(0);"};
code = {@code, "stack = {typeof(item) == MAP ? item | [\".\" -> item], @stack};"};
else
tag = original_tag_list[1];
code = {@code, tostr("if (!(top = `stack[1][\"", tag, "\"] ! E_RANGE'))")};
code = {@code, "for item in ({\"\"})"};
code = {@code, "ticks_left() < 10000 || seconds_left() < 2 && suspend(0);"};
code = {@code, "stack = {stack[1]:merge(typeof(item) == MAP ? item | [\".\" -> item]), @stack};"};
endif
tag_count = tag_count + 1;
elseif (end_context)
if (!tag_stack)
return {0, {tostr("Line ", linec, ":  dangling end tag:  ", tag)}};
endif
{top, @tag_stack} = tag_stack;
if (top != tag)
return {0, {tostr("Line ", linec, ":  mismatched end tag:  ", tag)}};
endif
code = {@code, "stack = stack[2..$];", "endfor", "endif"};
if ((l = length(original_tag_list)) > 1)
code = {@code, tostr("stack = stack[", l, "..$];")};
endif
tag_count = tag_count + 1;
else
if ((l = length(original_tag_list)) > 1)
for tag in (original_tag_list[1..$ - 1])
code = {@code, tostr("top = `stack[1][\"", tag, "\"] ! E_RANGE';")};
code = {@code, "stack = {typeof(top) == MAP ? top | [], @stack};"};
endfor
endif
if (!original_tag_list)
return {0, {tostr("Line ", linec, ":  empty tag")}};
endif
tag = original_tag_list[$];
if (escaped)
code = {@code, tostr("output = {@output, strsub(strsub(strsub(strsub(", "`tostr(stack[1][\"", tag, "\"]) ! E_RANGE => \"\"'", ", \"&\", \"&amp;\"), \"<\", \"&lt;\"), \">\", \"&gt;\"), \"\\\"\", \"&quot;\")};")};
else
code = {@code, tostr("output = {@output, `tostr(stack[1][\"", tag, "\"]) ! E_RANGE => \"\"'};")};
endif
if (l > 1)
code = {@code, tostr("stack = stack[", l, "..$];")};
endif
tag_count = tag_count + 1;
endif
endwhile
if ((!in_comment) && tag_count)
code = {@code, tostr("output = {@output, ", tag_count, "};")};
endif
endfor
if (tag_stack)
return {0, {tostr("Line ", linec, ":  missing end tag:  ", tag_stack[1])}};
endif
code = {@code, "out = {}; acc = {}; indent = \"\";"};
code = {@code, "while (output)"};
code = {@code, "{line, @output} = output;"};
code = {@code, "ticks_left() < 10000 || seconds_left() < 2 && suspend(0);"};
code = {@code, "if (typeof(line) == LIST)"};
if (had_partial)
code = {@code, "if (lines = line)"};
code = {@code, "if (length(lines) > 1)"};
code = {@code, "temp = {lines[1], 0};"};
code = {@code, "for line in (lines[2..$ - 1])"};
code = {@code, "temp = {@temp, indent + line, 0};"};
code = {@code, "endfor"};
code = {@code, "temp = {@temp, indent + lines[$]};"};
code = {@code, "output = {@temp, @output};"};
code = {@code, "else"};
code = {@code, "output = {lines[1], @output};"};
code = {@code, "endif"};
code = {@code, "endif"};
endif
code = {@code, "elseif (typeof(line) == INT)"};
code = {@code, "if (line > 0)"};
code = {@code, "if (match(acc = tostr(@acc), \"[^ ]\"))"};
code = {@code, "out = {@out, acc};"};
code = {@code, "endif"};
code = {@code, "else"};
code = {@code, "out = {@out, tostr(@acc)};"};
code = {@code, "endif"};
code = {@code, "acc = {};"};
if (had_partial)
code = {@code, "indent = \"\";"};
endif
code = {@code, "else"};
if (had_partial)
code = {@code, "if (!match(line, \"[^ ]\"))"};
code = {@code, "indent = line;"};
code = {@code, "endif"};
endif
code = {@code, "acc = {@acc, line};"};
code = {@code, "endif"};
code = {@code, "endwhile"};
code = {@code, "return out;"};
return {1, code};
return;
"{source, ?options = []} = args;";
"";
"(typeof(source) == LIST) || raise(E_TYPE, \"Source must be a list\");";
"";
"/* NOTES */";
"/* LambdaMOO currently only has one kind of whitespace -- a single";
" * space -- therefore many of the associated tests from the";
" * specification don't quite work as-is.  In sames cases, I have";
" * replaced tab (\\t) and newline (\\n) with a single space.  In other";
" * cases, I have used lists to represent lines separated by a newline";
" * (or return/newline).  Other tests just won't pass as-is without";
" * finer control over line-endings.";
" */";
"";
"code = {\"stack = args;\", \"output = {};\"};";
"";
"/* the initial delimiters */";
"start_delim = \"{{\";";
"end_delim = \"}}\";";
"";
"/* if true, the template had a partial */";
"had_partial = 0;";
"";
"/* if true, we're processing a multiline comment */";
"in_comment = 0;";
"";
"/* the number of tags in the line */";
"tag_count = 0;";
"";
"/* for matching tags */";
"tag_stack = {};";
"";
"/* line count */";
"linec = 0;";
"";
"/* process each line */";
"for line in (source)";
"  ticks_left() < 10000 || seconds_left() < 2 && suspend(0);";
"";
"  linec = linec + 1;";
"";
"  /* if we're processing a multiline comment, look for the end";
"   * delimiter -- once found, continue with the rest of the line as if";
"   * it were a continuation of the line on which the comment started";
"   */";
"  if (in_comment)";
"    e = end_delim;";
"    if (!(i = line:index(e)))";
"      line = \"\";";
"    else";
"      line = line[i + length(e)..$];";
"      tag_count = tag_count + 1;";
"      in_comment = 0;";
"    endif";
"";
"  else";
"    tag_count = 0;";
"";
"    /* preserve empty lines */";
"    if (line == \"\")";
"      code = {@code, \"output = {@output, \\\"\\\", 0};\"};";
"    endif";
"";
"  endif";
"";
"  /* chop each line into pieces of content separated by tags -- each";
"   * pass through the loop tries to find a tag and the piece of";
"   * content preceding it";
"   */";
"  while (line)";
"    escaped = 1;";
"    start_new_context = 0;";
"    start_new_inverted_context = 0;";
"    end_context = 0;";
"    include_partial = 0;";
"    set_delimiters = 0;";
"    comment = 0;";
"";
"    /* look for a starting delimiter */";
"    s = start_delim;";
"    if (!(i = line:index(s)))";
"      /* no delimiter! */";
"      code = {@code, tostr(\"output = {@output, \", toliteral(line), \", \", tag_count, \"};\")};";
"      tag_count = 0;";
"      line = \"\";";
"      continue;";
"    endif";
"";
"    if ((c = line[i + length(s)]) == \"{\")";
"      escaped = 0;";
"      s = start_delim + \"{\";";
"      e = \"}\" + end_delim;";
"    elseif (c == \"&\")";
"      escaped = 0;";
"      s = start_delim + \"&\";";
"      e = end_delim;";
"    elseif (c == \"#\")";
"      start_new_context = 1;";
"      s = start_delim + \"#\";";
"      e = end_delim;";
"    elseif (c == \"^\")";
"      start_new_inverted_context = 1;";
"      s = start_delim + \"^\";";
"      e = end_delim;";
"    elseif (c == \"/\")";
"      end_context = 1;";
"      s = start_delim + \"/\";";
"      e = end_delim;";
"    elseif (c == \">\")";
"      include_partial = 1;";
"      s = start_delim + \">\";";
"      e = end_delim;";
"    elseif (c == \"=\")";
"      set_delimiters = 1;";
"      s = start_delim + \"=\";";
"      e = \"=\" + end_delim;";
"    elseif (c == \"!\")";
"      comment = 1;";
"      s = start_delim + \"!\";";
"      e = end_delim;";
"    else";
"      s = start_delim;";
"      e = end_delim;";
"    endif";
"";
"    content = line[1..i - 1];";
"    rest = line[i + length(s)..$];";
"";
"    /* look for an ending delimiter */";
"    if (!(j = rest:index(e)) && comment)";
"      /* no delimiter! but we're inside a comment */";
"      code = {@code, tostr(\"output = {@output, \", toliteral(content), \"};\")};";
"      in_comment = 1;";
"      line = \"\";";
"      continue;";
"    elseif (!j)";
"      /* no delimiter! */";
"      code = {@code, tostr(\"output = {@output, \", toliteral(line), \", \", tag_count, \"};\")};";
"      tag_count = 0;";
"      line = \"\";";
"      continue;";
"    endif";
"";
"    /* make j relative to the beginning of the line */";
"    j = j + i + length(s) - 1;";
"";
"    /* parse the tag */";
"    tag = original_tag = line[i + length(s)..j - 1]:trim();";
"    tag_list = original_tag_list = tag != \".\" ? tag:split(\".\") | {\".\"};";
"";
"    code = {@code, tostr(\"output = {@output, \", toliteral(content), \"};\")};";
"";
"    line = line[j + length(e)..$];";
"";
"    if (comment)";
"      tag_count = tag_count + 1;";
"";
"    elseif (include_partial)";
"      had_partial = 1;";
"      code = {@code, tostr(\"verb = `this:(\\\"\", original_tag, \"\\\")(@stack) ! E_VERBNF => {}';\")};";
"      code = {@code, \"output = {@output, verb};\"};";
"      tag_count = tag_count + 1;";
"";
"    elseif (set_delimiters)";
"      {start_delim, end_delim} = original_tag:split();";
"      tag_count = tag_count + 1;";
"";
"    elseif (start_new_context)";
"      /* if all parts succeed, consider the tag truthy */";
"      /* always increase the stack depth so that the end-tag pops the correct number of frames off */";
"      tag_stack = {tag, @tag_stack};";
"      if ((l = length(original_tag_list)) > 1)";
"        code = {@code, \"failed = 0;\"};";
"        tag = original_tag_list[1];";
"        code = {@code, tostr(\"if (top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE')\")};";
"        code = {@code, \"stack = {stack[1]:merge(typeof(top) == MAP ? top | []), @stack};\"};";
"        code = {@code, \"else\"};";
"        code = {@code, \"stack = {[], @stack}; failed = 1;\"};";
"        code = {@code, \"endif\"};";
"        for tag in (original_tag_list[2..$ - 1])";
"          code = {@code, tostr(\"if (top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE')\")};";
"          code = {@code, \"stack = {typeof(top) == MAP ? top | [], @stack};\"};";
"          code = {@code, \"else\"};";
"          code = {@code, \"stack = {[], @stack}; failed = 1;\"};";
"          code = {@code, \"endif\"};";
"        endfor";
"        tag = original_tag_list[$];";
"        code = {@code, tostr(\"if (!failed && (top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE'))\")};";
"        code = {@code, \"for item in (typeof(top) == LIST ? top | {top})\"};";
"        code = {@code, \"ticks_left() < 10000 || seconds_left() < 2 && suspend(0);\"};";
"        code = {@code, \"stack = {typeof(item) == MAP ? item | [\\\".\\\" -> item], @stack};\"};";
"      else";
"        tag = original_tag_list[1];";
"        code = {@code, tostr(\"if (top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE')\")};";
"        code = {@code, \"for item in (typeof(top) == LIST ? top | {top})\"};";
"        code = {@code, \"ticks_left() < 10000 || seconds_left() < 2 && suspend(0);\"};";
"        code = {@code, \"stack = {stack[1]:merge(typeof(item) == MAP ? item | [\\\".\\\" -> item]), @stack};\"};";
"      endif";
"      tag_count = tag_count + 1;";
"";
"    elseif (start_new_inverted_context)";
"      /* if any part fails, consider the tag falsey */";
"      /* always increase the stack depth so that the end-tag pops the correct number of frames off */";
"      tag_stack = {tag, @tag_stack};";
"      if ((l = length(original_tag_list)) > 1)";
"        code = {@code, \"failed = 0;\"};";
"        tag = original_tag_list[1];";
"        code = {@code, tostr(\"if (top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE')\")};";
"        code = {@code, \"stack = {stack[1]:merge(typeof(top) == MAP ? top | []), @stack};\"};";
"        code = {@code, \"else\"};";
"        code = {@code, \"stack = {[], @stack}; failed = 1;\"};";
"        code = {@code, \"endif\"};";
"        for tag in (original_tag_list[2..$ - 1])";
"          code = {@code, tostr(\"if (top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE')\")};";
"          code = {@code, \"stack = {typeof(top) == MAP ? top | [], @stack};\"};";
"          code = {@code, \"else\"};";
"          code = {@code, \"stack = {[], @stack}; failed = 1;\"};";
"          code = {@code, \"endif\"};";
"        endfor";
"        tag = original_tag_list[$];";
"        code = {@code, tostr(\"if (failed || !(top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE'))\")};";
"        code = {@code, \"for item in ({\\\"\\\"})\"};";
"        code = {@code, \"ticks_left() < 10000 || seconds_left() < 2 && suspend(0);\"};";
"        code = {@code, \"stack = {typeof(item) == MAP ? item | [\\\".\\\" -> item], @stack};\"};";
"      else";
"        tag = original_tag_list[1];";
"        code = {@code, tostr(\"if (!(top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE'))\")};";
"        code = {@code, \"for item in ({\\\"\\\"})\"};";
"        code = {@code, \"ticks_left() < 10000 || seconds_left() < 2 && suspend(0);\"};";
"        code = {@code, \"stack = {stack[1]:merge(typeof(item) == MAP ? item | [\\\".\\\" -> item]), @stack};\"};";
"      endif";
"      tag_count = tag_count + 1;";
"";
"    elseif (end_context)";
"      if (!tag_stack)";
"        return {0, {tostr(\"Line \", linec, \":  dangling end tag:  \", tag)}};";
"      endif";
"      {top, @tag_stack} = tag_stack;";
"      if (top != tag)";
"        return {0, {tostr(\"Line \", linec, \":  mismatched end tag:  \", tag)}};";
"      endif";
"      code = {@code, \"stack = stack[2..$];\", \"endfor\", \"endif\"};";
"      if ((l = length(original_tag_list)) > 1)";
"        code = {@code, tostr(\"stack = stack[\", l, \"..$];\")};";
"      endif";
"      tag_count = tag_count + 1;";
"";
"    else";
"      if ((l = length(original_tag_list)) > 1)";
"        for tag in (original_tag_list[1..$ - 1])";
"          code = {@code, tostr(\"top = `stack[1][\\\"\", tag, \"\\\"] ! E_RANGE';\")};";
"          code = {@code, \"stack = {typeof(top) == MAP ? top | [], @stack};\"};";
"        endfor";
"      endif";
"      if (!original_tag_list)";
"        return {0, {tostr(\"Line \", linec, \":  empty tag\")}};";
"      endif";
"      tag = original_tag_list[$];";
"      if (escaped)";
"        code = {@code, tostr(\"output = {@output, strsub(strsub(strsub(strsub(\", \"`tostr(stack[1][\\\"\", tag, \"\\\"]) ! E_RANGE => \\\"\\\"'\", \", \\\"&\\\", \\\"&amp;\\\"), \\\"<\\\", \\\"&lt;\\\"), \\\">\\\", \\\"&gt;\\\"), \\\"\\\\\\\"\\\", \\\"&quot;\\\")};\")};";
"      else";
"        code = {@code, tostr(\"output = {@output, `tostr(stack[1][\\\"\", tag, \"\\\"]) ! E_RANGE => \\\"\\\"'};\")};";
"      endif";
"      if (l > 1)";
"        code = {@code, tostr(\"stack = stack[\", l, \"..$];\")};";
"      endif";
"      tag_count = tag_count + 1;";
"";
"    endif";
"";
"  endwhile";
"";
"  /* add line terminator */";
"  if (!in_comment && tag_count)";
"    code = {@code, tostr(\"output = {@output, \", tag_count, \"};\")};";
"  endif";
"";
"endfor";
"";
"if (tag_stack)";
"  return {0, {tostr(\"Line \", linec, \":  missing end tag:  \", tag_stack[1])}};";
"endif";
"";
"/* Clean up and render.";
" * `0' terminates lines of original content _without_ tags, otherwise";
" * the number indicates the number of tags in the line of original";
" * content.  Lists hold partial content, and must be indented.";
" */";
"code = {@code, \"out = {}; acc = {}; indent = \\\"\\\";\"};";
"code = {@code, \"while (output)\"};";
"code = {@code, \"{line, @output} = output;\"};";
"code = {@code, \"ticks_left() < 10000 || seconds_left() < 2 && suspend(0);\"};";
"code = {@code, \"if (typeof(line) == LIST)\"};";
"if (had_partial)";
"  code = {@code, \"if (lines = line)\"};";
"  code = {@code, \"if (length(lines) > 1)\"};";
"  code = {@code, \"temp = {lines[1], 0};\"};";
"  code = {@code, \"for line in (lines[2..$ - 1])\"};";
"  code = {@code, \"temp = {@temp, indent + line, 0};\"};";
"  code = {@code, \"endfor\"};";
"  code = {@code, \"temp = {@temp, indent + lines[$]};\"};";
"  code = {@code, \"output = {@temp, @output};\"};";
"  code = {@code, \"else\"};";
"  code = {@code, \"output = {lines[1], @output};\"};";
"  code = {@code, \"endif\"};";
"  code = {@code, \"endif\"};";
"endif";
"code = {@code, \"elseif (typeof(line) == INT)\"};";
"code = {@code, \"if (line > 0)\"};";
"code = {@code, \"if (match(acc = tostr(@acc), \\\"[^ ]\\\"))\"};";
"code = {@code, \"out = {@out, acc};\"};";
"code = {@code, \"endif\"};";
"code = {@code, \"else\"};";
"code = {@code, \"out = {@out, tostr(@acc)};\"};";
"code = {@code, \"endif\"};";
"code = {@code, \"acc = {};\"};";
"if (had_partial)";
"  code = {@code, \"indent = \\\"\\\";\"};";
"endif";
"code = {@code, \"else\"};";
"if (had_partial)";
"  code = {@code, \"if (!match(line, \\\"[^ ]\\\"))\"};";
"  code = {@code, \"indent = line;\"};";
"  code = {@code, \"endif\"};";
"endif";
"code = {@code, \"acc = {@acc, line};\"};";
"code = {@code, \"endif\"};";
"code = {@code, \"endwhile\"};";
"code = {@code, \"return out;\"};";
"";
"return {1, code};";
"";
"chunk_length:331";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:D953F0592C90A9BFFA80F4BA168484FAD6A98E5E";
"-=-=-mxyzptlk-=-=-";
.
#117:0
$restrict_to_caller($system, "authenticate");
if (length(args) == 2)
{name, password} = args;
for player in (children($authenticatable))
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (name == player.name)
if ($identity.utilities:verify_hashed_password(password, player.hashed_password))
return player;
endif
endif
endfor
endif
return $failed_match;
return;
"$restrict_to_caller($system, \"authenticate\");";
"";
"if (length(args) == 2)";
"  {name, password} = args;";
"  for player in (children($authenticatable))";
"    ticks_left() < 10000 || seconds_left() < 2 && suspend(0);";
"    if (name == player.name)";
"      if ($identity.utilities:verify_hashed_password(password, player.hashed_password))";
"        return player;";
"      endif";
"    endif";
"  endfor";
"endif";
"";
"return $failed_match;";
"";
"chunk_length:15";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:CDEDBE61D3FCD123CEA0CFD54FE546F9150ABC83";
"-=-=-mxyzptlk-=-=-";
.
#118:0
if (player != this)
notify(player, "I couldn't understand that.");
return;
endif
first_time = !this.hashed_password;
if (!first_time)
notify(player, "To change your password, first specify your old password, and then specify and confirm your new password.");
else
notify(player, "To set your password, specify and confirm your password.");
endif
try
set_connection_option(player, "binary", 1);
set_connection_option(player, "hold-input", 1);
set_connection_option(player, "client-echo", 0);
if (!first_time)
notify(player, "          Old Password: ");
while (!(((old_password = read()) && (old_password = decode_binary(old_password))) && (typeof(old_password = old_password[1]) == STR)))
endwhile
notify(player, "~0A~0D");
endif
notify(player, "          New Password: ");
while (!(((new_password = read()) && (new_password = decode_binary(new_password))) && (typeof(new_password = new_password[1]) == STR)))
endwhile
notify(player, "~0A~0D");
notify(player, "  Confirm New Password: ");
while (!(((confirm_password = read()) && (confirm_password = decode_binary(confirm_password))) && (typeof(confirm_password = confirm_password[1]) == STR)))
endwhile
notify(player, "~0A~0D");
finally
set_connection_option(player, "binary", 0);
set_connection_option(player, "hold-input", 0);
set_connection_option(player, "client-echo", 1);
endtry
utilities = $lookup("utilities");
if (this.hashed_password && (!utilities:verify_hashed_password(old_password, this.hashed_password)))
notify(player, tostr("Old password is incorrect.  Password not ", first_time ? "set" | "changed", "."));
return;
endif
if (new_password != confirm_password)
notify(player, tostr("Password and confirmation do not match.  Password not ", first_time ? "set" | "changed", "."));
return;
endif
this.hashed_password = utilities:hash_password(new_password);
notify(player, tostr("Password ", first_time ? "set" | "changed", "."));
return;
"if (player != this)";
"  notify(player, \"I couldn't understand that.\");";
"  return;";
"endif";
"";
"first_time = !this.hashed_password;";
"";
"if (!first_time)";
"  notify(player, \"To change your password, first specify your old password, and then specify and confirm your new password.\");";
"else";
"  notify(player, \"To set your password, specify and confirm your password.\");";
"endif";
"";
"try";
"  set_connection_option(player, \"binary\", 1);";
"  set_connection_option(player, \"hold-input\", 1);";
"  set_connection_option(player, \"client-echo\", 0);";
"";
"  /* when reading lines, discard telnet commands and empty lines */";
"";
"  if (!first_time)";
"    notify(player, \"          Old Password: \");";
"    while (!((old_password = read()) && (old_password = decode_binary(old_password)) && (typeof(old_password = old_password[1]) == STR)))";
"    endwhile";
"    notify(player, \"~0A~0D\");";
"  endif";
"";
"  notify(player, \"          New Password: \");";
"  while (!((new_password = read()) && (new_password = decode_binary(new_password)) && (typeof(new_password = new_password[1]) == STR)))";
"  endwhile";
"  notify(player, \"~0A~0D\");";
"";
"  notify(player, \"  Confirm New Password: \");";
"  while (!((confirm_password = read()) && (confirm_password = decode_binary(confirm_password)) && (typeof(confirm_password = confirm_password[1]) == STR)))";
"  endwhile";
"  notify(player, \"~0A~0D\");";
"";
"finally";
"  set_connection_option(player, \"binary\", 0);";
"  set_connection_option(player, \"hold-input\", 0);";
"  set_connection_option(player, \"client-echo\", 1);";
"endtry";
"";
"utilities = $lookup(\"utilities\");";
"";
"if (this.hashed_password && !utilities:verify_hashed_password(old_password, this.hashed_password))";
"  notify(player, tostr(\"Old password is incorrect.  Password not \", (first_time ? \"set\" | \"changed\"), \".\" ));";
"  return;";
"endif";
"";
"if (new_password != confirm_password)";
"  notify(player, tostr(\"Password and confirmation do not match.  Password not \", (first_time ? \"set\" | \"changed\"), \".\" ));";
"  return;";
"endif";
"";
"this.hashed_password = utilities:hash_password(new_password);";
"";
"notify(player, tostr(\"Password \", (first_time ? \"set\" | \"changed\"), \".\" ));";
"";
"chunk_length:58";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:8DBF0ACBC439BF88839CCEDB52B304930BF3BCCB";
"-=-=-mxyzptlk-=-=-";
.
#119:0
{password, hashed_password} = args;
try
algo = hashed_password["algo"];
salt = hashed_password["salt"];
hash = hashed_password["hash"];
except (E_RANGE)
raise(E_INVARG, "Invalid hashed password");
endtry
((algo && salt) && hash) || raise(E_INVARG, "Invalid hashed password");
(((typeof(algo) == STR) && (typeof(salt) == STR)) && (typeof(hash) == STR)) || raise(E_INVARG, "Invalid hashed password");
(algo in {"sha256"}) || raise(E_INVARG, "Unsupported algo");
new_hash = string_hash(salt + password, algo);
if ((length = length(new_hash)) != length(hash))
return 0;
endif
count = 0;
for i in [1..length]
count = ((new_hash[i] == hash[i]) ? 1 | 0) + count;
endfor
return length == count;
return;
"{password, hashed_password} = args;";
"try";
"  algo = hashed_password[\"algo\"];";
"  salt = hashed_password[\"salt\"];";
"  hash = hashed_password[\"hash\"];";
"except (E_RANGE)";
"  raise(E_INVARG, \"Invalid hashed password\");";
"endtry";
"algo && salt && hash || raise(E_INVARG, \"Invalid hashed password\");";
"typeof(algo) == STR && typeof(salt) == STR && typeof(hash) == STR || raise(E_INVARG, \"Invalid hashed password\");";
"algo in {\"sha256\"} || raise(E_INVARG, \"Unsupported algo\");";
"/* absolutely use a *constant time* comparison to frustrate timing attacks */";
"new_hash = string_hash(salt + password, algo);";
"if ((length = length(new_hash)) != length(hash))";
"  return 0;";
"endif";
"count = 0;";
"for i in [1..length]";
"  count = (new_hash[i] == hash[i] ? 1 | 0) + count;";
"endfor";
"return length == count;";
"";
"chunk_length:21";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:41112376E5760A2247C86287362A042A8FEC11D9";
"-=-=-mxyzptlk-=-=-";
.
#119:1
{password} = args;
algo = "sha256";
salt = string_hash(tostr(random(), time()), algo);
hash = string_hash(salt + password, algo);
return ["algo" -> algo, "salt" -> salt, "hash" -> hash];
return;
"{password} = args;";
"algo = \"sha256\";";
"salt = string_hash(tostr(random(), time()), algo);";
"hash = string_hash(salt + password, algo);";
"return [\"algo\" -> algo, \"salt\" -> salt, \"hash\" -> hash];";
"";
"chunk_length:5";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:15DD175E1035003708BEFB2AF757479D9FA8D806";
"-=-=-mxyzptlk-=-=-";
.
#124:0
{target} = args;
set_task_perms(caller_perms());
delim = ("match_verb" == verb) ? ":" | ".";
if (i = rindex(target, delim))
if ((o = this:match_object(target[1..i - 1])) != $failed_match)
return {o, target[i + 1..$]};
endif
endif
return {$failed_match, ""};
return;
"{target} = args;";
"";
"set_task_perms(caller_perms());";
"";
"delim = (\"match_verb\" == verb) ? \":\" | \".\";";
"";
"if ((i = rindex(target, delim)))";
"  if ((o = this:match_object(target[1..i - 1])) != $failed_match)";
"    return {o, target[i + 1..$]};";
"  endif";
"endif";
"";
"return {$failed_match, \"\"};";
"";
"chunk_length:13";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:0C65E4074D90C393874003C18119666DE152059E";
"-=-=-mxyzptlk-=-=-";
.
#124:1
{target} = args;
set_task_perms(cp = caller_perms());
ok = (cp == player) || cp.wizard;
if (ok && ("me" == target))
return player;
elseif (ok && ("here" == target))
return player.location;
elseif ((ok && (`v = player.alt_bindings[target] ! E_RANGE' != E_RANGE)) && `valid(v) ! E_TYPE')
return v;
elseif (m = match(target, "^%(#[0-9]+%|%$[a-z0-9_%.]+%)$"))
if (m[4][m[3][1][1]] == "$")
try
o = $system;
s = m[4][m[3][1][1] + 1..m[3][1][2]] + ".";
while (x = index(s, "."))
o = o.(s[1..x - 1]);
s = s[x + 1..$];
endwhile
except ex (E_RANGE, E_PROPNF)
return $failed_match;
endtry
elseif (m[4][m[3][1][1]] == "#")
o = toobj(m[4][m[3][1][1]..m[3][1][2]]);
endif
if (!valid(o))
return $failed_match;
endif
return o;
endif
return $failed_match;
return;
"{target} = args;";
"";
"/* The targets \"me\" and \"here\", and values from the player's bindings";
" * are only accessible if the caller is the player or is a wizard.";
" */";
"";
"set_task_perms((cp = caller_perms()));";
"";
"ok = (cp == player) || cp.wizard;";
"";
"if (ok && \"me\" == target)";
"  return player;";
"elseif (ok && \"here\" == target)";
"  return player.location;";
"elseif (ok && `v = player.alt_bindings[target] ! E_RANGE' != E_RANGE && `valid(v) ! E_TYPE')";
"  return v;";
"elseif (m = match(target, \"^%(#[0-9]+%|%$[a-z0-9_%.]+%)$\"))";
"  if (m[4][m[3][1][1]] == \"$\")";
"    try";
"      o = $system;";
"      s = m[4][m[3][1][1] + 1..m[3][1][2]] + \".\";";
"      while (x = index(s, \".\"))";
"        o = o.(s[1..x - 1]);";
"        s = s[x + 1..$];";
"      endwhile";
"    except ex (E_RANGE, E_PROPNF)";
"      return $failed_match;";
"    endtry";
"  elseif (m[4][m[3][1][1]] == \"#\")";
"    o = toobj(m[4][m[3][1][1]..m[3][1][2]]);";
"  endif";
"  if (!valid(o))";
"    return $failed_match;";
"  endif";
"  return o;";
"endif";
"";
"return $failed_match;";
"";
"chunk_length:38";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:299D11796815D9977AB762B7C469ABB17B4058BA";
"-=-=-mxyzptlk-=-=-";
.
#124:2
{o, v} = args;
set_task_perms(caller_perms());
info_function = (verb == "_player_controls_verb") ? "verb_info" | "property_info";
return player.wizard || (player == `call_function(info_function, o, v)[1] ! ANY');
.
#124:3
{o} = args;
set_task_perms(caller_perms());
return player.wizard || (player == `o.owner ! ANY');
.
#124:4
{STR} = args;
if (r = match(STR, "%( +[+-][a-z]+%)+ *$"))
cmd = STR[^..r[1] - 1];
tail = STR[r[1] + 1..$]:split();
return {cmd, @tail};
else
return {STR};
endif
return;
"{str} = args;";
"";
"if ((r = match(str, \"%( +[+-][a-z]+%)+ *$\")))";
"  cmd = str[^..r[1] - 1];";
"  tail = str[r[1] + 1..$]:split();";
"  return {cmd, @tail};";
"else";
"  return {str};";
"endif";
"";
"chunk_length:9";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E9E120C913299D9B89F717C31631D48503BFF77D";
"-=-=-mxyzptlk-=-=-";
.
#125:0
callers() && raise(E_PERM, "Server task");
set_task_perms(player);
"very simple, really primitive matching";
if (((prepstr == "with") && (iobjstr == "$composed")) && `valid($composed) ! ANY')
if ((verb in {"@install", "@uninstall", "@list"}) && `respond_to($composed, verb) ! ANY')
return $composed:(verb)(@args);
endif
endif
if (((prepstr == "with") && (iobjstr == "$unit.test")) && `valid($unit.test) ! ANY')
if ((verb in {"@test"}) && `respond_to($unit.test, verb) ! ANY')
return $unit.test:(verb)(@args);
endif
endif
notify(player, "I couldn't understand that.");
.
#125:1
$permit("wizard", "owner");
notify(this, tostr(@args));
.
#125:2
boot_player(player);
.
#126:0
$private();
set_task_perms(caller_perms());
{prog} = args;
t = $plastic.tokenizer_proto:create(prog);
p = $plastic.parser_proto:create(t);
try
statements = p:parse_all();
except ex ("Syntax error")
return {0, t.row, t.column, {ex[2]}, t, p};
endtry
return {1, statements, t, p};
return;
"$private();";
"";
"set_task_perms(caller_perms());";
"";
"{prog} = args;";
"";
"t = $plastic.tokenizer_proto:create(prog);";
"p = $plastic.parser_proto:create(t);";
"";
"try";
"  statements = p:parse_all();";
"except ex (\"Syntax error\")";
"  return {0, t.row, t.column, {ex[2]}, t, p};";
"endtry";
"";
"return {1, statements, t, p};";
"";
"chunk_length:16";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:72D03E5248B95E4E3428EC34BD95D40452FD921C";
"-=-=-mxyzptlk-=-=-";
.
#126:1
if (player != this)
notify(player, "I couldn't understand that.");
return;
elseif (!player.programmer)
notify(player, "You need to be a programmer to evaluate code.");
return;
endif
set_task_perms(player);
$grant($core.change_owner_permit_proto:create_for_subject($plastic.owner));
try
prog = {argstr};
set_connection_option(player, "hold-input", 1);
while (((({retval, @rest} = this:_parse(prog)) && (!retval)) && ({row, column, errors, t, p} = rest)) && (row > length(prog)))
if (argstr)
player:tell("Enter lines of code.  Enter a single period (\".\") to abort editing.");
argstr = 0;
endif
if ((line = read(player)) == ".")
player:tell("(aborted)");
return;
endif
prog = {@prog, line};
endwhile
finally
set_connection_option(player, "hold-input", 0);
endtry
if (!retval)
for error in (errors)
player:tell("Line ", row, ":  ", error);
endfor
return;
endif
{statements, t, p} = rest;
if ((length(statements) == 1) && (statements[1].type != "statement"))
ret = create($plastic.control_flow_statement_proto, 1);
ret.id = "return";
ret.type = "statement";
ret.first = statements[1];
statements = {ret};
endif
if (statements && (!((statements[$].type == "statement") && (statements[$].id == "return"))))
ret = create($plastic.control_flow_statement_proto, 1);
ret.id = "return";
ret.type = "statement";
ret.first = 0;
statements = {@statements, ret};
endif
variables = [];
for variable in ($plastic.utilities:match(statements, ["type" -> "variable"]))
id = variable.id;
if ((((id[1] != "_") && (id[1] != "$")) && (`variables[id] ! E_RANGE' == E_RANGE)) && (!(variable.id in $plastic.compiler.builtin_names)))
variables[id] = variable;
endif
endfor
variables = variables:values();
ret = create($plastic.bracket_operator_proto, 1);
ret.id = "[";
ret.type = "unary";
ret.value = {};
for variable in (variables)
key = create($plastic.literal_proto, 1);
key.type = "string";
key.value = variable.id;
value = create($plastic.error_catching_operator_proto, 1);
value.id = "!!";
value.type = "binary";
value.first = variable;
value.second = {create($plastic.name_proto, 1)};
value.second[1].id = "ANY";
value.second[1].type = "keyword";
value.second[1].value = "ANY";
ret.value = {@ret.value, {key, value}};
endfor
for statement in ($plastic.utilities:match(statements, ["type" -> "statement", "id" -> "return"]))
if (statement.first == 0)
statement.first = create($plastic.literal_proto, 1);
statement.first.type = "number";
statement.first.value = 0;
endif
first = create($plastic.brace_operator_proto, 1);
first.id = "{";
first.type = "unary";
first.value = {statement.first, ret};
statement.first = first;
endfor
prefix = {};
if (variables)
prefix = create($plastic.assignment_operator_proto, 1);
prefix.id = "=";
prefix.type = "binary";
prefix.value = "=";
prefix.first = create($plastic.name_proto, 1);
prefix.first.id = "__";
prefix.first.type = "variable";
prefix.first.value = "__";
prefix.second = create($plastic.property_selector_operator_proto, 1);
prefix.second.id = ".";
prefix.second.type = "binary";
prefix.second.first = create($plastic.name_proto, 1);
prefix.second.first.id = "player";
prefix.second.first.type = "variable";
prefix.second.first.value = "player";
prefix.second.second = create($plastic.name_proto, 1);
prefix.second.second.id = "alt_bindings";
prefix.second.second.type = "identifier";
prefix.second.second.value = "alt_bindings";
prefix = {prefix};
endif
for variable in (variables)
k = variable.id;
if (`this.alt_bindings[k] ! E_RANGE' == E_RANGE)
continue;
endif
assignment = create($plastic.assignment_operator_proto, 1);
assignment.id = "=";
assignment.type = "binary";
assignment.value = "=";
assignment.first = create($plastic.name_proto, 1);
assignment.first.id = k;
assignment.first.type = "variable";
assignment.first.value = k;
assignment.second = create($plastic.bracket_operator_proto, 1);
assignment.second.id = "[";
assignment.second.type = "binary";
assignment.second.first = create($plastic.name_proto, 1);
assignment.second.first.id = "__";
assignment.second.first.type = "variable";
assignment.second.first.value = "__";
assignment.second.second = create($plastic.literal_proto, 1);
assignment.second.second.id = k;
assignment.second.second.type = "string";
assignment.second.second.value = k;
prefix = {@prefix, assignment};
endfor
statements = {@prefix, @statements};
compiler = create($plastic.compiler, 1);
source = {};
for statement in (statements)
if (statement.type != "statement")
source = {@source, compiler:p(statement), ";"};
else
source = {@source, @compiler:p(statement)};
endif
endfor
if (!source)
source = {""};
endif
{code, retval} = eval(@source);
if (code)
variables = [];
if (typeof(retval) == LIST)
{retval, ?variables = []} = retval;
endif
variables["_"] = retval;
player.alt_bindings = player.alt_bindings:merge(variables);
t = typeof(retval);
if (((t == OBJ) || (t == ANON)) && valid(retval))
player:tell(toliteral(retval), " ", toliteral(retval.name));
elseif (t == ERR)
player:tell(toliteral(retval), " ", toliteral(tostr(retval)));
else
player:tell(toliteral(retval));
endif
else
for line in (retval)
player:tell(line);
endfor
endif
return;
"if (player != this)";
"  notify(player, \"I couldn't understand that.\");";
"  return;";
"elseif (!player.programmer)";
"  notify(player, \"You need to be a programmer to evaluate code.\");";
"  return;";
"endif";
"";
"set_task_perms(player);";
"";
"/* permit $plastic to change the ownership of parser tree objects */";
"$grant($core.change_owner_permit_proto:create_for_subject($plastic.owner));";
"";
"/* The strategy is to add lines until we either have a chunk of code";
" * that parses without error (in which case we compile it and evaluate";
" * the result) or is uncorrectable (in which case we output the syntax";
" * errors).  \"Uncorrectable\" means that adding more lines will not";
" * result in a valid chunk of code.";
"*/";
"";
"try";
"  prog = {argstr};";
"";
"  set_connection_option(player, \"hold-input\", 1);";
"";
"  while (({retval, @rest} = this:_parse(prog)) && !retval &&";
"         ({row, column, errors, t, p} = rest) &&";
"         row > length(prog))";
"    if (argstr)";
"      player:tell(\"Enter lines of code.  Enter a single period (\\\".\\\") to abort editing.\");";
"      argstr = 0;";
"    endif";
"    if ((line = read(player)) == \".\")";
"      player:tell(\"(aborted)\");";
"      return;";
"    endif";
"    prog = {@prog, line};";
"  endwhile";
"finally";
"  set_connection_option(player, \"hold-input\", 0);";
"endtry";
"";
"if (!retval)";
"  for error in (errors)";
"    player:tell(\"Line \", row, \":  \", error);";
"  endfor";
"  return;";
"endif";
"";
"{statements, t, p} = rest;";
"";
"/* if it's not a statement, make it a return statement */";
"if (length(statements) == 1 && statements[1].type != \"statement\")";
"  ret = create($plastic.control_flow_statement_proto, 1);";
"  ret.id = \"return\";";
"  ret.type = \"statement\";";
"  ret.first = statements[1];";
"  statements = {ret};";
"endif";
"";
"/* if it doesn't end in a return statement, tack on a return statement */";
"if (statements && !(statements[$].type == \"statement\" && statements[$].id == \"return\"))";
"  ret = create($plastic.control_flow_statement_proto, 1);";
"  ret.id = \"return\";";
"  ret.type = \"statement\";";
"  ret.first = 0;";
"  statements = {@statements, ret};";
"endif";
"";
"/* select the variables */";
"variables = [];";
"for variable in ($plastic.utilities:match(statements, [\"type\" -> \"variable\"]))";
"  id = variable.id;";
"  if (id[1] != \"_\" && id[1] != \"$\" && `variables[id] ! E_RANGE' == E_RANGE && !(variable.id in $plastic.compiler.builtin_names))";
"    variables[id] = variable;";
"  endif";
"endfor";
"variables = variables:values();";
"";
"/* build code to return the variables */";
"ret = create($plastic.bracket_operator_proto, 1);";
"ret.id = \"[\";";
"ret.type = \"unary\";";
"ret.value = {};";
"for variable in (variables)";
"  key = create($plastic.literal_proto, 1);";
"  key.type = \"string\";";
"  key.value = variable.id;";
"  value = create($plastic.error_catching_operator_proto, 1);";
"  value.id = \"!!\";";
"  value.type = \"binary\";";
"  value.first = variable;";
"  value.second = {create($plastic.name_proto, 1)};";
"  value.second[1].id = \"ANY\";";
"  value.second[1].type = \"keyword\";";
"  value.second[1].value = \"ANY\";";
"  ret.value = {@ret.value, {key, value}};";
"endfor";
"";
"/* look for and fix up return statements */";
"for statement in ($plastic.utilities:match(statements, [\"type\" -> \"statement\", \"id\" -> \"return\"]))";
"  if (statement.first == 0)";
"    statement.first = create($plastic.literal_proto, 1);";
"    statement.first.type = \"number\";";
"    statement.first.value = 0;";
"  endif";
"  first = create($plastic.brace_operator_proto, 1);";
"  first.id = \"{\";";
"  first.type = \"unary\";";
"  first.value = {statement.first, ret};";
"  statement.first = first;";
"endfor";
"";
"/* prefix with bindings */";
"prefix = {};";
"";
"if (variables)";
"  prefix = create($plastic.assignment_operator_proto, 1);";
"  prefix.id = \"=\";";
"  prefix.type = \"binary\";";
"  prefix.value = \"=\";";
"  prefix.first = create($plastic.name_proto, 1);";
"  prefix.first.id = \"__\";";
"  prefix.first.type = \"variable\";";
"  prefix.first.value = \"__\";";
"  prefix.second = create($plastic.property_selector_operator_proto, 1);";
"  prefix.second.id = \".\";";
"  prefix.second.type = \"binary\";";
"  prefix.second.first = create($plastic.name_proto, 1);";
"  prefix.second.first.id = \"player\";";
"  prefix.second.first.type = \"variable\";";
"  prefix.second.first.value = \"player\";";
"  prefix.second.second = create($plastic.name_proto, 1);";
"  prefix.second.second.id = \"alt_bindings\";";
"  prefix.second.second.type = \"identifier\";";
"  prefix.second.second.value = \"alt_bindings\";";
"  prefix = {prefix};";
"endif";
"";
"for variable in (variables)";
"  k = variable.id;";
"  if (`this.alt_bindings[k] ! E_RANGE' == E_RANGE)";
"    continue;";
"  endif";
"  assignment = create($plastic.assignment_operator_proto, 1);";
"  assignment.id = \"=\";";
"  assignment.type = \"binary\";";
"  assignment.value = \"=\";";
"  assignment.first = create($plastic.name_proto, 1);";
"  assignment.first.id = k;";
"  assignment.first.type = \"variable\";";
"  assignment.first.value = k;";
"  assignment.second = create($plastic.bracket_operator_proto, 1);";
"  assignment.second.id = \"[\";";
"  assignment.second.type = \"binary\";";
"  assignment.second.first = create($plastic.name_proto, 1);";
"  assignment.second.first.id = \"__\";";
"  assignment.second.first.type = \"variable\";";
"  assignment.second.first.value = \"__\";";
"  assignment.second.second = create($plastic.literal_proto, 1);";
"  assignment.second.second.id = k;";
"  assignment.second.second.type = \"string\";";
"  assignment.second.second.value = k;";
"  prefix = {@prefix, assignment};";
"endfor";
"";
"statements = {@prefix, @statements};";
"";
"/* generate the code to eval */";
"compiler = create($plastic.compiler, 1);";
"";
"source = {};";
"";
"for statement in (statements)";
"  if (statement.type != \"statement\")";
"    source = {@source, compiler:p(statement), \";\"};";
"  else";
"    source = {@source, @compiler:p(statement)};";
"  endif";
"endfor";
"";
"if (!source)";
"  source = {\"\"};";
"endif";
"";
"/* and evaluate...! */";
"{code, retval} = eval(@source);";
"";
"if (code)";
"  variables = [];";
"  if (typeof(retval) == LIST)";
"    {retval, ?variables = []} = retval;";
"  endif";
"";
"  variables[\"_\"] = retval;";
"";
"  player.alt_bindings = player.alt_bindings:merge(variables);";
"";
"  t = typeof(retval);";
"  if ((t == OBJ || t == ANON) && valid(retval))";
"    player:tell(toliteral(retval), \" \", toliteral(retval.name));";
"  elseif (t == ERR)";
"    player:tell(toliteral(retval), \" \", toliteral(tostr(retval)));";
"  else";
"    player:tell(toliteral(retval));";
"  endif";
"else";
"  for line in (retval)";
"    player:tell(line);";
"  endfor";
"endif";
"";
"chunk_length:211";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:26BA67CD480AF982E3FFF6B7BF7712B68FEAF1C5";
"-=-=-mxyzptlk-=-=-";
.
#126:2
if (player != this)
player:notify("I couldn't understand that.");
return;
elseif (!player.programmer)
player:notify("You need to be a programmer to do that.");
return;
endif
utilities = $lookup("player_utilities");
{o, v} = utilities:match_verb(argstr);
if (v && `vi = verb_info(o, v) ! E_VERBNF')
if (utilities:_player_controls_verb(o, v) || index(vi[2], "r"))
d = $verb_detail(o, v);
if (`d["content_type"] ! E_RANGE')
vc = verb_code(o, v);
else
vc = verb_code(o, v, 0, 1);
endif
if (verb == "@edit")
if (`d["content_type"] ! E_RANGE')
player:notify("Editing ", argstr);
player:notify("#$# edit name: ", argstr, " upload: @program ", argstr, " as ", d["content_type"]);
else
player:notify("Editing ", argstr);
player:notify("#$# edit name: ", argstr, " upload: @program ", argstr);
endif
endif
for i in (vc)
player:notify(i);
endfor
if (verb == "@edit")
player:notify(".");
endif
return;
else
player:notify("You don't have permission to do that.");
return;
endif
elseif (v)
player:notify("That verb doesn't exist.");
return;
endif
{o, p} = utilities:match_property(argstr);
if (p && `pi = property_info(o, p) ! E_PROPNF')
if (utilities:_player_controls_property(o, p) || index(pi[2], "r"))
v = o.(p);
if ((type = typeof(v)) == LIST)
for i in (v)
if (typeof(i) != STR)
type = -1;
break;
endif
endfor
endif
if (verb == "@edit")
if (type == LIST)
player:notify("Editing ", argstr);
player:notify("#$# edit name: ", argstr, " upload: @program ", argstr, " as list");
else
player:notify("Editing ", argstr);
player:notify("#$# edit name: ", argstr, " upload: @program ", argstr);
endif
endif
if (type != LIST)
v = {toliteral(v)};
endif
for i in (v)
player:notify(i);
endfor
if (verb == "@edit")
player:notify(".");
endif
return;
else
player:notify("You don't have permission to do that.");
return;
endif
elseif (p)
player:notify("That property doesn't exist.");
return;
endif
player:notify("I couldn't understand that.");
return;
"if (player != this)";
"  player:notify(\"I couldn't understand that.\");";
"  return;";
"elseif (!player.programmer)";
"  player:notify(\"You need to be a programmer to do that.\");";
"  return;";
"endif";
"";
"utilities = $lookup(\"player_utilities\");";
"";
"{o, v} = utilities:match_verb(argstr);";
"if (v && `vi = verb_info(o, v) ! E_VERBNF')";
"  if (utilities:_player_controls_verb(o, v) || index(vi[2], \"r\"))";
"    d = $verb_detail(o, v);";
"    if (`d[\"content_type\"] ! E_RANGE')";
"      vc = verb_code(o, v);";
"    else";
"      vc = verb_code(o, v, 0, 1);";
"    endif";
"    if (verb == \"@edit\")";
"      if (`d[\"content_type\"] ! E_RANGE')";
"        player:notify(\"Editing \", argstr);";
"        player:notify(\"#$# edit name: \", argstr, \" upload: @program \", argstr, \" as \", d[\"content_type\"]);";
"      else";
"        player:notify(\"Editing \", argstr);";
"        player:notify(\"#$# edit name: \", argstr, \" upload: @program \", argstr);";
"      endif";
"    endif";
"    for i in (vc)";
"      player:notify(i);";
"    endfor";
"    if (verb == \"@edit\")";
"      player:notify(\".\");";
"    endif";
"    return;";
"  else";
"    player:notify(\"You don't have permission to do that.\");";
"    return;";
"  endif";
"elseif (v)";
"  player:notify(\"That verb doesn't exist.\");";
"  return;";
"endif";
"";
"{o, p} = utilities:match_property(argstr);";
"if (p && `pi = property_info(o, p) ! E_PROPNF')";
"  if (utilities:_player_controls_property(o, p) || index(pi[2], \"r\"))";
"    v = o.(p);";
"    /* is it a list of strings? */";
"    if ((type = typeof(v)) == LIST)";
"      for i in (v)";
"        if (typeof(i) != STR)";
"          type = -1;";
"          break;";
"        endif";
"      endfor";
"    endif";
"    if (verb == \"@edit\")";
"      if (type == LIST)";
"        player:notify(\"Editing \", argstr);";
"        player:notify(\"#$# edit name: \", argstr, \" upload: @program \", argstr, \" as list\");";
"      else";
"        player:notify(\"Editing \", argstr);";
"        player:notify(\"#$# edit name: \", argstr, \" upload: @program \", argstr);";
"      endif";
"    endif";
"    if (type != LIST)";
"      v = {toliteral(v)};";
"    endif";
"    for i in (v)";
"      player:notify(i);";
"    endfor";
"    if (verb == \"@edit\")";
"      player:notify(\".\");";
"    endif";
"    return;";
"  else";
"    player:notify(\"You don't have permission to do that.\");";
"    return;";
"  endif";
"elseif (p)";
"  player:notify(\"That property doesn't exist.\");";
"  return;";
"endif";
"";
"player:notify(\"I couldn't understand that.\");";
"";
"chunk_length:86";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:9E3190397CF8BA52EAC3D1B9F599AA8A2ED4A87F";
"-=-=-mxyzptlk-=-=-";
.
#126:3
if (player != this)
player:notify("I couldn't understand that.");
return;
elseif (!player.programmer)
player:notify("You need to be a programmer to program.");
return;
endif
utilities = $lookup("player_utilities");
ll = {};
while ((l = read(player)) != ".")
ll = {@ll, l};
endwhile
{o, v} = utilities:match_verb(dobjstr);
if (v && `vi = verb_info(o, v) ! E_VERBNF')
if (utilities:_player_controls_verb(o, v) || index(vi[2], "w"))
if ((prepstr == "as") && iobjstr)
content_type = $_generate_content_type($_parse_content_type(iobjstr));
elseif (prepstr)
player:notify("I couldn't understand that.");
return;
endif
vd = $verb_detail(o, v);
if (`vd["sha1"] ! E_RANGE' == value_hash(ll, "sha1"))
player:notify("No change.  Nothing to do for ", dobjstr);
return;
endif
set_task_perms(player);
if (`content_type ! E_VARNF')
r = set_verb_code(o, v, ll, content_type);
else
r = set_verb_code(o, v, ll);
endif
if (!r)
player:notify("Programming succeeded for ", dobjstr);
else
player:notify("Programming failed for ", dobjstr);
for rr in (r)
player:notify(rr);
endfor
endif
return;
else
player:notify("You don't have permission to do that.");
return;
endif
elseif (v)
player:notify("That verb doesn't exist.");
return;
endif
{o, p} = utilities:match_property(dobjstr);
if (p && `pi = property_info(o, p) ! E_PROPNF')
if (utilities:_player_controls_property(o, p) || index(pi[2], "w"))
if ((prepstr == "as") && (iobjstr == "list"))
content_type = LIST;
elseif (prepstr)
player:notify("I couldn't understand that.");
return;
endif
set_task_perms(player);
if (`content_type ! E_VARNF')
o.(p) = ll;
else
r = eval(((dobjstr + " = ") + ll:join()) + ";");
endif
if (`r[1] ! E_VARNF => 1')
player:notify("Programming succeeded for ", dobjstr);
else
player:notify("Programming failed for ", dobjstr);
for rr in (r[2])
player:notify(rr);
endfor
endif
return;
else
player:notify("You don't have permission to do that.");
return;
endif
elseif (p)
player:notify("That property doesn't exist.");
return;
endif
player:notify("I couldn't understand that.");
return;
"if (player != this)";
"  player:notify(\"I couldn't understand that.\");";
"  return;";
"elseif (!player.programmer)";
"  player:notify(\"You need to be a programmer to program.\");";
"  return;";
"endif";
"";
"utilities = $lookup(\"player_utilities\");";
"";
"/* snarf lines early to avoid the flood of error messages */";
"ll = {};";
"while ((l = read(player)) != \".\")";
"  ll = {@ll, l};";
"endwhile";
"";
"{o, v} = utilities:match_verb(dobjstr);";
"if (v && `vi = verb_info(o, v) ! E_VERBNF')";
"  if (utilities:_player_controls_verb(o, v) || index(vi[2], \"w\"))";
"    if (prepstr == \"as\" && iobjstr)";
"      content_type = $_generate_content_type($_parse_content_type(iobjstr));";
"    elseif (prepstr)";
"      player:notify(\"I couldn't understand that.\");";
"      return;";
"    endif";
"";
"    vd = $verb_detail(o, v);";
"    if (`vd[\"sha1\"] ! E_RANGE' == value_hash(ll, \"sha1\"))";
"      player:notify(\"No change.  Nothing to do for \", dobjstr);";
"      return;";
"    endif";
"";
"    set_task_perms(player);";
"";
"    if (`content_type ! E_VARNF')";
"      r = set_verb_code(o, v, ll, content_type);";
"    else";
"      r = set_verb_code(o, v, ll);";
"    endif";
"";
"    if (!r)";
"      player:notify(\"Programming succeeded for \", dobjstr);";
"    else";
"      player:notify(\"Programming failed for \", dobjstr);";
"      for rr in (r)";
"        player:notify(rr);";
"      endfor";
"    endif";
"";
"    return;";
"";
"  else";
"    player:notify(\"You don't have permission to do that.\");";
"    return;";
"  endif";
"elseif (v)";
"  player:notify(\"That verb doesn't exist.\");";
"  return;";
"endif";
"";
"{o, p} = utilities:match_property(dobjstr);";
"if (p && `pi = property_info(o, p) ! E_PROPNF')";
"  if (utilities:_player_controls_property(o, p) || index(pi[2], \"w\"))";
"    if (prepstr == \"as\" && iobjstr == \"list\")";
"      content_type = LIST;";
"    elseif (prepstr)";
"      player:notify(\"I couldn't understand that.\");";
"      return;";
"    endif";
"";
"    set_task_perms(player);";
"";
"    if (`content_type ! E_VARNF')";
"      o.(p) = ll;";
"    else";
"      r = eval(dobjstr + \" = \" + ll:join() + \";\");";
"    endif";
"";
"    if (`r[1] ! E_VARNF => 1')";
"      player:notify(\"Programming succeeded for \", dobjstr);";
"    else";
"      player:notify(\"Programming failed for \", dobjstr);";
"      for rr in (r[2])";
"        player:notify(rr);";
"      endfor";
"    endif";
"";
"  return;";
"";
"  else";
"    player:notify(\"You don't have permission to do that.\");";
"    return;";
"  endif";
"elseif (p)";
"  player:notify(\"That property doesn't exist.\");";
"  return;";
"endif";
"";
"player:notify(\"I couldn't understand that.\");";
"";
"chunk_length:99";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:1C4EEFFC1C20EF733CE277B783006D6199A4BD5E";
"-=-=-mxyzptlk-=-=-";
.
#126:4
if (player != this)
player:notify("I couldn't understand that.");
return;
endif
all = 0;
tail = {};
utilities = $lookup("player_utilities");
if (!valid(dobj))
{dobjstr, @tail} = utilities:extract_tail(dobjstr);
dobj = utilities:match_object(dobjstr);
all = ("+all" in tail) && (!("-all" in tail));
endif
if (!valid(dobj))
player:notify("I couldn't understand that.");
return;
endif
if (!tail)
all = !(verbs(dobj) || properties(dobj));
endif
p = n = "";
dobj.r ? p = p + "r" | (n = n + "r");
dobj.w ? p = p + "w" | (n = n + "w");
dobj.f ? p = p + "f" | (n = n + "f");
dobj.a ? p = p + "a" | (n = n + "a");
t = {};
`is_player(dobj) ! E_TYPE' && (t = {@t, "player"});
dobj.programmer && (t = {@t, "programmer"});
dobj.wizard && (t = {@t, "wizard"});
t = t:join(", ");
player:notify("\"", dobj.name, "\" (", dobj, ")", p ? " +" | "", p, n ? " -" | "", n, " ", t);
player:notify("Parents: ", toliteral(parents(dobj)), ", ", "Children: ", toliteral(children(dobj)));
player:notify("Location: ", toliteral(dobj.location), ", ", "Contents: ", toliteral(dobj.contents));
player:notify("Owner: ", dobj.owner);
if (utilities:_player_controls_object(dobj) || dobj.r)
ancestors = all ? {dobj, @ancestors(dobj)} | {dobj};
for o in (ancestors)
if (utilities:_player_controls_object(o) || o.r)
for i, j in (verbs(o))
if (utilities:_player_controls_verb(o, j))
if ((dobj == o) && (1 == j))
player:notify();
player:notify("-- Verbs --");
elseif (1 == j)
player:notify();
player:notify("-- Verbs from \"", o.name, "\" (", o, ") --");
else
player:notify();
endif
l = {i};
vd = $verb_detail(o, j);
`vd["state"] == "dirty" ! E_RANGE' && (l = {@l, "[dirty]"});
`vd["content_type"] ! E_RANGE' && (l = {@l, vd["content_type"]});
player:notify(l:join(" "));
player:notify("  ", toliteral(verb_info(o, j)));
player:notify("  ", toliteral(verb_args(o, j)));
else
if (1 == j)
player:notify();
player:notify("-- Verbs from \"", o.name, "\" (", o, ") --");
else
player:notify();
endif
player:notify(i);
player:notify("  <<permission denied>>");
endif
endfor
else
player:notify();
player:notify("-- Verbs from \"", o.name, "\" (", o, ") --");
player:notify("  <<permission denied>>");
endif
endfor
for o in (ancestors)
if (utilities:_player_controls_object(o) || o.r)
for i, j in (properties(o))
if (utilities:_player_controls_property(dobj, i))
if ((dobj == o) && (1 == j))
player:notify();
player:notify("-- Properties --");
elseif (1 == j)
player:notify();
player:notify("-- Properties from \"", o.name, "\" (", o, ") --");
else
player:notify();
endif
l = {i};
is_clear_property(dobj, i) && (l = {@l, "[clear]"});
l = {@l, toliteral(dobj.(i))};
player:notify(l:join(" "));
player:notify("  " + toliteral(property_info(dobj, i)));
else
if (1 == j)
player:notify();
player:notify("-- Properties from \"", o.name, "\" (", o, ") --");
else
player:notify();
endif
player:notify(i);
player:notify("  <<permission denied>>");
endif
endfor
else
player:notify();
player:notify("-- Properties from \"", o.name, "\" (", o, ") --");
player:notify("  <<permission denied>>");
endif
endfor
endif
player:notify();
player:notify("(done)");
return;
"if (player != this)";
"  player:notify(\"I couldn't understand that.\");";
"  return;";
"endif";
"";
"all = 0;";
"tail = {};";
"";
"utilities = $lookup(\"player_utilities\");";
"";
"if (!valid(dobj))";
"  {dobjstr, @tail} = utilities:extract_tail(dobjstr);";
"  dobj = utilities:match_object(dobjstr);";
"  all = (\"+all\" in tail) && !(\"-all\" in tail);";
"endif";
"if (!valid(dobj))";
"  player:notify(\"I couldn't understand that.\");";
"  return;";
"endif";
"";
"/* Default to all detail if the object defines";
" * no verbs or properties and there is no tail.";
" */";
"if (!tail)";
"  all = !(verbs(dobj) || properties(dobj));";
"endif";
"";
"/* everybody can see general information about the object */";
"";
"p = n = \"\";";
"dobj.r ? (p = p + \"r\") | (n = n + \"r\");";
"dobj.w ? (p = p + \"w\") | (n = n + \"w\");";
"dobj.f ? (p = p + \"f\") | (n = n + \"f\");";
"dobj.a ? (p = p + \"a\") | (n = n + \"a\");";
"";
"t = {};";
"`is_player(dobj) ! E_TYPE' && (t = {@t, \"player\"});";
"dobj.programmer && (t = {@t, \"programmer\"});";
"dobj.wizard && (t = {@t, \"wizard\"});";
"t = t:join(\", \");";
"";
"player:notify(\"\\\"\", dobj.name, \"\\\" (\", dobj, \")\", (p ? \" +\" | \"\"), p, (n ? \" -\" | \"\"), n, \" \", t);";
"player:notify(\"Parents: \", toliteral(parents(dobj)), \", \", \"Children: \", toliteral(children(dobj)));";
"player:notify(\"Location: \", toliteral(dobj.location), \", \", \"Contents: \", toliteral(dobj.contents));";
"player:notify(\"Owner: \", dobj.owner);";
"";
"/* Only display the details if the object is specifically in the";
" * player's control or generally readable.  If the object or any";
" * of its ancestors are in control/readable, include a section for";
" * the object/ancestor.  If a verb/property is in the player's";
" * control or is readable, include details about the verb/";
" * property.";
" */";
"";
"if (utilities:_player_controls_object(dobj) || dobj.r)";
"  ancestors = all ? {dobj, @ancestors(dobj)} | {dobj};";
"";
"  for o in (ancestors)";
"    if (utilities:_player_controls_object(o) || o.r)";
"      for i, j in (verbs(o))";
"        if (utilities:_player_controls_verb(o, j))";
"          if (dobj == o && 1 == j)";
"            player:notify();";
"            player:notify(\"-- Verbs --\");";
"          elseif (1 == j)";
"            player:notify();";
"            player:notify(\"-- Verbs from \\\"\", o.name, \"\\\" (\", o, \") --\");";
"          else";
"            player:notify();";
"          endif";
"          l = {i};";
"          vd = $verb_detail(o, j);";
"          `vd[\"state\"] == \"dirty\" ! E_RANGE' && (l = {@l, \"[dirty]\"});";
"          `vd[\"content_type\"] ! E_RANGE' && (l = {@l, vd[\"content_type\"]});";
"          player:notify(l:join(\" \"));";
"          player:notify(\"  \", toliteral(verb_info(o, j)));";
"          player:notify(\"  \", toliteral(verb_args(o, j)));";
"        else";
"          if (1 == j)";
"            player:notify();";
"            player:notify(\"-- Verbs from \\\"\", o.name, \"\\\" (\", o, \") --\");";
"          else";
"            player:notify();";
"          endif";
"          player:notify(i);";
"          player:notify(\"  <<permission denied>>\");";
"        endif";
"      endfor";
"    else";
"      player:notify();";
"      player:notify(\"-- Verbs from \\\"\", o.name, \"\\\" (\", o, \") --\");";
"      player:notify(\"  <<permission denied>>\");";
"    endif";
"  endfor";
"";
"  for o in (ancestors)";
"    if (utilities:_player_controls_object(o) || o.r)";
"      for i, j in (properties(o))";
"        if (utilities:_player_controls_property(dobj, i))";
"          if (dobj == o && 1 == j)";
"            player:notify();";
"            player:notify(\"-- Properties --\");";
"          elseif (1 == j)";
"            player:notify();";
"            player:notify(\"-- Properties from \\\"\", o.name, \"\\\" (\", o, \") --\");";
"          else";
"            player:notify();";
"          endif";
"          l = {i};";
"          is_clear_property(dobj, i) && (l = {@l, \"[clear]\"});";
"          l = {@l, toliteral(dobj.(i))};";
"          player:notify(l:join(\" \"));";
"          player:notify(\"  \" + toliteral(property_info(dobj, i)));";
"        else";
"          if (1 == j)";
"            player:notify();";
"            player:notify(\"-- Properties from \\\"\", o.name, \"\\\" (\", o, \") --\");";
"          else";
"            player:notify();";
"          endif";
"          player:notify(i);";
"          player:notify(\"  <<permission denied>>\");";
"        endif";
"      endfor";
"    else";
"      player:notify();";
"      player:notify(\"-- Properties from \\\"\", o.name, \"\\\" (\", o, \") --\");";
"      player:notify(\"  <<permission denied>>\");";
"    endif";
"  endfor";
"";
"endif";
"";
"player:notify();";
"player:notify(\"(done)\");";
"";
"chunk_length:135";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:7C0962940168BA3D034518A88EB186A7FCE7B040";
"-=-=-mxyzptlk-=-=-";
.
#126:5
if (player != this)
player:notify("I couldn't understand that.");
return;
elseif (!player.programmer)
player:notify("You need to be a programmer to @diff verb code.");
return;
endif
player_utilities = $lookup("player_utilities");
{o, v} = player_utilities:match_verb(dobjstr);
if (!v)
player:notify("I couldn't understand that.");
return;
elseif (v && (`vi = verb_info(o, v) ! E_VERBNF' == E_VERBNF))
player:notify("That verb doesn't exist.");
return;
elseif ((!player_utilities:_player_controls_verb(o, v)) && (!index(vi[2], "r")))
player:notify("You don't have permission to do that.");
return;
endif
vd = $verb_detail(o, v);
if (`vd["state"] ! E_RANGE' != "dirty")
player:notify("There is nothing to diff; the verb is clean.");
return;
endif
if (`vd["revision"] ! E_RANGE => 0' < 2)
player:notify("There is nothing to diff; there is only one revision.");
return;
endif
set_task_perms(player);
r1 = vd["revision"] - 1;
r2 = vd["revision"];
vc1 = verb_code(o, v, ["revision" -> r1]);
vc2 = verb_code(o, v, ["revision" -> r2]);
player:notify("--- ", dobjstr, " r", r1);
player:notify("+++ ", dobjstr, " r", r2, " (dirty)");
patience_diff = $lookup("patience_diff|text_tools");
diffs = patience_diff:diff(vc1, vc2);
for diff in (diffs)
pos1 = diff[2];
pos2 = diff[3];
if (diff[1] == "r")
df1 = diff[4];
ln1 = length(df1);
df2 = diff[5];
ln2 = length(df2);
elseif (diff[1] == "+")
df1 = {};
ln1 = 0;
df2 = diff[4];
ln2 = length(df2);
elseif (diff[1] = "-")
df1 = diff[4];
ln1 = length(df1);
df2 = {};
ln2 = 0;
endif
before = (pos1 > 1) ? tostr(" ", vc1[pos1 - 1]) | 0;
after = (((pos1 + ln1) - 1) < length(vc1)) ? tostr(" ", vc1[pos1 + ln1]) | 0;
player:notify("@@ -", pos1, ",", ln1, " +", pos2, ",", ln2, " @@");
before && player:notify(before);
for l in (df1)
player:notify("-" + l);
endfor
for l in (df2)
player:notify("+" + l);
endfor
after && player:notify(after);
endfor
player:notify("(done)");
return;
"if (player != this)";
"  player:notify(\"I couldn't understand that.\");";
"  return;";
"elseif (!player.programmer)";
"  player:notify(\"You need to be a programmer to @diff verb code.\");";
"  return;";
"endif";
"";
"player_utilities = $lookup(\"player_utilities\");";
"";
"{o, v} = player_utilities:match_verb(dobjstr);";
"if (!v)";
"  player:notify(\"I couldn't understand that.\");";
"  return;";
"elseif (v && `vi = verb_info(o, v) ! E_VERBNF' == E_VERBNF)";
"  player:notify(\"That verb doesn't exist.\");";
"  return;";
"elseif (!player_utilities:_player_controls_verb(o, v) && !index(vi[2], \"r\"))";
"  player:notify(\"You don't have permission to do that.\");";
"  return;";
"endif";
"";
"vd = $verb_detail(o, v);";
"if (`vd[\"state\"] ! E_RANGE' != \"dirty\")";
"  player:notify(\"There is nothing to diff; the verb is clean.\");";
"  return;";
"endif";
"if (`vd[\"revision\"] ! E_RANGE => 0' < 2)";
"  player:notify(\"There is nothing to diff; there is only one revision.\");";
"  return;";
"endif";
"";
"set_task_perms(player);";
"";
"r1 = vd[\"revision\"] - 1;";
"r2 = vd[\"revision\"];";
"";
"vc1 = verb_code(o, v, [\"revision\" -> r1]);";
"vc2 = verb_code(o, v, [\"revision\" -> r2]);";
"";
"player:notify(\"--- \", dobjstr, \" r\", r1);";
"player:notify(\"+++ \", dobjstr, \" r\", r2, \" (dirty)\");";
"";
"patience_diff = $lookup(\"patience_diff|text_tools\");";
"";
"diffs = patience_diff:diff(vc1, vc2);";
"";
"for diff in (diffs)";
"  pos1 = diff[2];";
"  pos2 = diff[3];";
"  if (diff[1] == \"r\")";
"    df1 = diff[4];";
"    ln1 = length(df1);";
"    df2 = diff[5];";
"    ln2 = length(df2);";
"  elseif (diff[1] == \"+\")";
"    df1 = {};";
"    ln1 = 0;";
"    df2 = diff[4];";
"    ln2 = length(df2);";
"  elseif (diff[1] = \"-\")";
"    df1 = diff[4];";
"    ln1 = length(df1);";
"    df2 = {};";
"    ln2 = 0;";
"  endif";
"  before = pos1 > 1 ? tostr(\" \", vc1[pos1 - 1]) | 0;";
"  after = pos1 + ln1 - 1 < length(vc1) ? tostr(\" \", vc1[pos1 + ln1]) | 0;";
"  player:notify(\"@@ -\", pos1, \",\", ln1, \" +\", pos2, \",\", ln2, \" @@\");";
"  before && player:notify(before);";
"  for l in (df1)";
"    player:notify(\"-\" + l);";
"  endfor";
"  for l in (df2)";
"    player:notify(\"+\" + l);";
"  endfor";
"  after && player:notify(after);";
"endfor";
"";
"player:notify(\"(done)\");";
"";
"chunk_length:80";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:A47BE42A7D9589E8326AF92033ABEF72EE381BFD";
"-=-=-mxyzptlk-=-=-";
.
#126:6
if (player != this)
player:notify("I couldn't understand that.");
return;
elseif (!player.programmer)
player:notify("You need to be a programmer to ", verb, " verb code.");
return;
endif
player_utilities = $lookup("player_utilities");
{o, v} = player_utilities:match_verb(dobjstr);
if (!v)
player:notify("I couldn't understand that.");
return;
elseif (v && (`vi = verb_info(o, v) ! E_VERBNF' == E_VERBNF))
player:notify("That verb doesn't exist.");
return;
elseif ((!player_utilities:_player_controls_verb(o, v)) && (!index(vi[2], "w")))
player:notify("You don't have permission to do that.");
return;
endif
vd = $verb_detail(o, v);
if (`vd["state"] ! E_RANGE' != "dirty")
player:notify("There is nothing to ", verb[2..$], "; the verb is clean.");
return;
endif
if (("@revert" == verb) && (`vd["revision"] ! E_RANGE => 0' < 2))
player:notify("There is nothing to revert; there is only one revision.");
return;
endif
set_task_perms(player);
if ("@commit" == verb)
$verb_commit(o, v);
player:notify("You committed the changes to ", dobjstr);
elseif ("@revert" == verb)
$verb_revert(o, v);
player:notify("You reverted the changes to ", dobjstr);
endif
return;
"if (player != this)";
"  player:notify(\"I couldn't understand that.\");";
"  return;";
"elseif (!player.programmer)";
"  player:notify(\"You need to be a programmer to \", verb, \" verb code.\");";
"  return;";
"endif";
"";
"player_utilities = $lookup(\"player_utilities\");";
"";
"{o, v} = player_utilities:match_verb(dobjstr);";
"if (!v)";
"  player:notify(\"I couldn't understand that.\");";
"  return;";
"elseif (v && `vi = verb_info(o, v) ! E_VERBNF' == E_VERBNF)";
"  player:notify(\"That verb doesn't exist.\");";
"  return;";
"elseif (!player_utilities:_player_controls_verb(o, v) && !index(vi[2], \"w\"))";
"  player:notify(\"You don't have permission to do that.\");";
"  return;";
"endif";
"";
"vd = $verb_detail(o, v);";
"if (`vd[\"state\"] ! E_RANGE' != \"dirty\")";
"  player:notify(\"There is nothing to \", verb[2..$], \"; the verb is clean.\");";
"  return;";
"endif";
"";
"if (\"@revert\" == verb && `vd[\"revision\"] ! E_RANGE => 0' < 2)";
"  player:notify(\"There is nothing to revert; there is only one revision.\");";
"  return;";
"endif";
"";
"set_task_perms(player);";
"";
"if (\"@commit\" == verb)";
"  $verb_commit(o, v);";
"  player:notify(\"You committed the changes to \", dobjstr);";
"elseif (\"@revert\" == verb)";
"  $verb_revert(o, v);";
"  player:notify(\"You reverted the changes to \", dobjstr);";
"endif";
"";
"chunk_length:42";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:39BA28E527A97FD9B68E40D9EC05118E1BE8A11E";
"-=-=-mxyzptlk-=-=-";
.
#127:0
if (player != this)
notify(player, "I couldn't understand that.");
return;
elseif (!player.wizard)
notify(player, "You need to be a wizard to shut down the server.");
return;
endif
player:notify("Goodbye!");
shutdown();
return;
"if (player != this)";
"  notify(player, \"I couldn't understand that.\");";
"  return;";
"elseif (!player.wizard)";
"  notify(player, \"You need to be a wizard to shut down the server.\");";
"  return;";
"endif";
"";
"player:notify(\"Goodbye!\");";
"";
"shutdown();";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:18873593F31BE54AEC357B9E2B33503F0BBBA9E5";
"-=-=-mxyzptlk-=-=-";
.
#128:0
$restrict_to_caller($composed);
chparents(#5, {$alt.wizard_proto});
chparents(#6, {$alt.programmer_proto});
return;
"$restrict_to_caller($composed);";
"/* improvise-specific application tweaks */";
"chparents(#5, {$alt.wizard_proto});";
"chparents(#6, {$alt.programmer_proto});";
"";
"chunk_length:4";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:47625885FC0B925292089EDE0ACD5F175697BDC2";
"-=-=-mxyzptlk-=-=-";
.
#130:0
$restrict_to_caller($system, "server_started");
$lookup("server"):start(8888);
.
#134:0
$private();
{?parameters = []} = args;
if (valid(player))
return parameters:merge(["links" -> {["id" -> tonum($system), "name" -> "$system"], ["id" -> tonum(player.location), "name" -> "home"], ["id" -> tonum(player), "name" -> "me"]}, "player" -> ["id" -> tonum(player), "name" -> player.name], "page" -> ["title" -> "Stunt | Improvise"]]);
else
return parameters:merge(["links" -> {["id" -> tonum($system), "name" -> "$system"]}, "page" -> ["title" -> "Stunt | Improvise"]]);
endif
return;
"$private()";
"";
"{parameters = []} = args";
"";
"if (valid(player))";
"  return parameters:merge([";
"    \"links\" -> {";
"      [\"id\" -> tonum($system), \"name\" -> \"$system\"],";
"      [\"id\" -> tonum(player.location), \"name\" -> \"home\"],";
"      [\"id\" -> tonum(player), \"name\" -> \"me\"]";
"    },";
"    \"player\" -> [\"id\" -> tonum(player), \"name\" -> player.name],";
"    \"page\" -> [\"title\" -> \"Stunt | Improvise\"]";
"  ])";
"else";
"  return parameters:merge([";
"    \"links\" -> {";
"      [\"id\" -> tonum($system), \"name\" -> \"$system\"]";
"    },";
"    \"page\" -> [\"title\" -> \"Stunt | Improvise\"]";
"  ])";
"end";
"";
"chunk_length:22";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:EB6289E288639999C9F2ED4360038E8CCEC8FE5B";
"-=-=-mxyzptlk-=-=-";
.
#134:1
$restrict_to_caller($dialog.server);
{parameters} = args;
_343639275 = this;
_281805987 = $lookup("home_views");
request = this.request;
response = this.response;
parameters = _343639275:_common_parameters(parameters);
if (valid(player))
swf = (this.socket_or_long_poll == "socket") ? request:headers()["Cookie"] | 0;
parameters = parameters:merge(["page" -> ["title" -> "Stunt | Improvise", "swf" -> swf]]);
_343639275:ok(_281805987:home(parameters));
else
_343639275:ok(_281805987:public(parameters));
endif
return;
"$restrict_to_caller($dialog.server)";
"";
"{parameters} = args";
"";
"from this use _common_parameters, ok";
"from \"home_views\" use home, public";
"";
"request = this.request";
"response = this.response";
"parameters = _common_parameters(parameters)";
"";
"if (valid(player))";
"  swf = (this.socket_or_long_poll == \"socket\") ? request:headers()[\"Cookie\"] | 0";
"  parameters = parameters:merge([\"page\" -> [\"title\" -> \"Stunt | Improvise\", \"swf\" -> swf]])";
"  ok(home(parameters))";
"else";
"  ok(public(parameters))";
"end";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:78101A7D58D21E321E3179D64D662EC3A5B2533B";
"-=-=-mxyzptlk-=-=-";
.
#134:2
$restrict_to_caller($dialog.server);
{parameters} = args;
_198012228 = this;
_136517732 = $lookup("home_views");
parameters = _198012228:_common_parameters(parameters);
_198012228:ok(_136517732:browse(parameters));
return;
"$restrict_to_caller($dialog.server)";
"";
"{parameters} = args";
"";
"from this use _common_parameters, ok";
"from \"home_views\" use browse";
"";
"parameters = _common_parameters(parameters)";
"";
"ok(browse(parameters))";
"";
"chunk_length:10";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:F872B7A86B41CB011802DBFC54B95A19148C8014";
"-=-=-mxyzptlk-=-=-";
.
#135:0
stack = args;
output = {};
output = {@output, "<head>", 0};
output = {@output, "  <title>"};
top = `stack[1]["page"] ! E_RANGE';
stack = {(typeof(top) == MAP) ? top | ([]), @stack};
output = {@output, strsub(strsub(strsub(strsub(`tostr(stack[1]["title"]) ! E_RANGE => ""', "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), "\"", "&quot;")};
stack = stack[2..$];
output = {@output, "</title>", 1};
output = {@output, "  "};
verb = `this:authenticity_token_meta_tag(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "  "};
failed = 0;
if (top = `stack[1]["page"] ! E_RANGE')
stack = {stack[1]:merge((typeof(top) == MAP) ? top | ([])), @stack};
else
stack = {[], @stack};
failed = 1;
endif
if ((!failed) && (top = `stack[1]["swf"] ! E_RANGE'))
for item in ((typeof(top) == LIST) ? top | {top})
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
stack = {(typeof(item) == MAP) ? item | (["." -> item]), @stack};
output = {@output, 1};
output = {@output, "    <meta name=\"session_state\" content=\""};
output = {@output, strsub(strsub(strsub(strsub(`tostr(stack[1]["."]) ! E_RANGE => ""', "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), "\"", "&quot;")};
output = {@output, "\"/>", 1};
output = {@output, "    <script type=\"text/javascript\" src=\"/js/Socket.js\"></script>", 0};
output = {@output, "    <script type=\"text/javascript\" src=\"/js/swfobject-2.1.min.js\"></script>", 0};
output = {@output, "    <script type=\"text/javascript\">", 0};
output = {@output, "      var flashvars = {};", 0};
output = {@output, "      var params = {menu: 'false', scale: 'noScale', allowScriptAccess: 'always', bgcolor: '#FFFFFF'};", 0};
output = {@output, "      var attributes = {id: 'JavascriptSocket', name: 'JavascriptSocket'};", 0};
output = {@output, "      swfobject.embedSWF('/flash/javascriptsocket.swf', 'flash-content', '100%', '100%', '9.0.0', null, flashvars, params, attributes);", 0};
output = {@output, "    </script>", 0};
output = {@output, "  "};
stack = stack[2..$];
endfor
endif
stack = stack[2..$];
output = {@output, 1};
output = {@output, "  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/bootstrap-2.0.2.min.css\">", 0};
output = {@output, "  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/bootstrap-responsive-2.0.2.min.css\">", 0};
output = {@output, "  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/font-awesome-1.0.0-7.min.css\">", 0};
output = {@output, "  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/moo-0.0.4.min.css\">", 0};
output = {@output, "  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/console.min.css\">", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/jquery-1.7.1.min.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/jquery.ui.core-1.8.18.min.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/jquery.ui.widget-1.8.18.min.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/jquery.console-1.1.0.min.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/underscore-1.3.1.min.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/backbone-0.9.2.min.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/bootstrap-dropdown-2.0.2.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/bootstrap-modal-2.0.2.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/bootstrap-transition-2.0.2.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/moo-0.0.4.min.js\"></script>", 0};
output = {@output, "  <script type=\"text/javascript\" src=\"/js/moo-interactive-0.0.4.min.js\"></script>", 0};
output = {@output, "</head>", 0};
out = {};
acc = {};
indent = "";
while (output)
{line, @output} = output;
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (typeof(line) == LIST)
if (lines = line)
if (length(lines) > 1)
temp = {lines[1], 0};
for line in (lines[2..$ - 1])
temp = {@temp, indent + line, 0};
endfor
temp = {@temp, indent + lines[$]};
output = {@temp, @output};
else
output = {lines[1], @output};
endif
endif
elseif (typeof(line) == INT)
if (line > 0)
if (match(acc = tostr(@acc), "[^ ]"))
out = {@out, acc};
endif
else
out = {@out, tostr(@acc)};
endif
acc = {};
indent = "";
else
if (!match(line, "[^ ]"))
indent = line;
endif
acc = {@acc, line};
endif
endwhile
return out;
return;
"<head>";
"  <title>{{page.title}}</title>";
"  {{>authenticity_token_meta_tag}}";
"  {{#page.swf}}";
"    <meta name=\"session_state\" content=\"{{.}}\"/>";
"    <script type=\"text/javascript\" src=\"/js/Socket.js\"></script>";
"    <script type=\"text/javascript\" src=\"/js/swfobject-2.1.min.js\"></script>";
"    <script type=\"text/javascript\">";
"      var flashvars = {};";
"      var params = {menu: 'false', scale: 'noScale', allowScriptAccess: 'always', bgcolor: '#FFFFFF'};";
"      var attributes = {id: 'JavascriptSocket', name: 'JavascriptSocket'};";
"      swfobject.embedSWF('/flash/javascriptsocket.swf', 'flash-content', '100%', '100%', '9.0.0', null, flashvars, params, attributes);";
"    </script>";
"  {{/page.swf}}";
"  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/bootstrap-2.0.2.min.css\">";
"  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/bootstrap-responsive-2.0.2.min.css\">";
"  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/font-awesome-1.0.0-7.min.css\">";
"  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/moo-0.0.4.min.css\">";
"  <link type=\"text/css\" rel=\"stylesheet\" href=\"/css/console.min.css\">";
"  <script type=\"text/javascript\" src=\"/js/jquery-1.7.1.min.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/jquery.ui.core-1.8.18.min.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/jquery.ui.widget-1.8.18.min.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/jquery.console-1.1.0.min.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/underscore-1.3.1.min.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/backbone-0.9.2.min.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/bootstrap-dropdown-2.0.2.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/bootstrap-modal-2.0.2.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/bootstrap-transition-2.0.2.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/moo-0.0.4.min.js\"></script>";
"  <script type=\"text/javascript\" src=\"/js/moo-interactive-0.0.4.min.js\"></script>";
"</head>";
"";
"chunk_length:31";
"chunk_type:source";
"content_type:application/x-mustache";
"sha1:98EE2C7B0EA5AA61DFE0037DC3CB65D9652F4A13";
"-=-=-mxyzptlk-=-=-";
.
#135:1
stack = args;
output = {};
output = {@output, ""};
failed = 0;
if (top = `stack[1]["page"] ! E_RANGE')
stack = {stack[1]:merge((typeof(top) == MAP) ? top | ([])), @stack};
else
stack = {[], @stack};
failed = 1;
endif
if ((!failed) && (top = `stack[1]["swf"] ! E_RANGE'))
for item in ((typeof(top) == LIST) ? top | {top})
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
stack = {(typeof(item) == MAP) ? item | (["." -> item]), @stack};
output = {@output, 1};
output = {@output, "  <div id=\"flash-content\"></div>", 0};
output = {@output, ""};
stack = stack[2..$];
endfor
endif
stack = stack[2..$];
output = {@output, 1};
output = {@output, "<script type=\"text/javascript\">", 0};
output = {@output, "", 0};
output = {@output, "  var authenticity_token = $(\"meta[name=authenticity_token]\").attr(\"content\");", 0};
output = {@output, "", 0};
output = {@output, "  $(document).ajaxSend(function(event, xhr, settings) {", 0};
output = {@output, "    xhr.setRequestHeader(\"X-Authenticity-Token\", authenticity_token);", 0};
output = {@output, "  });", 0};
output = {@output, "", 0};
output = {@output, "  $(\"#disconnect\").click(function(e) {", 0};
output = {@output, "    e.preventDefault();", 0};
output = {@output, "    $.post($(this).attr(\"href\"), function() {", 0};
output = {@output, "      window.location.href = \"/\";", 0};
output = {@output, "    });", 0};
output = {@output, "  });", 0};
output = {@output, "</script>", 0};
out = {};
acc = {};
indent = "";
while (output)
{line, @output} = output;
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (typeof(line) == LIST)
elseif (typeof(line) == INT)
if (line > 0)
if (match(acc = tostr(@acc), "[^ ]"))
out = {@out, acc};
endif
else
out = {@out, tostr(@acc)};
endif
acc = {};
else
acc = {@acc, line};
endif
endwhile
return out;
return;
"{{#page.swf}}";
"  <div id=\"flash-content\"></div>";
"{{/page.swf}}";
"<script type=\"text/javascript\">";
"";
"  var authenticity_token = $(\"meta[name=authenticity_token]\").attr(\"content\");";
"";
"  $(document).ajaxSend(function(event, xhr, settings) {";
"    xhr.setRequestHeader(\"X-Authenticity-Token\", authenticity_token);";
"  });";
"";
"  $(\"#disconnect\").click(function(e) {";
"    e.preventDefault();";
"    $.post($(this).attr(\"href\"), function() {";
"      window.location.href = \"/\";";
"    });";
"  });";
"</script>";
"";
"chunk_length:18";
"chunk_type:source";
"content_type:application/x-mustache";
"sha1:9F3D0B2DEE4CB78C3D159EFEFFEA556046D6BAC2";
"-=-=-mxyzptlk-=-=-";
.
#135:2
stack = args;
output = {};
output = {@output, "<div class=\"navbar navbar-fixed-top\">", 0};
output = {@output, "  <div class=\"navbar-inner\">", 0};
output = {@output, "    <div class=\"container\">", 0};
output = {@output, "      <a class=\"brand\" href=\"/\">", 0};
output = {@output, "        "};
top = `stack[1]["page"] ! E_RANGE';
stack = {(typeof(top) == MAP) ? top | ([]), @stack};
output = {@output, strsub(strsub(strsub(strsub(`tostr(stack[1]["title"]) ! E_RANGE => ""', "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), "\"", "&quot;")};
stack = stack[2..$];
output = {@output, 1};
output = {@output, "      </a>", 0};
output = {@output, "      <ul class=\"nav\">", 0};
output = {@output, "        "};
if (top = `stack[1]["player"] ! E_RANGE')
for item in ((typeof(top) == LIST) ? top | {top})
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
stack = {stack[1]:merge((typeof(item) == MAP) ? item | (["." -> item])), @stack};
output = {@output, 1};
output = {@output, "          <li>", 0};
output = {@output, "            <a href=\"/\">Console</a>", 0};
output = {@output, "          </li>", 0};
output = {@output, "        "};
stack = stack[2..$];
endfor
endif
output = {@output, 1};
output = {@output, "        <li class=\"dropdown\">", 0};
output = {@output, "          <a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\">Browse To<b class=\"caret\"></b></a>", 0};
output = {@output, "          <ul class=\"dropdown-menu\">", 0};
output = {@output, "            "};
if (top = `stack[1]["links"] ! E_RANGE')
for item in ((typeof(top) == LIST) ? top | {top})
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
stack = {stack[1]:merge((typeof(item) == MAP) ? item | (["." -> item])), @stack};
output = {@output, 1};
output = {@output, "              <li><a rel=\"object\" data-object-number=\""};
output = {@output, strsub(strsub(strsub(strsub(`tostr(stack[1]["id"]) ! E_RANGE => ""', "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), "\"", "&quot;")};
output = {@output, "\" href=\"/objects/"};
output = {@output, strsub(strsub(strsub(strsub(`tostr(stack[1]["id"]) ! E_RANGE => ""', "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), "\"", "&quot;")};
output = {@output, "\">"};
output = {@output, strsub(strsub(strsub(strsub(`tostr(stack[1]["name"]) ! E_RANGE => ""', "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), "\"", "&quot;")};
output = {@output, "</a></li>", 3};
output = {@output, "            "};
stack = stack[2..$];
endfor
endif
output = {@output, 1};
output = {@output, "          </ul>", 0};
output = {@output, "        </li>", 0};
output = {@output, "      </ul>", 0};
output = {@output, "      <ul class=\"nav pull-right\">", 0};
output = {@output, "        "};
if (top = `stack[1]["player"] ! E_RANGE')
for item in ((typeof(top) == LIST) ? top | {top})
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
stack = {stack[1]:merge((typeof(item) == MAP) ? item | (["." -> item])), @stack};
output = {@output, 1};
output = {@output, "          <li><a id=\"disconnect\" href=\"/session/destroy\">Disconnect</a></li>", 0};
output = {@output, "        "};
stack = stack[2..$];
endfor
endif
output = {@output, 1};
output = {@output, "        "};
if (!(top = `stack[1]["player"] ! E_RANGE'))
for item in ({""})
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
stack = {stack[1]:merge((typeof(item) == MAP) ? item | (["." -> item])), @stack};
output = {@output, 1};
output = {@output, "          <li><a href=\"/\">Connect</a></li>", 0};
output = {@output, "        "};
stack = stack[2..$];
endfor
endif
output = {@output, 1};
output = {@output, "      </ul>", 0};
output = {@output, "    </div>", 0};
output = {@output, "  </div>", 0};
output = {@output, "</div>", 0};
out = {};
acc = {};
indent = "";
while (output)
{line, @output} = output;
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (typeof(line) == LIST)
elseif (typeof(line) == INT)
if (line > 0)
if (match(acc = tostr(@acc), "[^ ]"))
out = {@out, acc};
endif
else
out = {@out, tostr(@acc)};
endif
acc = {};
else
acc = {@acc, line};
endif
endwhile
return out;
return;
"<div class=\"navbar navbar-fixed-top\">";
"  <div class=\"navbar-inner\">";
"    <div class=\"container\">";
"      <a class=\"brand\" href=\"/\">";
"        {{page.title}}";
"      </a>";
"      <ul class=\"nav\">";
"        {{#player}}";
"          <li>";
"            <a href=\"/\">Console</a>";
"          </li>";
"        {{/player}}";
"        <li class=\"dropdown\">";
"          <a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\">Browse To<b class=\"caret\"></b></a>";
"          <ul class=\"dropdown-menu\">";
"            {{#links}}";
"              <li><a rel=\"object\" data-object-number=\"{{id}}\" href=\"/objects/{{id}}\">{{name}}</a></li>";
"            {{/links}}";
"          </ul>";
"        </li>";
"      </ul>";
"      <ul class=\"nav pull-right\">";
"        {{#player}}";
"          <li><a id=\"disconnect\" href=\"/session/destroy\">Disconnect</a></li>";
"        {{/player}}";
"        {{^player}}";
"          <li><a href=\"/\">Connect</a></li>";
"        {{/player}}";
"      </ul>";
"    </div>";
"  </div>";
"</div>";
"";
"chunk_length:32";
"chunk_type:source";
"content_type:application/x-mustache";
"sha1:BB81418E9CDC9537A706F603B5475A95D2ACB503";
"-=-=-mxyzptlk-=-=-";
.
#135:3
stack = args;
output = {};
output = {@output, "<!DOCTYPE html>", 0};
output = {@output, "<html lang=\"en\">", 0};
output = {@output, ""};
verb = `this:_head(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "<body>", 0};
output = {@output, "  <style type=\"text/css\">", 0};
output = {@output, "    body .container .mark {", 0};
output = {@output, "      font-weight: bold;", 0};
output = {@output, "    }", 0};
output = {@output, "    #logo {", 0};
output = {@output, "      width: 450px;", 0};
output = {@output, "      margin: 40px 10px;", 0};
output = {@output, "    }", 0};
output = {@output, "  </style>", 0};
output = {@output, "  <div class=\"container\">", 0};
output = {@output, "    &nbsp;", 0};
output = {@output, "    <div class=\"row\">", 0};
output = {@output, "      <div class=\"span12\">", 0};
output = {@output, "        <h1>Welcome to Stunt | Improvise</h1>", 0};
output = {@output, "      </div>", 0};
output = {@output, "    </div>", 0};
output = {@output, "    &nbsp;", 0};
output = {@output, "    <div class=\"row\">", 0};
output = {@output, "      <div class=\"span5\">", 0};
output = {@output, "        <form class=\"well form-inline\" action=\"/session/create\" method=\"post\">", 0};
output = {@output, "          "};
verb = `this:authenticity_token_form_input(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "          <button type=\"submit\" name=\"submit\">Connect</button>", 0};
output = {@output, "          <input class=\"span3\" type=\"text\" name=\"credentials\" placeholder=\"credentials, ex: &lt;player&gt; &lt;password&gt;\">", 0};
output = {@output, "        </form>", 0};
output = {@output, "        <img id=\"logo\" src=\"/img/stunt.png\">", 0};
output = {@output, "      </div>", 0};
output = {@output, "      <div class=\"span7\">", 0};
output = {@output, "        <h2>Get Started</h2>", 0};
output = {@output, "        <p>", 0};
output = {@output, "          &larr; Use the form on the left to connect to a specific player.", 0};
output = {@output, "        </p>", 0};
output = {@output, "        <h2>About Stunt | Improvise</h2>", 0};
output = {@output, "        <p>", 0};
output = {@output, "          <a href=\"https://github.com/toddsundsted/stunt\">Stunt</a>", 0};
output = {@output, "          is a set of extensions to the <a href=\"http://sourceforge.net/projects/lambdamoo/\">LambdaMOO server</a>", 0};
output = {@output, "          and <a href=\"https://github.com/toddsundsted/improvise\">Improvise</a>", 0};
output = {@output, "          is an associated framework that uses those extensions.", 0};
output = {@output, "        </p>", 0};
output = {@output, "        <p>", 0};
output = {@output, "          <span class=\"mark\">Stunt | Improvise</span> is well suited", 0};
output = {@output, "          for building immersive, collaborative, Web-based", 0};
output = {@output, "          applications &mdash; specifically, applications where", 0};
output = {@output, "          every <em>user</em> is a <em>programmer</em>.", 0};
output = {@output, "        </p>", 0};
output = {@output, "        <p>", 0};
output = {@output, "          Together, <span class=\"mark\">Stunt | Improvise</span>", 0};
output = {@output, "          comprise:", 0};
output = {@output, "        </p>", 0};
output = {@output, "        <ul>", 0};
output = {@output, "          <li>a persistent, NoSQL object database with a simple JSON API</li>", 0};
output = {@output, "          <li>an server-side HTTP-based MVC framework with support for HTML5 features like pushState</li>", 0};
output = {@output, "          <li>a client-side RAI framework based on Backbone.js</li>", 0};
output = {@output, "          <li>a framework for securely executing untrusted code</li>", 0};
output = {@output, "          <li>a simple, embedded programming language</li>", 0};
output = {@output, "          <li>integrated package management</li>", 0};
output = {@output, "        </ul>", 0};
output = {@output, "        <h2>Learn More</h2>", 0};
output = {@output, "        <p>", 0};
output = {@output, "          To learn more, check out:", 0};
output = {@output, "        </p>", 0};
output = {@output, "        <ul>", 0};
output = {@output, "          <li><a href=\"http://stunt.io/\">the Stunt.io website</a></li>", 0};
output = {@output, "          <li><a href=\"http://stunt.io/ProgrammersManual.html\">the LambdaMOO Programmers Manual</a></li>", 0};
output = {@output, "          <li><a href=\"https://github.com/toddsundsted/stunt\">the Stunt GitHub project</a></li>", 0};
output = {@output, "          <li><a href=\"https://github.com/toddsundsted/improvise\">the Improvise GitHub project</a></li>", 0};
output = {@output, "        </ul>", 0};
output = {@output, "      </div>", 0};
output = {@output, "    </div>", 0};
output = {@output, "  </div>", 0};
output = {@output, ""};
verb = `this:_foot(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "</body>", 0};
output = {@output, "</html>", 0};
out = {};
acc = {};
indent = "";
while (output)
{line, @output} = output;
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (typeof(line) == LIST)
if (lines = line)
if (length(lines) > 1)
temp = {lines[1], 0};
for line in (lines[2..$ - 1])
temp = {@temp, indent + line, 0};
endfor
temp = {@temp, indent + lines[$]};
output = {@temp, @output};
else
output = {lines[1], @output};
endif
endif
elseif (typeof(line) == INT)
if (line > 0)
if (match(acc = tostr(@acc), "[^ ]"))
out = {@out, acc};
endif
else
out = {@out, tostr(@acc)};
endif
acc = {};
indent = "";
else
if (!match(line, "[^ ]"))
indent = line;
endif
acc = {@acc, line};
endif
endwhile
return out;
return;
"<!DOCTYPE html>";
"<html lang=\"en\">";
"{{> _head}}";
"<body>";
"  <style type=\"text/css\">";
"    body .container .mark {";
"      font-weight: bold;";
"    }";
"    #logo {";
"      width: 450px;";
"      margin: 40px 10px;";
"    }";
"  </style>";
"  <div class=\"container\">";
"    &nbsp;";
"    <div class=\"row\">";
"      <div class=\"span12\">";
"        <h1>Welcome to Stunt | Improvise</h1>";
"      </div>";
"    </div>";
"    &nbsp;";
"    <div class=\"row\">";
"      <div class=\"span5\">";
"        <form class=\"well form-inline\" action=\"/session/create\" method=\"post\">";
"          {{>authenticity_token_form_input}}";
"          <button type=\"submit\" name=\"submit\">Connect</button>";
"          <input class=\"span3\" type=\"text\" name=\"credentials\" placeholder=\"credentials, ex: &lt;player&gt; &lt;password&gt;\">";
"        </form>";
"        <img id=\"logo\" src=\"/img/stunt.png\">";
"      </div>";
"      <div class=\"span7\">";
"        <h2>Get Started</h2>";
"        <p>";
"          &larr; Use the form on the left to connect to a specific player.";
"        </p>";
"        <h2>About Stunt | Improvise</h2>";
"        <p>";
"          <a href=\"https://github.com/toddsundsted/stunt\">Stunt</a>";
"          is a set of extensions to the <a href=\"http://sourceforge.net/projects/lambdamoo/\">LambdaMOO server</a>";
"          and <a href=\"https://github.com/toddsundsted/improvise\">Improvise</a>";
"          is an associated framework that uses those extensions.";
"        </p>";
"        <p>";
"          <span class=\"mark\">Stunt | Improvise</span> is well suited";
"          for building immersive, collaborative, Web-based";
"          applications &mdash; specifically, applications where";
"          every <em>user</em> is a <em>programmer</em>.";
"        </p>";
"        <p>";
"          Together, <span class=\"mark\">Stunt | Improvise</span>";
"          comprise:";
"        </p>";
"        <ul>";
"          <li>a persistent, NoSQL object database with a simple JSON API</li>";
"          <li>an server-side HTTP-based MVC framework with support for HTML5 features like pushState</li>";
"          <li>a client-side RAI framework based on Backbone.js</li>";
"          <li>a framework for securely executing untrusted code</li>";
"          <li>a simple, embedded programming language</li>";
"          <li>integrated package management</li>";
"        </ul>";
"        <h2>Learn More</h2>";
"        <p>";
"          To learn more, check out:";
"        </p>";
"        <ul>";
"          <li><a href=\"http://stunt.io/\">the Stunt.io website</a></li>";
"          <li><a href=\"http://stunt.io/ProgrammersManual.html\">the LambdaMOO Programmers Manual</a></li>";
"          <li><a href=\"https://github.com/toddsundsted/stunt\">the Stunt GitHub project</a></li>";
"          <li><a href=\"https://github.com/toddsundsted/improvise\">the Improvise GitHub project</a></li>";
"        </ul>";
"      </div>";
"    </div>";
"  </div>";
"{{> _foot}}";
"</body>";
"</html>";
"";
"chunk_length:76";
"chunk_type:source";
"content_type:application/x-mustache";
"sha1:4EC70131E3D3149EC0D031768D6559CEE3BDAD2A";
"-=-=-mxyzptlk-=-=-";
.
#135:4
stack = args;
output = {};
output = {@output, "<!DOCTYPE html>", 0};
output = {@output, "<html lang=\"en\">", 0};
output = {@output, "  "};
verb = `this:_head(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "  <body>", 0};
output = {@output, "    "};
verb = `this:_nav(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "    <div id=\"top\" class=\"container\" style=\"padding-top: 60px;\">", 0};
output = {@output, "      <div class=\"row\">", 0};
output = {@output, "        <div id=\"console\" class=\"console span12\"></div>", 0};
output = {@output, "      </div>", 0};
output = {@output, "    </div>", 0};
output = {@output, "    <script type=\"text/javascript\">", 0};
output = {@output, "      $(function() {", 0};
output = {@output, "        var console1 = $('#console').console({", 0};
output = {@output, "           autofocus:true,", 0};
output = {@output, "           animateScroll:true,", 0};
output = {@output, "           promptHistory:true,", 0};
output = {@output, "           promptLabel: '> ',", 0};
output = {@output, "           commandHandle:function(command){", 0};
output = {@output, "             interactive.send(command + '\\n');", 0};
output = {@output, "             return true;", 0};
output = {@output, "           }", 0};
output = {@output, "        });", 0};
output = {@output, "        $('#console .jquery-console-inner').height($(window).height() - 140);", 0};
output = {@output, "        var interactive = new Moo.Interactive(window.location.hostname, window.location.port, {", 0};
output = {@output, "          session_state: $('meta[name=session_state]').attr('content'),", 0};
output = {@output, "          authenticity_token: $('meta[name=authenticity_token]').attr('content'),", 0};
output = {@output, "          callback: function(message) {", 0};
output = {@output, "            message = message.split('\\n');", 0};
output = {@output, "            message = _.select(message, function(v) { return v; });", 0};
output = {@output, "            message = _.map(message, function(v) { return {msg: v} });", 0};
output = {@output, "            console1.append(message);", 0};
output = {@output, "          }", 0};
output = {@output, "        });", 0};
output = {@output, "      });", 0};
output = {@output, "    </script>", 0};
output = {@output, "    "};
verb = `this:_foot(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "  </body>", 0};
output = {@output, "</html>", 0};
out = {};
acc = {};
indent = "";
while (output)
{line, @output} = output;
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (typeof(line) == LIST)
if (lines = line)
if (length(lines) > 1)
temp = {lines[1], 0};
for line in (lines[2..$ - 1])
temp = {@temp, indent + line, 0};
endfor
temp = {@temp, indent + lines[$]};
output = {@temp, @output};
else
output = {lines[1], @output};
endif
endif
elseif (typeof(line) == INT)
if (line > 0)
if (match(acc = tostr(@acc), "[^ ]"))
out = {@out, acc};
endif
else
out = {@out, tostr(@acc)};
endif
acc = {};
indent = "";
else
if (!match(line, "[^ ]"))
indent = line;
endif
acc = {@acc, line};
endif
endwhile
return out;
return;
"<!DOCTYPE html>";
"<html lang=\"en\">";
"  {{> _head}}";
"  <body>";
"    {{> _nav}}";
"    <div id=\"top\" class=\"container\" style=\"padding-top: 60px;\">";
"      <div class=\"row\">";
"        <div id=\"console\" class=\"console span12\"></div>";
"      </div>";
"    </div>";
"    <script type=\"text/javascript\">";
"      $(function() {";
"        var console1 = $('#console').console({";
"           autofocus:true,";
"           animateScroll:true,";
"           promptHistory:true,";
"           promptLabel: '> ',";
"           commandHandle:function(command){";
"             interactive.send(command + '\\n');";
"             return true;";
"           }";
"        });";
"        $('#console .jquery-console-inner').height($(window).height() - 140);";
"        var interactive = new Moo.Interactive(window.location.hostname, window.location.port, {";
"          session_state: $('meta[name=session_state]').attr('content'),";
"          authenticity_token: $('meta[name=authenticity_token]').attr('content'),";
"          callback: function(message) {";
"            message = message.split('\\n');";
"            message = _.select(message, function(v) { return v; });";
"            message = _.map(message, function(v) { return {msg: v} });";
"            console1.append(message);";
"          }";
"        });";
"      });";
"    </script>";
"    {{> _foot}}";
"  </body>";
"</html>";
"";
"chunk_length:38";
"chunk_type:source";
"content_type:application/x-mustache";
"sha1:3256046A1B5E54E4F0D2229BABF4BEB583F1EEAD";
"-=-=-mxyzptlk-=-=-";
.
#135:5
stack = args;
output = {};
output = {@output, "<!DOCTYPE html>", 0};
output = {@output, "<html lang=\"en\">", 0};
output = {@output, "  "};
verb = `this:_head(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "  <body>", 0};
output = {@output, "    "};
verb = `this:_nav(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "    <div id=\"top\" class=\"container\" style=\"padding-top: 60px;\">", 0};
output = {@output, "      <p id=\"browser\" class=\"browser\"></p>", 0};
output = {@output, "    </div>", 0};
output = {@output, "    <script type=\"text/javascript\">", 0};
output = {@output, "      $(function() {", 0};
output = {@output, "        Moo.Object.prototype.urlRoot = 'http://' + window.location.host + '///objects';", 0};
output = {@output, "", 0};
output = {@output, "        var $browser = $('#browser');", 0};
output = {@output, "        $browser.simpleObjectPanel();", 0};
output = {@output, "", 0};
output = {@output, "        Moo.Space = Backbone.Router.extend({", 0};
output = {@output, "          routes: {", 0};
output = {@output, "            'objects/:number': 'browse'", 0};
output = {@output, "          },", 0};
output = {@output, "          browse: function(number) {", 0};
output = {@output, "            var o = new Moo.Object({id: number});", 0};
output = {@output, "            o.fetch({", 0};
output = {@output, "              success: function(model, response) {", 0};
output = {@output, "                $browser.simpleObjectPanel({object: o});", 0};
output = {@output, "                $('#top').get(0).scrollIntoView(true);", 0};
output = {@output, "              },", 0};
output = {@output, "              error: function(model, response) {", 0};
output = {@output, "                $browser.simpleObjectPanel({object: o});", 0};
output = {@output, "                $('#top').get(0).scrollIntoView(true);", 0};
output = {@output, "              }", 0};
output = {@output, "            });", 0};
output = {@output, "          }", 0};
output = {@output, "        });", 0};
output = {@output, "        var moo = new Moo.Space;", 0};
output = {@output, "", 0};
output = {@output, "        $('body').on('click', 'a[rel*=object]', function(e) {", 0};
output = {@output, "          e.preventDefault();", 0};
output = {@output, "          var o = $(e.target).data('object-number');", 0};
output = {@output, "          moo.navigate('/objects/' + o, {trigger: true});", 0};
output = {@output, "        });", 0};
output = {@output, "", 0};
output = {@output, "        Backbone.history.start({pushState: true});", 0};
output = {@output, "", 0};
output = {@output, "        "};
if (top = `stack[1]["id"] ! E_RANGE')
for item in ((typeof(top) == LIST) ? top | {top})
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
stack = {stack[1]:merge((typeof(item) == MAP) ? item | (["." -> item])), @stack};
output = {@output, 1};
output = {@output, "          moo.navigate('/objects/"};
output = {@output, strsub(strsub(strsub(strsub(`tostr(stack[1]["id"]) ! E_RANGE => ""', "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), "\"", "&quot;")};
output = {@output, "');", 1};
output = {@output, "        "};
stack = stack[2..$];
endfor
endif
output = {@output, 1};
output = {@output, "      });", 0};
output = {@output, "    </script>", 0};
output = {@output, "    "};
verb = `this:_foot(@stack) ! E_VERBNF => {}';
output = {@output, verb};
output = {@output, 1};
output = {@output, "  </body>", 0};
output = {@output, "</html>", 0};
out = {};
acc = {};
indent = "";
while (output)
{line, @output} = output;
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
if (typeof(line) == LIST)
if (lines = line)
if (length(lines) > 1)
temp = {lines[1], 0};
for line in (lines[2..$ - 1])
temp = {@temp, indent + line, 0};
endfor
temp = {@temp, indent + lines[$]};
output = {@temp, @output};
else
output = {lines[1], @output};
endif
endif
elseif (typeof(line) == INT)
if (line > 0)
if (match(acc = tostr(@acc), "[^ ]"))
out = {@out, acc};
endif
else
out = {@out, tostr(@acc)};
endif
acc = {};
indent = "";
else
if (!match(line, "[^ ]"))
indent = line;
endif
acc = {@acc, line};
endif
endwhile
return out;
return;
"<!DOCTYPE html>";
"<html lang=\"en\">";
"  {{> _head}}";
"  <body>";
"    {{> _nav}}";
"    <div id=\"top\" class=\"container\" style=\"padding-top: 60px;\">";
"      <p id=\"browser\" class=\"browser\"></p>";
"    </div>";
"    <script type=\"text/javascript\">";
"      $(function() {";
"        Moo.Object.prototype.urlRoot = 'http://' + window.location.host + '///objects';";
"";
"        var $browser = $('#browser');";
"        $browser.simpleObjectPanel();";
"";
"        Moo.Space = Backbone.Router.extend({";
"          routes: {";
"            'objects/:number': 'browse'";
"          },";
"          browse: function(number) {";
"            var o = new Moo.Object({id: number});";
"            o.fetch({";
"              success: function(model, response) {";
"                $browser.simpleObjectPanel({object: o});";
"                $('#top').get(0).scrollIntoView(true);";
"              },";
"              error: function(model, response) {";
"                $browser.simpleObjectPanel({object: o});";
"                $('#top').get(0).scrollIntoView(true);";
"              }";
"            });";
"          }";
"        });";
"        var moo = new Moo.Space;";
"";
"        $('body').on('click', 'a[rel*=object]', function(e) {";
"          e.preventDefault();";
"          var o = $(e.target).data('object-number');";
"          moo.navigate('/objects/' + o, {trigger: true});";
"        });";
"";
"        Backbone.history.start({pushState: true});";
"";
"        {{#id}}";
"          moo.navigate('/objects/{{id}}');";
"        {{/id}}";
"      });";
"    </script>";
"    {{> _foot}}";
"  </body>";
"</html>";
"";
"chunk_length:51";
"chunk_type:source";
"content_type:application/x-mustache";
"sha1:DF0E9237C2D63F33AABC361455BB1D682EC3C596";
"-=-=-mxyzptlk-=-=-";
.
#136:0
$restrict_to_caller($dialog.server);
{parameters} = args;
credentials = `parameters["credentials"] ! E_RANGE => ""';
if (valid(player = $authenticate(@credentials:split())))
this.session = ["player" -> player];
endif
this:moved(parameters["__url_base__"] + "/");
return;
"$restrict_to_caller($dialog.server)";
"";
"{parameters} = args";
"";
"credentials = (parameters[\"credentials\"] !! E_RANGE => \"\")";
"";
"if (valid(player = $authenticate(@credentials:split())))";
"  this.session = [\"player\" -> player] // blow away the session; set the player";
"endif";
"";
"this:moved(parameters[\"__url_base__\"] + \"/\")";
"";
"chunk_length:11";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:C0CEBBB081BB6112DE4A4C65C489AA68DCEEB7C6";
"-=-=-mxyzptlk-=-=-";
.
#136:1
$restrict_to_caller($dialog.server);
{parameters} = args;
this.session = ["player" -> $nothing];
this:moved(parameters["__url_base__"] + "/");
return;
"$restrict_to_caller($dialog.server)";
"";
"{parameters} = args";
"";
"this.session = [\"player\" -> $nothing] // blow away the session; reset the player";
"";
"this:moved(parameters[\"__url_base__\"] + \"/\")";
"";
"chunk_length:7";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:AA365D0C0DE126B66D46948A899EA785142A1F1F";
"-=-=-mxyzptlk-=-=-";
.
#137:0
$restrict_to_caller($dialog.server);
{request} = args;
path = request:path():split("/");
method = request:method();
{host, ?port = 80} = `request:headers()["host"]:split(":") ! E_RANGE => {""}';
parameters = ["__base_uri__" -> host ? tostr("http://", host, ":", port) | "", "__connection__" -> player];
if ((!path) && (method == "get"))
return {this.home_controller, "home", parameters};
elseif (((length(path) == 2) && (path[1] == "objects")) && (method == "get"))
return {this.home_controller, "browse", parameters:merge(["id" -> path[2]])};
elseif ((path == {"session", "create"}) && (method == "post"))
return {this.session_controller, path[2], parameters};
elseif ((path == {"session", "destroy"}) && (method == "post"))
return {this.session_controller, path[2], parameters};
endif
return {};
return;
"$restrict_to_caller($dialog.server)";
"";
"{request} = args";
"";
"path = request:path():split(\"/\")";
"method = request:method()";
"";
"{host, port = 80} = (request:headers()[\"host\"]:split(\":\") !! E_RANGE => {\"\"})";
"";
"parameters = [";
"  \"__base_uri__\" -> host ? tostr(\"http://\", host, \":\", port) | \"\",";
"  \"__connection__\" -> player";
"]";
"";
"if (!path && method == \"get\")";
"  return {this.home_controller, \"home\", parameters}";
"elseif (length(path) == 2 && path[1] == \"objects\" && method == \"get\")";
"  return {this.home_controller, \"browse\", parameters:merge([\"id\" -> path[2]])}";
"elseif (path == {\"session\", \"create\"} && method == \"post\")";
"  return {this.session_controller, path[2], parameters}";
"elseif (path == {\"session\", \"destroy\"} && method == \"post\")";
"  return {this.session_controller, path[2], parameters}";
"end";
"";
"return {}";
"";
"chunk_length:25";
"chunk_type:source";
"content_type:application/x-moocode;version=0.0.2";
"sha1:D1CBE0B51F1D1E9F69E87E10F5F38CD6288BDF46";
"-=-=-mxyzptlk-=-=-";
.
#138:0
$restrict_to_caller(this.ask_proto);
{query, limit} = args;
((from = query.from) == 0) && raise(E_INVARG, "Missing from");
select = where = {};
if (operations = query.operations)
for operation in (operations)
`select = operation["select"] ! E_RANGE';
`where = {@where, operation["where"]} ! E_RANGE';
endfor
endif
set_task_perms(callers()[2][3]);
if (((type = typeof(from)) == OBJ) && valid(from))
from = descendants(from);
elseif ((type == LIST) && (length(from) < 1))
type = -1;
elseif ((type == LIST) && ((type = typeof(from[1])) in {OBJ, MAP, LIST}))
else
raise(E_INVARG, tostr("Invalid from:  ", toliteral(from)));
endif
res = {};
for o in (from)
((ticks_left() < 10000) || (seconds_left() < 2)) && suspend(0);
for w in (where)
{o1, op, o2} = w;
if (o1[1] < 0)
try
o1 = this:lookup(type, o, o1[2]);
except ex ("type mismatch", "not found", "permission denied")
o = [$ask.ERRORS -> [o1[2] -> ex[1]]];
break w;
endtry
else
o1 = o1[2];
endif
if (o2[1] < 0)
try
o2 = this:lookup(type, o, o2[2]);
except ex ("type mismatch", "not found", "permission denied")
o = [$ask.ERRORS -> [o2[2] -> ex[1]]];
break w;
endtry
else
o2 = o2[2];
endif
try
if ((op == "=") || (op == "=="))
if (o1 != o2)
continue o;
endif
elseif (op == "!=")
if (o1 == o2)
continue o;
endif
elseif (op == ">")
if (o1 <= o2)
continue o;
endif
elseif (op == ">=")
if (o1 < o2)
continue o;
endif
elseif (op == "<")
if (o1 >= o2)
continue o;
endif
elseif (op == "<=")
if (o1 > o2)
continue o;
endif
elseif (op == "includes")
if (!(o2 in o1))
continue o;
endif
elseif (op == "in")
if (!(o1 in o2))
continue o;
endif
elseif (op == "is")
if ((o1 && (!o2)) || ((!o1) && o2))
continue o;
endif
elseif (op == "=~")
if (!match(o1, o2))
continue o;
endif
else
raise(E_INVARG, tostr("Invalid operation:  ", op));
endif
except (E_TYPE)
o = [$ask.ERRORS -> tostr("type mismatch:  ", toliteral(o1), " ", op, " ", toliteral(o2))];
break w;
endtry
endfor
if (`o[$ask.ERRORS] ! E_TYPE, E_RANGE')
res = {@res, o};
elseif (select)
r = [];
for s in (select)
try
r[s] = this:lookup(type, o, s);
except ex ("type mismatch", "not found", "permission denied")
r = r:set_value_by_path({$ask.ERRORS, s}, ex[1]);
endtry
endfor
res = {@res, r};
else
res = {@res, o};
endif
if ((limit > 0) && res)
break;
endif
endfor
return (limit > 0) ? res ? res[1] | $failed_match | res;
return;
"$restrict_to_caller(this.ask_proto);";
"";
"{query, limit} = args;";
"";
"(from = query.from) == 0 && raise(E_INVARG, \"Missing from\");";
"";
"select = where = {};";
"if (operations = query.operations)";
"  for operation in (operations)";
"    `select = operation[\"select\"] ! E_RANGE';";
"    `where = {@where, operation[\"where\"]} ! E_RANGE';";
"  endfor";
"endif";
"";
"/* perms of the verb that called `all()', `one()'... */";
"set_task_perms(callers()[2][3]);";
"";
"/* `type' indicates the type of field to query over */";
"";
"if ((type = typeof(from)) == OBJ && valid(from))";
"  from = descendants(from);";
"elseif (type == LIST && length(from) < 1)";
"  type = -1;";
"elseif (type == LIST && (type = typeof(from[1])) in {OBJ, MAP, LIST})";
"  /* do nothing, but don't fail */";
"else";
"  raise(E_INVARG, tostr(\"Invalid from:  \", toliteral(from)));";
"endif";
"";
"res = {};";
"";
"for o in (from)";
"  ticks_left() < 10000 || seconds_left() < 2 && suspend(0);";
"  /* WHERE */";
"  for w in (where)";
"    {o1, op, o2} = w;";
"    /* get value from operand */";
"    if (o1[1] < 0)";
"      try";
"        o1 = this:lookup(type, o, o1[2]);";
"      except ex (\"type mismatch\", \"not found\", \"permission denied\")";
"        o = [$ask.ERRORS -> [o1[2] -> ex[1]]];";
"        break w;";
"      endtry";
"    else";
"      o1 = o1[2];";
"    endif";
"    if (o2[1] < 0)";
"      try";
"        o2 = this:lookup(type, o, o2[2]);";
"      except ex (\"type mismatch\", \"not found\", \"permission denied\")";
"        o = [$ask.ERRORS -> [o2[2] -> ex[1]]];";
"        break w;";
"      endtry";
"    else";
"      o2 = o2[2];";
"    endif";
"    /* operate! */";
"    try";
"      if (op == \"=\" || op == \"==\")";
"        if (o1 != o2)";
"          continue o; /* back to the top of the big loop */";
"        endif";
"      elseif (op == \"!=\")";
"        if (o1 == o2)";
"          continue o;";
"        endif";
"      elseif (op == \">\")";
"        if (o1 <= o2)";
"          continue o;";
"        endif";
"      elseif (op == \">=\")";
"        if (o1 < o2)";
"          continue o;";
"        endif";
"      elseif (op == \"<\")";
"        if (o1 >= o2)";
"          continue o;";
"        endif";
"      elseif (op == \"<=\")";
"        if (o1 > o2)";
"          continue o;";
"        endif";
"      elseif (op == \"includes\")";
"        if (!(o2 in o1))";
"          continue o;";
"        endif";
"      elseif (op == \"in\")";
"        if (!(o1 in o2))";
"          continue o;";
"        endif";
"      elseif (op == \"is\")";
"        if ((o1 && !o2) || (!o1 && o2))";
"          continue o;";
"        endif";
"      elseif (op == \"=~\")";
"        if (!match(o1, o2))";
"          continue o;";
"        endif";
"      else";
"        raise(E_INVARG, tostr(\"Invalid operation:  \", op));";
"      endif";
"    except (E_TYPE)";
"      o = [$ask.ERRORS -> tostr(\"type mismatch:  \", toliteral(o1), \" \", op, \" \", toliteral(o2))];";
"      break w;";
"    endtry";
"  endfor";
"  /* SELECT */";
"  if (`o[$ask.ERRORS] ! E_TYPE, E_RANGE')";
"    /* test for errors from the WHERE stage */";
"    res = {@res, o};";
"  elseif (select)";
"    r = [];";
"    for s in (select)";
"      try";
"        r[s] = this:lookup(type, o, s);";
"      except ex (\"type mismatch\", \"not found\", \"permission denied\")";
"        r = r:set_value_by_path({$ask.ERRORS, s}, ex[1]);";
"      endtry";
"    endfor";
"    res = {@res, r};";
"  else";
"    res = {@res, o};";
"  endif";
"";
"  if (limit > 0 && res)";
"    break;";
"  endif";
"endfor";
"";
"return limit > 0 ? (res ? res[1] | $failed_match) | res;";
"";
"chunk_length:131";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:E181326A5B6DCB6DAFB810C95DE78A3536E4F5BD";
"-=-=-mxyzptlk-=-=-";
.
#138:1
$private();
set_task_perms(caller_perms());
{type, target, attr} = args;
try
if (attr == $ask.ID)
return target;
elseif ((type == MAP) || (type == LIST))
return target[attr];
else
return respond_to(target, attr) ? target:(attr)() | target.(attr);
endif
except (E_TYPE)
raise("type mismatch");
except (E_RANGE, E_PROPNF)
raise("not found");
except (E_PERM)
raise("permission denied");
endtry
return;
"$private();";
"";
"set_task_perms(caller_perms());";
"";
"{type, target, attr} = args;";
"";
"try";
"  if (attr == $ask.ID)";
"    return target;";
"  elseif (type == MAP || type == LIST)";
"    return target[attr];";
"  else";
"    return respond_to(target, attr) ? target:(attr)() | target.(attr);";
"  endif";
"except (E_TYPE)";
"  raise(\"type mismatch\");";
"except (E_RANGE, E_PROPNF)";
"  raise(\"not found\");";
"except (E_PERM)";
"  raise(\"permission denied\");";
"endtry";
"";
"chunk_length:21";
"chunk_type:source";
"content_type:application/x-moocode";
"sha1:FBDFFE1F31913432DA0D40246E1FCE695664493B";
"-=-=-mxyzptlk-=-=-";
.
